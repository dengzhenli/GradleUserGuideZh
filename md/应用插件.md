

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# The Application Plugin

version 6.9-20201126230040+0000

Contents

  * Building JVM applications
  * Building applications using the Java Module System
  * Building a distribution
  * Tasks
  * Application extension
  * Licensing
  * Convention properties (deprecated)

The Application plugin facilitates creating an executable JVM application. It
makes it easy to start the application locally during development, and to
package the application as a TAR and/or ZIP including operating system
specific start scripts.

Applying the Application plugin also implicitly applies the [Java
plugin](java_plugin.html#java_plugin). The `main` source set is effectively
the “application”.

Applying the Application plugin also implicitly applies the [Distribution
plugin](distribution_plugin.html#distribution_plugin). A `main` distribution
is created that packages up the application, including code dependencies and
generated start scripts.

## Building JVM applications

To use the application plugin, include the following in your build script:

Example 1. Using the application plugin

build.gradle

    
    
    plugins {
        id 'application'
    }

build.gradle.kts

    
    
    plugins {
        application
    }

The only mandatory configuration for the plugin is the specification of the
main class (i.e. entry point) of the application.

Example 2. Configure the application main class

build.gradle

    
    
    application {
        mainClass = 'org.gradle.sample.Main'
    }

build.gradle.kts

    
    
    application {
        mainClass.set("org.gradle.sample.Main")
    }

You can run the application by executing the `run` task (type:
[JavaExec](../javadoc/org/gradle/api/tasks/JavaExec.html)). This will compile
the main source set, and launch a new JVM with its classes (along with all
runtime dependencies) as the classpath and using the specified main class. You
can launch the application in debug mode with `gradle run --debug-jvm` (see
[JavaExec.setDebug(boolean)](../javadoc/org/gradle/api/tasks/JavaExec.html#setDebug-
boolean-)).

Since Gradle 4.9, the command line arguments can be passed with `--args`. For
example, if you want to launch the application with command line arguments
`foo --bar`, you can use `gradle run --args="foo --bar"` (see
[JavaExec.setArgsString(java.lang.String)](../javadoc/org/gradle/api/tasks/JavaExec.html#setArgsString-
java.lang.String-).

If your application requires a specific set of JVM settings or system
properties, you can configure the `applicationDefaultJvmArgs` property. These
JVM arguments are applied to the `run` task and also considered in the
generated start scripts of your distribution.

Example 3. Configure default JVM settings

build.gradle

    
    
    application {
        applicationDefaultJvmArgs = ['-Dgreeting.language=en']
    }

build.gradle.kts

    
    
    application {
        applicationDefaultJvmArgs = listOf("-Dgreeting.language=en")
    }

If your application's start scripts should be in a different directory than
`bin`, you can configure the `executableDir` property.

Example 4. Configure custom directory for start scripts

build.gradle

    
    
    application {
        executableDir = 'custom_bin_dir'
    }

build.gradle.kts

    
    
    application {
        executableDir = "custom_bin_dir"
    }

## Building applications using the Java Module System

Gradle supports the building of [Java
Modules](https://www.oracle.com/corporate/features/understanding-
java-9-modules.html) as described in the [corresponding section of the Java
Library plugin
documentation](java_library_plugin.html#sec:java_library_modular). Java
modules can also be runnable and you can use the application plugin to run and
package such a modular application. For this, you need to do two things in
addition to what you do for a non-modular application.

First, you need to add a `module-info.java` file to describe your application
module. Please refer to the [Java Library plugin
documentation](java_library_plugin.html#sec:java_library_modular) for more
details on this topic.

Second, you need to tell Gradle the name of the module you want to run in
addition to the main class name like this:

Example 5. Configure the modular application's main module

build.gradle

    
    
    application {
        mainModule = 'org.gradle.sample.app' // name defined in module-info.java
        mainClass = 'org.gradle.sample.Main'
    }

build.gradle.kts

    
    
    application {
        mainModule.set("org.gradle.sample.app") // name defined in module-info.java
        mainClass.set("org.gradle.sample.Main")
    }

That's all. If you run your application, by executing the `run` task or
through a generated start script, it will run as module and respect module
boundaries at runtime. For example, reflective access to an internal package
from another module can fail.

The configured _main class_ is also baked into the `module-info.class` file of
your application Jar. If you run the modular application directly using the
`java` command, it is then sufficient to provide the module name.

You can also look at a [ready made
example](../samples/sample_java_modules_multi_project.html) that includes a
modular application as part of a multi-project.

__ |

Java Module System support is an incubating feature and therefore you need to
turn on _module path inference_ explicitly as shown below.  
  
---|---  
  
Example 6. Activate module path inference

build.gradle

    
    
    java {
        modularity.inferModulePath = true
    }

build.gradle.kts

    
    
    java {
        modularity.inferModulePath.set(true)
    }

## Building a distribution

A distribution of the application can be created, by way of the [Distribution
plugin](distribution_plugin.html#distribution_plugin) (which is automatically
applied). A `main` distribution is created with the following content:

Table 1. Distribution content Location | Content  
---|---  
  
(root dir)

|

`src/dist`  
  
`lib`

|

All runtime dependencies and main source set class files.  
  
`bin`

|

Start scripts (generated by `startScripts` task).  
  
Static files to be added to the distribution can be simply added to
`src/dist`. More advanced customization can be done by configuring the
[CopySpec](../javadoc/org/gradle/api/file/CopySpec.html) exposed by the main
distribution.

Example 7. Include output from other tasks in the application distribution

build.gradle

    
    
    task createDocs {
        def docs = file("$buildDir/docs")
        outputs.dir docs
        doLast {
            docs.mkdirs()
            new File(docs, 'readme.txt').write('Read me!')
        }
    }
    
    distributions {
        main {
            contents {
                from(createDocs) {
                    into 'docs'
                }
            }
        }
    }

build.gradle.kts

    
    
    val createDocs by tasks.registering {
        val docs = file("$buildDir/docs")
        outputs.dir(docs)
        doLast {
            docs.mkdirs()
            File(docs, "readme.txt").writeText("Read me!")
        }
    }
    
    distributions {
        main {
            contents {
                from(createDocs) {
                    into("docs")
                }
            }
        }
    }

By specifying that the distribution should include the task's output files
(see [more about tasks](more_about_tasks.html#sec:task_inputs_outputs)),
Gradle knows that the task that produces the files must be invoked before the
distribution can be assembled and will take care of this for you.

You can run `gradle installDist` to create an image of the application in
`build/install/ _projectName_`. You can run `gradle distZip` to create a ZIP
containing the distribution, `gradle distTar` to create an application TAR or
`gradle assemble` to build both.

### Customizing start script generation

The application plugin can generate Unix (suitable for Linux, macOS etc.) and
Windows start scripts out of the box. The start scripts launch a JVM with the
specified settings defined as part of the original build and runtime
environment (e.g. `JAVA_OPTS` env var). The default script templates are based
on the same scripts used to launch Gradle itself, that ship as part of a
Gradle distribution.

The start scripts are completely customizable. Please refer to the
documentation of
[CreateStartScripts](../dsl/org.gradle.jvm.application.tasks.CreateStartScripts.html)
for more details and customization examples.

## Tasks

The Application plugin adds the following tasks to the project.

`run` — [JavaExec](../dsl/org.gradle.api.tasks.JavaExec.html)

    

_Depends on_ : `classes`

Starts the application.

`startScripts` —
[CreateStartScripts](../dsl/org.gradle.jvm.application.tasks.CreateStartScripts.html)

    

_Depends on_ : `jar`

Creates OS specific scripts to run the project as a JVM application.

`installDist` — [Sync](../dsl/org.gradle.api.tasks.Sync.html)

    

_Depends on_ : `jar`, `startScripts`

Installs the application into a specified directory.

`distZip` — [Zip](../dsl/org.gradle.api.tasks.bundling.Zip.html)

    

_Depends on_ : `jar`, `startScripts`

Creates a full distribution ZIP archive including runtime libraries and OS
specific scripts.

`distTar` — [Tar](../dsl/org.gradle.api.tasks.bundling.Tar.html)

    

_Depends on_ : `jar`, `startScripts`

Creates a full distribution TAR archive including runtime libraries and OS
specific scripts.

## Application extension

The Application Plugin adds an extension to the project, which you can use to
configure its behavior. See the
[JavaApplication](../dsl/org.gradle.api.plugins.JavaApplication.html) DSL
documentation for more information on the properties available on the
extension.

You can configure the extension via the `application {}` block shown earlier,
for example using the following in your build script:

build.gradle

    
    
    application {
        executableDir = 'custom_bin_dir'
    }

build.gradle.kts

    
    
    application {
        executableDir = "custom_bin_dir"
    }

## Licensing

The Gradle start scripts that are bundled with your application are licensed
under the [Apache 2.0 Software
License](https://www.apache.org/licenses/LICENSE-2.0). This does not affect
your application, which you can license as you choose.

## Convention properties (deprecated)

This plugin also adds some convention properties to the project, which you can
use to configure its behavior. These are **deprecated** and superseded by the
extension described above. See the
[Project](../dsl/org.gradle.api.Project.html#N14FED) DSL documentation for
information on them.

Unlike the extension properties, these properties appear as top-level project
properties in the build script. For example, to change the application name
you can just add the following to your build script:

build.gradle

    
    
    applicationName = 'my-app'

build.gradle.kts

    
    
    application.applicationName = "my-app"

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

