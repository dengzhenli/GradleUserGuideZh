

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Using Ant from Gradle

version 6.9-20201126230040+0000

Contents

  * Using Ant tasks and types in your build
  * Importing an Ant build
  * Ant properties and references
  * Ant logging
  * API

Gradle provides excellent integration with Ant. You can use individual Ant
tasks or entire Ant builds in your Gradle builds. In fact, you will find that
it's far easier and more powerful using Ant tasks in a Gradle build script,
than it is to use Ant's XML format. You could even use Gradle simply as a
powerful Ant task scripting tool.

Ant can be divided into two layers. The first layer is the Ant language. It
provides the syntax for the `build.xml` file, the handling of the targets,
special constructs like macrodefs, and so on. In other words, everything
except the Ant tasks and types. Gradle understands this language, and allows
you to import your Ant `build.xml` directly into a Gradle project. You can
then use the targets of your Ant build as if they were Gradle tasks.

The second layer of Ant is its wealth of Ant tasks and types, like `javac`,
`copy` or `jar`. For this layer Gradle provides integration simply by relying
on Groovy, and the fantastic `AntBuilder`.

Finally, since build scripts are Groovy scripts, you can always execute an Ant
build as an external process. Your build script may contain statements like:
`"ant clean compile".execute()`.[1]

You can use Gradle's Ant integration as a path for migrating your build from
Ant to Gradle. For example, you could start by importing your existing Ant
build. Then you could move your dependency declarations from the Ant script to
your build file. Finally, you could move your tasks across to your build file,
or replace them with some of Gradle's plugins. This process can be done in
parts over time, and you can have a working Gradle build during the entire
process.

## Using Ant tasks and types in your build

In your build script, a property called `ant` is provided by Gradle. This is a
reference to an [AntBuilder](../javadoc/org/gradle/api/AntBuilder.html)
instance. This `AntBuilder` is used to access Ant tasks, types and properties
from your build script. There is a very simple mapping from Ant's `build.xml`
format to Groovy, which is explained below.

You execute an Ant task by calling a method on the `AntBuilder` instance. You
use the task name as the method name. For example, you execute the Ant `echo`
task by calling the `ant.echo()` method. The attributes of the Ant task are
passed as Map parameters to the method. Below is an example of the `echo`
task. Notice that we can also mix Groovy code and the Ant task markup. This
can be extremely powerful.

Example 1. Using an Ant task

build.gradle

    
    
    task hello {
        doLast {
            String greeting = 'hello from Ant'
            ant.echo(message: greeting)
        }
    }

build.gradle.kts

    
    
    tasks.register("hello") {
        doLast {
            val greeting = "hello from Ant"
            ant.withGroovyBuilder {
                "echo"("message" to greeting)
            }
        }
    }

Output of `gradle hello`

    
    
    > gradle hello
    
    > Task :hello
    [ant:echo] hello from Ant
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

You pass nested text to an Ant task by passing it as a parameter of the task
method call. In this example, we pass the message for the `echo` task as
nested text:

Example 2. Passing nested text to an Ant task

build.gradle

    
    
    task hello {
        doLast {
            ant.echo('hello from Ant')
        }
    }

build.gradle.kts

    
    
    tasks.register("hello") {
        doLast {
            ant.withGroovyBuilder {
                "echo"("message" to "hello from Ant")
            }
        }
    }

Output of `gradle hello`

    
    
    > gradle hello
    
    > Task :hello
    [ant:echo] hello from Ant
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

You pass nested elements to an Ant task inside a closure. Nested elements are
defined in the same way as tasks, by calling a method with the same name as
the element we want to define.

Example 3. Passing nested elements to an Ant task

build.gradle

    
    
    task zip {
        doLast {
            ant.zip(destfile: 'archive.zip') {
                fileset(dir: 'src') {
                    include(name: '**.xml')
                    exclude(name: '**.java')
                }
            }
        }
    }

build.gradle.kts

    
    
    tasks.register("zip") {
        doLast {
            ant.withGroovyBuilder {
                "zip"("destfile" to "archive.zip") {
                    "fileset"("dir" to "src") {
                        "include"("name" to "**.xml")
                        "exclude"("name" to "**.java")
                    }
                }
            }
        }
    }

You can access Ant types in the same way that you access tasks, using the name
of the type as the method name. The method call returns the Ant data type,
which you can then use directly in your build script. In the following
example, we create an Ant `path` object, then iterate over the contents of it.

Example 4. Using an Ant type

build.gradle

    
    
    task list {
        doLast {
            def path = ant.path {
                fileset(dir: 'libs', includes: '*.jar')
            }
            path.list().each {
                println it
            }
        }
    }

build.gradle.kts

    
    
    import org.apache.tools.ant.types.Path
    
    tasks.register("list") {
        doLast {
            val path = ant.withGroovyBuilder {
                "path" {
                    "fileset"("dir" to "libs", "includes" to "*.jar")
                }
            } as Path
            path.list().forEach {
                println(it)
            }
        }
    }

More information about `AntBuilder` can be found in 'Groovy in Action' 8.4 or
at the [Groovy Wiki](https://groovy-lang.org/scripting-ant.html).

### Using custom Ant tasks in your build

To make custom tasks available in your build, you can use the `taskdef`
(usually easier) or `typedef` Ant task, just as you would in a `build.xml`
file. You can then refer to the custom Ant task as you would a built-in Ant
task.

Example 5. Using a custom Ant task

build.gradle

    
    
    task check {
        doLast {
            ant.taskdef(resource: 'checkstyletask.properties') {
                classpath {
                    fileset(dir: 'libs', includes: '*.jar')
                }
            }
            ant.checkstyle(config: 'checkstyle.xml') {
                fileset(dir: 'src')
            }
        }
    }

build.gradle.kts

    
    
    tasks.register("check") {
        doLast {
            ant.withGroovyBuilder {
                "taskdef"("resource" to "checkstyletask.properties") {
                    "classpath" {
                        "fileset"("dir" to "libs", "includes" to "*.jar")
                    }
                }
                "checkstyle"("config" to "checkstyle.xml") {
                    "fileset"("dir" to "src")
                }
            }
        }
    }

You can use Gradle's dependency management to assemble the classpath to use
for the custom tasks. To do this, you need to define a custom configuration
for the classpath, then add some dependencies to the configuration. This is
described in more detail in [Declaring
Dependencies](declaring_dependencies.html).

Example 6. Declaring the classpath for a custom Ant task

build.gradle

    
    
    configurations {
        pmd
    }
    
    dependencies {
        pmd group: 'pmd', name: 'pmd', version: '4.2.5'
    }

build.gradle.kts

    
    
    val pmd = configurations.create("pmd")
    
    dependencies {
        pmd(group = "pmd", name = "pmd", version = "4.2.5")
    }

To use the classpath configuration, use the `asPath` property of the custom
configuration.

Example 7. Using a custom Ant task and dependency management together

build.gradle

    
    
    task check {
        doLast {
            ant.taskdef(name: 'pmd',
                        classname: 'net.sourceforge.pmd.ant.PMDTask',
                        classpath: configurations.pmd.asPath)
            ant.pmd(shortFilenames: 'true',
                    failonruleviolation: 'true',
                    rulesetfiles: file('pmd-rules.xml').toURI().toString()) {
                formatter(type: 'text', toConsole: 'true')
                fileset(dir: 'src')
            }
        }
    }

build.gradle.kts

    
    
    tasks.register("check") {
        doLast {
            ant.withGroovyBuilder {
                "taskdef"("name" to "pmd",
                          "classname" to "net.sourceforge.pmd.ant.PMDTask",
                          "classpath" to pmd.asPath)
                "pmd"("shortFilenames" to true,
                      "failonruleviolation" to true,
                      "rulesetfiles" to file("pmd-rules.xml").toURI().toString()) {
                    "formatter"("type" to "text", "toConsole" to "true")
                    "fileset"("dir" to "src")
                }
            }
        }
    }

## Importing an Ant build

You can use the `ant.importBuild()` method to import an Ant build into your
Gradle project. When you import an Ant build, each Ant target is treated as a
Gradle task. This means you can manipulate and execute the Ant targets in
exactly the same way as Gradle tasks.

Example 8. Importing an Ant build

build.gradle

    
    
    ant.importBuild 'build.xml'

build.gradle.kts

    
    
    ant.importBuild("build.xml")

build.xml

    
    
    <project>
        <target name="hello">
            <echo>Hello, from Ant</echo>
        </target>
    </project>

Output of `gradle hello`

    
    
    > gradle hello
    
    > Task :hello
    [ant:echo] Hello, from Ant
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

You can add a task which depends on an Ant target:

Example 9. Task that depends on Ant target

build.gradle

    
    
    ant.importBuild 'build.xml'
    
    task intro(dependsOn: hello) {
        doLast {
            println 'Hello, from Gradle'
        }
    }

build.gradle.kts

    
    
    ant.importBuild("build.xml")
    
    tasks.register("intro") {
        dependsOn("hello")
        doLast {
            println("Hello, from Gradle")
        }
    }

Output of `gradle intro`

    
    
    > gradle intro
    
    > Task :hello
    [ant:echo] Hello, from Ant
    
    > Task :intro
    Hello, from Gradle
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

Or, you can add behaviour to an Ant target:

Example 10. Adding behaviour to an Ant target

build.gradle

    
    
    ant.importBuild 'build.xml'
    
    hello {
        doLast {
            println 'Hello, from Gradle'
        }
    }

build.gradle.kts

    
    
    ant.importBuild("build.xml")
    
    tasks.named("hello") {
        doLast {
            println("Hello, from Gradle")
        }
    }

Output of `gradle hello`

    
    
    > gradle hello
    
    > Task :hello
    [ant:echo] Hello, from Ant
    Hello, from Gradle
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

It is also possible for an Ant target to depend on a Gradle task:

Example 11. Ant target that depends on Gradle task

build.gradle

    
    
    ant.importBuild 'build.xml'
    
    task intro {
        doLast {
            println 'Hello, from Gradle'
        }
    }

build.gradle.kts

    
    
    ant.importBuild("build.xml")
    
    tasks.register("intro") {
        doLast {
            println("Hello, from Gradle")
        }
    }

build.xml

    
    
    <project>
        <target name="hello" depends="intro">
            <echo>Hello, from Ant</echo>
        </target>
    </project>

Output of `gradle hello`

    
    
    > gradle hello
    
    > Task :intro
    Hello, from Gradle
    
    > Task :hello
    [ant:echo] Hello, from Ant
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

Sometimes it may be necessary to “rename” the task generated for an Ant target
to avoid a naming collision with existing Gradle tasks. To do this, use the
[AntBuilder.importBuild(java.lang.Object,
org.gradle.api.Transformer)](../javadoc/org/gradle/api/AntBuilder.html#importBuild-
java.lang.Object-org.gradle.api.Transformer-) method.

Example 12. Renaming imported Ant targets

build.gradle

    
    
    ant.importBuild('build.xml') { antTargetName ->
        'a-' + antTargetName
    }

build.gradle.kts

    
    
    ant.importBuild("build.xml") { antTargetName ->
        "a-" + antTargetName
    }

build.xml

    
    
    <project>
        <target name="hello">
            <echo>Hello, from Ant</echo>
        </target>
    </project>

Output of `gradle a-hello`

    
    
    > gradle a-hello
    
    > Task :a-hello
    [ant:echo] Hello, from Ant
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

Note that while the second argument to this method should be a
[Transformer](../javadoc/org/gradle/api/Transformer.html), when programming in
Groovy we can simply use a closure instead of an anonymous inner class (or
similar) due to [Groovy's support for automatically coercing closures to
single-abstract-method types](http://mrhaki.blogspot.ie/2013/11/groovy-
goodness-implicit-closure.html).

## Ant properties and references

There are several ways to set an Ant property, so that the property can be
used by Ant tasks. You can set the property directly on the `AntBuilder`
instance. The Ant properties are also available as a Map which you can change.
You can also use the Ant `property` task. Below are some examples of how to do
this.

Example 13. Setting an Ant property

build.gradle

    
    
    ant.buildDir = buildDir
    ant.properties.buildDir = buildDir
    ant.properties['buildDir'] = buildDir
    ant.property(name: 'buildDir', location: buildDir)

build.gradle.kts

    
    
    ant.setProperty("buildDir", buildDir)
    ant.properties.set("buildDir", buildDir)
    ant.properties["buildDir"] = buildDir
    ant.withGroovyBuilder {
        "property"("name" to "buildDir", "location" to "buildDir")
    }

Many Ant tasks set properties when they execute. There are several ways to get
the value of these properties. You can get the property directly from the
`AntBuilder` instance. The Ant properties are also available as a Map. Below
are some examples.

Example 14. Getting an Ant property

build.xml

    
    
    <property name="antProp" value="a property defined in an Ant build"/>

build.gradle

    
    
    println ant.antProp
    println ant.properties.antProp
    println ant.properties['antProp']

build.gradle.kts

    
    
    println(ant.getProperty("antProp"))
    println(ant.properties.get("antProp"))
    println(ant.properties["antProp"])

There are several ways to set an Ant reference:

Example 15. Setting an Ant reference

build.gradle

    
    
    ant.path(id: 'classpath', location: 'libs')
    ant.references.classpath = ant.path(location: 'libs')
    ant.references['classpath'] = ant.path(location: 'libs')

build.gradle.kts

    
    
    ant.withGroovyBuilder { "path"("id" to "classpath", "location" to "libs") }
    ant.references.set("classpath", ant.withGroovyBuilder { "path"("location" to "libs") })
    ant.references["classpath"] = ant.withGroovyBuilder { "path"("location" to "libs") }

build.xml

    
    
    <path refid="classpath"/>

There are several ways to get an Ant reference:

Example 16. Getting an Ant reference

build.xml

    
    
    <path id="antPath" location="libs"/>

build.gradle

    
    
    println ant.references.antPath
    println ant.references['antPath']

build.gradle.kts

    
    
    println(ant.references.get("antPath"))
    println(ant.references["antPath"])

## Ant logging

Gradle maps Ant message priorities to Gradle log levels so that messages
logged from Ant appear in the Gradle output. By default, these are mapped as
follows:

Table 1. Ant message priority mapping Ant Message Priority | Gradle Log Level  
---|---  
  
_VERBOSE_

|

`DEBUG`  
  
_DEBUG_

|

`DEBUG`  
  
_INFO_

|

`INFO`  
  
_WARN_

|

`WARN`  
  
_ERROR_

|

`ERROR`  
  
### Fine tuning Ant logging

The default mapping of Ant message priority to Gradle log level can sometimes
be problematic. For example, there is no message priority that maps directly
to the `LIFECYCLE` log level, which is the default for Gradle. Many Ant tasks
log messages at the _INFO_ priority, which means to expose those messages from
Gradle, a build would have to be run with the log level set to `INFO`,
potentially logging much more output than is desired.

Conversely, if an Ant task logs messages at too high of a level, to suppress
those messages would require the build to be run at a higher log level, such
as `QUIET`. However, this could result in other, desirable output being
suppressed.

To help with this, Gradle allows the user to fine tune the Ant logging and
control the mapping of message priority to Gradle log level. This is done by
setting the priority that should map to the default Gradle `LIFECYCLE` log
level using the
[AntBuilder.setLifecycleLogLevel(java.lang.String)](../javadoc/org/gradle/api/AntBuilder.html#setLifecycleLogLevel-
java.lang.String-) method. When this value is set, any Ant message logged at
the configured priority or above will be logged at least at `LIFECYCLE`. Any
Ant message logged below this priority will be logged at most at `INFO`.

For example, the following changes the mapping such that Ant _INFO_ priority
messages are exposed at the `LIFECYCLE` log level.

Example 17. Fine tuning Ant logging

build.gradle

    
    
    ant.lifecycleLogLevel = "INFO"
    
    task hello {
        doLast {
            ant.echo(level: "info", message: "hello from info priority!")
        }
    }

build.gradle.kts

    
    
    ant.lifecycleLogLevel = AntBuilder.AntMessagePriority.INFO
    
    tasks.register("hello") {
        doLast {
            ant.withGroovyBuilder {
                "echo"("level" to "info", "message" to "hello from info priority!")
            }
        }
    }

Output of `gradle hello`

    
    
    > gradle hello
    
    > Task :hello
    [ant:echo] hello from info priority!
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

On the other hand, if the `lifecycleLogLevel` was set to _ERROR_ , Ant
messages logged at the _WARN_ priority would no longer be logged at the `WARN`
log level. They would now be logged at the `INFO` level and would be
suppressed by default.

## API

The Ant integration is provided by
[AntBuilder](../javadoc/org/gradle/api/AntBuilder.html).

* * *

1. In Groovy you can execute Strings. To learn more about executing external processes with Groovy have a look in 'Groovy in Action' 9.3.2 or at the Groovy wiki 

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

