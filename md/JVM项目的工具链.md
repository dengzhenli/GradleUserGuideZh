

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Toolchains for JVM projects

version 6.9-20201126230040+0000

Contents

  * Consuming Toolchains
  * Specify custom toolchains for individual tasks
  * Auto detection of installed toolchains
  * Auto Provisioning
  * Custom Toolchain locations
  * Toolchains for plugin authors

By default, Gradle uses the same Java version for running Gradle itself and
building JVM projects.

This is not always desirable. Building projects with different Java versions
on different developer machines and CI servers may lead to unexpected issues.
Additionally, you may want to build a project using a Java version that is not
supported for running Gradle.

A Java Toolchain (from now on referred to simply as toolchain) is a set of
tools, usually taken from a local JRE/JDK installation that are used to
configure different aspects of a build. Compile tasks may use `javac` as their
compiler, test and exec tasks may use the `java` command while `javadoc` will
be used to generate documentation.

## Consuming Toolchains

A build can globally define what toolchain it targets by stating the Java
Language version it needs and optionally the vendor:

buildSrc/src/main/groovy/myproject.java-conventions.gradle

    
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(14)
        }
    }

buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

    
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(14))
        }
    }

Executing the build (e.g. using `gradle check`) will now handle several things
for you and others running your build

  1. Setup all compile, test and javadoc tasks to use the defined toolchain which may be different than the one Gradle itself uses

  2. Gradle detects locally installed JVMs

  3. Gradle chooses a JRE/JDK matching the requirements of the build (in this case a JVM supporting Java 14)

  4. If no matching JVM is found, it will automatically download a matching JDK from [AdoptOpenJDK](https://adoptopenjdk.net/)

__ |

Toolchain support is only available in the Java plugins and for the tasks they
define. For the Groovy plugin, compilation is supported but not yet Groovydoc
generation.

Support for the Scala plugin will be released later.

However, _running tests_ can leverage the toolchain support since the `Test`
task does support toolchains.  
  
---|---  
  
### Using toolchains by specific vendors

In case your build has specific requirements from the used JRE/JDK, you may
want to define the vendor for the toolchain as well.
[`JvmVendorSpec`](../javadoc/org/gradle/jvm/toolchain/JvmVendorSpec.html) has
a list of well-known JVM vendors recognized by Gradle. The advantage is that
Gradle can handle any inconsistencies across JDK versions in how exactly the
JVM encodes the vendor information.

build.gradle

    
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(11)
            vendor = JvmVendorSpec.ADOPTOPENJDK
        }
    }

build.gradle.kts

    
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(11))
            vendor.set(JvmVendorSpec.ADOPTOPENJDK)
        }
    }

If the vendor you want to target is not a known vendor, you can still restrict
the toolchain to those matching the `java.vendor` system property of the
available toolchains.

Given the snippet below, only toolchain are taken into accounts whose
`java.vendor` property contains the given match string. Matching is done case-
insensitive.

build.gradle

    
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(11)
            vendor = JvmVendorSpec.matching("customString")
        }
    }

build.gradle.kts

    
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(11))
            vendor.set(JvmVendorSpec.matching("customString"))
        }
    }

### Selecting toolchains by their virtual machine implementation

If your project requires a specific implementation, you can filter based on
the implementation as well. Currently available implementations to choose from
are:

`VENDOR_SPECIFIC`

    

Acts as a placeholder and matches any implementation from any vendor (e.g.
hotspot, zulu, …​)

`J9`

    

Matches only virtual machine implementations using the OpenJ9/IBM J9 runtime
engine.

For example, to use an [Open J9](https://www.eclipse.org/openj9/) JVM,
distributed via [AdoptOpenJDK](https://adoptopenjdk.net/), you can specify the
filter as shown in the example below.

build.gradle

    
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(11)
            vendor = JvmVendorSpec.ADOPTOPENJDK
            implementation = JvmImplementation.J9
        }
    }

build.gradle.kts

    
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(11))
            vendor.set(JvmVendorSpec.ADOPTOPENJDK)
            implementation.set(JvmImplementation.J9)
        }
    }

## Specify custom toolchains for individual tasks

In case you want to tweak which toolchain is used for a specific task, you can
specify the exact tool a task is using. For example, the `Test` task exposes a
`JavaLauncher` property that defines which java executable to use for
launching the tests.

In the example below, we configure the default toolchain to use JDK8 for
compiling and testing. Additionally, we introduce a new `Test` task that is
going to run our unit tests but using a JDK 14.

list/build.gradle

    
    
    tasks.withType(JavaCompile).configureEach {
        javaCompiler = javaToolchains.compilerFor {
            languageVersion = JavaLanguageVersion.of(8)
        }
    }
    task('testsOn14', type: Test) {
        javaLauncher = javaToolchains.launcherFor {
            languageVersion = JavaLanguageVersion.of(14)
        }
    }

list/build.gradle.kts

    
    
    tasks.withType<JavaCompile>().configureEach {
        javaCompiler.set(javaToolchains.compilerFor {
            languageVersion.set(JavaLanguageVersion.of(8))
        })
    }
    
    tasks.register<Test>("testsOn14") {
        javaLauncher.set(javaToolchains.launcherFor {
            languageVersion.set(JavaLanguageVersion.of(14))
        })
    }

Depending on the task, a JRE might be enough while for other tasks (e.g.
compilation), a JDK is required. By default, Gradle prefers installed JDKs
over JREs.

Toolchains tool providers can be obtained from the
[`javaToolchains`](../javadoc/org/gradle/jvm/toolchain/JavaToolchainService.html)
extension.

Three tools are available:

  * A `JavaCompiler` which is the tool used by the `JavaCompile` task

  * A `JavaLauncher` which is the tool used by the `JavaExec` or `Test` tasks

  * A `JavadocTool` which is the tool used by the `Javadoc` task

### Integration with tasks relying on a Java executable or Java home

Any tasks that can be configured with a path to a Java executable, or a Java
home location, can benefit from toolchains.

While you will not be able to wire a toolchain tool directly, they all have
metadata that gives access to their full path or to the path of the Java
installation they belong to.

For example, you can configure the executable for a Kotlin compile tasks as
follows:

build.gradle

    
    
    def compiler = javaToolchains.compilerFor {
        languageVersion = JavaLanguageVersion.of(11)
    }
    
    tasks.withType(KotlinJvmCompile).configureEach {
        kotlinOptions.jdkHome = compiler.get().metadata.installationPath.asFile.absolutePath
    }

build.gradle.kts

    
    
    val compiler = javaToolchains.compilerFor {
        languageVersion.set(JavaLanguageVersion.of(11))
    }
    
    tasks.withType<KotlinJvmCompile>().configureEach {
        kotlinOptions.jdkHome = compiler.get().metadata.installationPath.asFile.absolutePath
    }

Similarly, doing `compiler.get().executablePath` would give you the full path
to `javac` for the given toolchain. Please note however that this may realize
(and provision) a toolchain eagerly.

## Auto detection of installed toolchains

By default, Gradle automatically detects local JRE/JDK installations so no
further configuration is required by the user. The following is a list of
common package managers and locations that are supported by the JVM auto
detection.

Operation-system specific locations:

  * Linux

  * MacOs

  * Windows

Supported Package Managers:

  * [Asdf-vm](https://asdf-vm.com/#/)

  * [Jabba](https://github.com/shyiko/jabba)

  * [SDKMAN!](https://sdkman.io/)

### How to disable auto-detection

In order to disable auto-detection, you can use the
`org.gradle.java.installations.auto-detect` Gradle property:

  * Either start gradle using `-Porg.gradle.java.installations.auto-detect=false`

  * Or put `org.gradle.java.installations.auto-detect=false` into your `gradle.properties` file.

## Auto Provisioning

If Gradle can't find a locally available toolchain which matches the
requirements of the build, it will automatically try to download it from
AdoptOpenJDK. By default, it will request a HotSpot JDK matching the current
operating system and architecture. Provisioning JDKs are installed in the
[Gradle User Home directory](directory_layout.html#dir:gradle_user_home).

__ |

Gradle will only download JDK versions for GA releases. There is no support
for downloading early access versions.  
  
---|---  
  
By default, the public [AdoptOpenJDK APIs](https://api.adoptopenjdk.net/) are
used to determine and download a matching JDK. In case you want to use another
server that is compatible with v3 of the AdoptOpenJDK API, you can point
Gradle to use a different host. For that you use the Gradle property as in the
example below:

    
    
    org.gradle.jvm.toolchain.install.adoptopenjdk.baseUri=https://api.company.net/

__ |

Only secure protocols like `https` are accepted. This is required to make sure
no one can tamper with the download in flight.  
  
---|---  
  
### Viewing and debugging toolchains

Gradle can display the list of all detected toolchains including their
metadata.

For example, to show all toolchains of a project, run:

    
    
    gradle -q javaToolchains

Output of **`gradle -q javaToolchains`**

    
    
    > gradle -q javaToolchains
    
     + Options
         | Auto-detection:     Enabled
         | Auto-download:      Enabled
    
     + AdoptOpenJDK 1.8.0_242
         | Location:           /Users/username/myJavaInstalls/8.0.242.hs-adpt/jre
         | Language Version:   8
         | Vendor:             AdoptOpenJDK
         | Is JDK:             true
         | Detected by:        system property 'org.gradle.java.installations.paths'
    
     + OpenJDK 15-ea
         | Location:           /Users/username/.sdkman/candidates/java/15.ea.21-open
         | Language Version:   15
         | Vendor:             AdoptOpenJDK
         | Is JDK:             true
         | Detected by:        SDKMAN!
    
     + OpenJDK 16
         | Location:           /Users/user/customJdks/16.ea.20-open
         | Language Version:   16
         | Vendor:             AdoptOpenJDK
         | Is JDK:             true
         | Detected by:        environment variable 'JDK16'
    
     + Oracle JDK 1.7.0_80
         | Location:           /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre
         | Language Version:   7
         | Vendor:             Oracle
         | Is JDK:             true
         | Detected by:        macOS java_home

This can help to debug which toolchains are available to the build, how they
are detected and what kind of metadata Gradle knows about those toolchains.

### How to disable auto provisioning

In order to disable auto-provisioning, you can use the
`org.gradle.java.installations.auto-download` Gradle property:

  * Either start gradle using `-Porg.gradle.java.installations.auto-download=false`

  * Or put `org.gradle.java.installations.auto-download=false` into a `gradle.properties` file.

## Custom Toolchain locations

If auto-detecting local toolchains is not sufficient or disabled, there are
additional ways you can let Gradle know about installed toolchains.

If your setup already provides environment variables pointing to installed
JVMs, you can also let Gradle know about which environment variables to take
into account. Assuming the environment variables `JDK8` and `JRE14` point to
valid java installations, the following instructs Gradle to resolve those
environment variables and consider those installations when looking for a
matching toolchain.

    
    
    org.gradle.java.installations.fromEnv=JDK8,JRE14

Additionally, you can provide a comma-separated list of paths to specific
installations using the `org.gradle.java.installations.paths` property. For
example, using the following in your `gradle.properties` will let Gradle know
which directories to look at when detecting JVMs. Gradle will treat these
directories as possible installations but will not descend into any nested
directories.

    
    
    org.gradle.java.installations.paths=/custom/path/jdk1.8,/shared/jre11

## Toolchains for plugin authors

Custom tasks that require a tool from the JDK should expose a `Property<T>`
with the desired tool as generic type. By injecting the `JavaToolchainService`
in the plugin or task, it is also possible to wire a convention in those
properties by obtaining the `JavaToolchainSpec` from the `java` extension on
the project. The example below showcases how to use the default toolchain as
convention while allowing users to individually configure the toolchain per
task.

build.gradle

    
    
    import javax.inject.Inject;
    
    class CustomTaskUsingToolchains extends DefaultTask {
    
        @Input
        final Property<JavaLauncher> launcher = project.objects.property(JavaLauncher.class);
    
        @Inject
        CustomTaskUsingToolchains(ObjectFactory factory) {
            // Access the default toolchain
            def toolchain = project.getExtensions().getByType(JavaPluginExtension.class).toolchain
    
            // acquire a provider that returns the launcher for the toolchain
            JavaToolchainService service = project.getExtensions().getByType(JavaToolchainService.class);
            Provider<JavaLauncher> defaultLauncher = service.launcherFor(toolchain);
    
            // use it as our default for the property
            launcher.convention(defaultLauncher);
        }
    
        @TaskAction
        def showConfiguredToolchain() {
            println launcher.get().executablePath
            println launcher.get().metadata.installationPath
        }
    }
    
    plugins {
        id 'java'
    }
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(8)
        }
    }
    
    task showDefaultToolchain(type: CustomTaskUsingToolchains)
    
    task showCustomToolchain(type: CustomTaskUsingToolchains) {
        launcher = javaToolchains.launcherFor {
            languageVersion = JavaLanguageVersion.of(14)
        }
    }

build.gradle.kts

    
    
    import javax.inject.Inject;
    
    open class CustomTaskUsingToolchains : DefaultTask {
    
        @get:Input
        val launcher: Property<JavaLauncher> = project.objects.property()
    
        @Inject
        constructor() {
            // Access the default toolchain
            val toolchain = project.extensions.getByType<JavaPluginExtension>().toolchain
    
            // acquire a provider that returns the launcher for the toolchain
            val service = project.extensions.getByType<JavaToolchainService>()
            val defaultLauncher = service.launcherFor(toolchain)
    
            // use it as our default for the property
            launcher.convention(defaultLauncher);
        }
    
        @TaskAction
        fun showConfiguredToolchain() {
            println(launcher.get().executablePath)
            println(launcher.get().metadata.installationPath)
        }
    }
    
    plugins {
        java
    }
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(8))
        }
    }
    
    tasks.register<CustomTaskUsingToolchains>("showDefaultToolchain")
    
    tasks.register<CustomTaskUsingToolchains>("showCustomToolchain") {
        launcher.set(javaToolchains.launcherFor {
            languageVersion.set(JavaLanguageVersion.of(14))
        })
    }

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

