

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Handling versions which change over time

version 6.7.1

Contents

  * Declaring a dynamic version
  * Declaring a changing version
  * Controlling dynamic version caching
  * Controlling dependency caching programmatically
  * Controlling dependency caching from the command line
  * Using component selection rules

There are many situations when you want to use the latest version of a
particular module dependency, or the latest in a range of versions. This can
be a requirement during development, or you may be developing a library that
is designed to work with a range of dependency versions. You can easily depend
on these constantly changing dependencies by using a _dynamic version_. A
dynamic version can be either a version range (e.g. `2.+`) or it can be a
placeholder for the latest version available e.g. `latest.integration`.

Alternatively, the module you request can change over time even for the same
version, a so-called changing version. An example of this type of _changing
module_ is a Maven `SNAPSHOT` module, which always points at the latest
artifact published. In other words, a standard Maven snapshot is a module that
is continually evolving, it is a "changing module".

__ |

Using dynamic versions and changing modules can lead to unreproducible builds.
As new versions of a particular module are published, its API may become
incompatible with your source code. Use this feature with caution!  
  
---|---  
  
## Declaring a dynamic version

Projects might adopt a more aggressive approach for consuming dependencies to
modules. For example you might want to always integrate the latest version of
a dependency to consume cutting edge features at any given time. A _dynamic
version_ allows for resolving the latest version or the latest version of a
version range for a given module.

__ |

Using dynamic versions in a build bears the risk of potentially breaking it.
As soon as a new version of the dependency is released that contains an
incompatible API change your source code might stop compiling.  
  
---|---  
  
Example 1. Declaring a dependency with a dynamic version

build.gradle

    
    
    plugins {
        id 'java-library'
    }
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation 'org.springframework:spring-web:5.+'
    }

build.gradle.kts

    
    
    plugins {
        `java-library`
    }
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation("org.springframework:spring-web:5.+")
    }

A [build scan](https://scans.gradle.com/) can effectively visualize dynamic
dependency versions and their respective, selected versions.

![dependency management dynamic dependency build scan](img/dependency-
management-dynamic-dependency-build-scan.png)

Figure 1. Dynamic dependencies in build scan

By default, Gradle caches dynamic versions of dependencies for 24 hours.
Within this time frame, Gradle does not try to resolve newer versions from the
declared repositories. The threshold can be configured as needed for example
if you want to resolve new versions earlier.

## Declaring a changing version

A team might decide to implement a series of features before releasing a new
version of the application or library. A common strategy to allow consumers to
integrate an unfinished version of their artifacts early and often is to
release a module with a so-called _changing version_. A changing version
indicates that the feature set is still under active development and hasn't
released a stable version for general availability yet.

In Maven repositories, changing versions are commonly referred to as [snapshot
versions](https://maven.apache.org/guides/getting-
started/index.html#What_is_a_SNAPSHOT_version). Snapshot versions contain the
suffix `-SNAPSHOT`. The following example demonstrates how to declare a
snapshot version on the Spring dependency.

Example 2. Declaring a dependency with a changing version

build.gradle

    
    
    plugins {
        id 'java-library'
    }
    
    repositories {
        mavenCentral()
        maven {
            url 'https://repo.spring.io/snapshot/'
        }
    }
    
    dependencies {
        implementation 'org.springframework:spring-web:5.0.3.BUILD-SNAPSHOT'
    }

build.gradle.kts

    
    
    plugins {
        `java-library`
    }
    
    repositories {
        mavenCentral()
        maven {
            url = uri("https://repo.spring.io/snapshot/")
        }
    }
    
    dependencies {
        implementation("org.springframework:spring-web:5.0.3.BUILD-SNAPSHOT")
    }

By default, Gradle caches changing versions of dependencies for 24 hours.
Within this time frame, Gradle does not try to resolve newer versions from the
declared repositories. The threshold can be configured as needed for example
if you want to resolve new snapshot versions earlier.

Gradle is flexible enough to treat any version as changing version e.g. if you
wanted to model snapshot behavior for an Ivy module. All you need to do is to
set the property
[ExternalModuleDependency.setChanging(boolean)](../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html#setChanging-
boolean-) to `true`.

## Controlling dynamic version caching

By default, Gradle caches dynamic versions and changing modules for 24 hours.
During that time frame Gradle does not contact any of the declared, remote
repositories for new versions. If you want Gradle to check the remote
repository more frequently or with every execution of your build, then you
will need to change the time to live (TTL) threshold.

__ |

Using a short TTL threshold for dynamic or changing versions may result in
longer build times due to the increased number of HTTP(s) calls.  
  
---|---  
  
You can override the default cache modes using command line options. You can
also change the cache expiry times in your build programmatically using the
resolution strategy.

## Controlling dependency caching programmatically

You can fine-tune certain aspects of caching programmatically using the
[ResolutionStrategy](../javadoc/org/gradle/api/artifacts/ResolutionStrategy.html)
for a configuration. The programmatic approach is useful if you would like to
change the settings permanently.

By default, Gradle caches dynamic versions for 24 hours. To change how long
Gradle will cache the resolved version for a dynamic version, use:

Example 3. Dynamic version cache control

build.gradle

    
    
    configurations.all {
        resolutionStrategy.cacheDynamicVersionsFor 10, 'minutes'
    }

build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.cacheDynamicVersionsFor(10, "minutes")
    }

By default, Gradle caches changing modules for 24 hours. To change how long
Gradle will cache the meta-data and artifacts for a changing module, use:

Example 4. Changing module cache control

build.gradle

    
    
    configurations.all {
        resolutionStrategy.cacheChangingModulesFor 4, 'hours'
    }

build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.cacheChangingModulesFor(4, "hours")
    }

## Controlling dependency caching from the command line

### Avoiding network access with offline mode

The `--offline` command line switch tells Gradle to always use dependency
modules from the cache, regardless if they are due to be checked again. When
running with offline, Gradle will never attempt to access the network to
perform dependency resolution. If required modules are not present in the
dependency cache, build execution will fail.

### Refreshing dependencies

You can control the behavior of dependency caching for a distinct build
invocation from the command line. Command line options are helpful for making
a selective, ad-hoc choice for a single execution of the build.

At times, the Gradle Dependency Cache can become out of sync with the actual
state of the configured repositories. Perhaps a repository was initially
misconfigured, or perhaps a "non-changing" module was published incorrectly.
To refresh all dependencies in the dependency cache, use the `--refresh-
dependencies` option on the command line.

The `--refresh-dependencies` option tells Gradle to ignore all cached entries
for resolved modules and artifacts. A fresh resolve will be performed against
all configured repositories, with dynamic versions recalculated, modules
refreshed, and artifacts downloaded. However, where possible Gradle will check
if the previously downloaded artifacts are valid before downloading again.
This is done by comparing published SHA1 values in the repository with the
SHA1 values for existing downloaded artifacts.

  * new versions of dynamic dependencies

  * new versions of changing modules (modules which use the same version string but can have different contents)

__ |

Refreshing dependencies will cause Gradle to invalidate its listing caches.
However:

  * it will perform HTTP HEAD requests on metadata files but _will not re-download them_ if they are identical

  * it will perform HTTP HEAD requests on artifact files but _will not re-download them_ if they are identical

In other words, refreshing dependencies _only_ has an impact if you actually
use dynamic dependencies _or_ that you have changing dependencies that you
were not aware of (in which case it is your responsibility to declare them
correctly to Gradle as changing dependencies).

It's a common misconception to think that using `--refresh-dependencies` will
force download of dependencies. This is **not** the case: Gradle will only
perform what is strictly required to refresh the dynamic dependencies. This
_may_ involve downloading new listing or metadata files, or even artifacts,
but if nothing changed, the impact is minimal.  
  
---|---  
  
## Using component selection rules

Component selection rules may influence which component instance should be
selected when multiple versions are available that match a version selector.
Rules are applied against every available version and allow the version to be
explicitly rejected by rule. This allows Gradle to ignore any component
instance that does not satisfy conditions set by the rule. Examples include:

  * For a dynamic version like `1.+` certain versions may be explicitly rejected from selection.

  * For a static version like `1.4` an instance may be rejected based on extra component metadata such as the Ivy branch attribute, allowing an instance from a subsequent repository to be used.

Rules are configured via the
[ComponentSelectionRules](../dsl/org.gradle.api.artifacts.ComponentSelectionRules.html)
object. Each rule configured will be called with a
[ComponentSelection](../dsl/org.gradle.api.artifacts.ComponentSelection.html)
object as an argument which contains information about the candidate version
being considered. Calling
[ComponentSelection.reject(java.lang.String)](../dsl/org.gradle.api.artifacts.ComponentSelection.html#org.gradle.api.artifacts.ComponentSelection:reject\(java.lang.String\))
causes the given candidate version to be explicitly rejected, in which case
the candidate will not be considered for the selector.

The following example shows a rule that disallows a particular version of a
module but allows the dynamic version to choose the next best candidate.

Example 5. Component selection rule

build.gradle

    
    
    configurations {
        rejectConfig {
            resolutionStrategy {
                componentSelection {
                    // Accept the highest version matching the requested version that isn't '1.5'
                    all { ComponentSelection selection ->
                        if (selection.candidate.group == 'org.sample' && selection.candidate.module == 'api' && selection.candidate.version == '1.5') {
                            selection.reject("version 1.5 is broken for 'org.sample:api'")
                        }
                    }
                }
            }
        }
    }
    
    dependencies {
        rejectConfig "org.sample:api:1.+"
    }

build.gradle.kts

    
    
    configurations {
        create("rejectConfig") {
            resolutionStrategy {
                componentSelection {
                    // Accept the highest version matching the requested version that isn't '1.5'
                    all {
                        if (candidate.group == "org.sample" && candidate.module == "api" && candidate.version == "1.5") {
                            reject("version 1.5 is broken for 'org.sample:api'")
                        }
                    }
                }
            }
        }
    }
    
    dependencies {
        "rejectConfig"("org.sample:api:1.+")
    }

Note that version selection is applied starting with the highest version
first. The version selected will be the first version found that all component
selection rules accept. A version is considered accepted if no rule explicitly
rejects it.

Similarly, rules can be targeted at specific modules. Modules must be
specified in the form of `group:module`.

Example 6. Component selection rule with module target

build.gradle

    
    
    configurations {
        targetConfig {
            resolutionStrategy {
                componentSelection {
                    withModule("org.sample:api") { ComponentSelection selection ->
                        if (selection.candidate.version == "1.5") {
                            selection.reject("version 1.5 is broken for 'org.sample:api'")
                        }
                    }
                }
            }
        }
    }

build.gradle.kts

    
    
    configurations {
        create("targetConfig") {
            resolutionStrategy {
                componentSelection {
                    withModule("org.sample:api") {
                        if (candidate.version == "1.5") {
                            reject("version 1.5 is broken for 'org.sample:api'")
                        }
                    }
                }
            }
        }
    }

Component selection rules can also consider component metadata when selecting
a version. Possible additional metadata that can be considered are
[ComponentMetadata](../javadoc/org/gradle/api/artifacts/ComponentMetadata.html)
and
[IvyModuleDescriptor](../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html).
Note that this extra information may not always be available and thus should
be checked for `null` values.

Example 7. Component selection rule with metadata

build.gradle

    
    
    configurations {
        metadataRulesConfig {
            resolutionStrategy {
                componentSelection {
                    // Reject any versions with a status of 'experimental'
                    all { ComponentSelection selection ->
                        if (selection.candidate.group == 'org.sample' && selection.metadata?.status == 'experimental') {
                            selection.reject("don't use experimental candidates from 'org.sample'")
                        }
                    }
                    // Accept the highest version with either a "release" branch or a status of 'milestone'
                    withModule('org.sample:api') { ComponentSelection selection ->
                        if (selection.getDescriptor(IvyModuleDescriptor)?.branch != "release" && selection.metadata?.status != 'milestone') {
                            selection.reject("'org.sample:api' must have testing branch or milestone status")
                        }
                    }
                }
            }
        }
    }

build.gradle.kts

    
    
    configurations {
        create("metadataRulesConfig") {
            resolutionStrategy {
                componentSelection {
                    // Reject any versions with a status of 'experimental'
                    all {
                        if (candidate.group == "org.sample" && metadata?.status == "experimental") {
                            reject("don't use experimental candidates from 'org.sample'")
                        }
                    }
                    // Accept the highest version with either a "release" branch or a status of 'milestone'
                    withModule("org.sample:api") {
                        if (getDescriptor(IvyModuleDescriptor::class)?.branch != "release" && metadata?.status != "milestone") {
                            reject("'org.sample:api' must have testing branch or milestone status")
                        }
                    }
                }
            }
        }
    }

Note that a
[ComponentSelection](../dsl/org.gradle.api.artifacts.ComponentSelection.html)
argument is _always_ required as parameter when declaring a component
selection rule.

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

