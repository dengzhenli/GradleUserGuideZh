

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Building Java & JVM projects

version 6.9-20201126230040+0000

Contents

  * Introduction
  * Declaring your source files via source sets
  * Managing your dependencies
  * Compiling your code
  * Managing resources
  * Running tests
  * Packaging and publishing
  * Generating API documentation
  * Cleaning the build
  * Building JVM components
  * Building Java libraries
  * Building Java applications
  * Building Java web applications
  * Building Java EE applications
  * Building Java Platforms
  * Enabling Java preview features
  * Building other JVM language projects

Gradle uses a convention-over-configuration approach to building JVM-based
projects that borrows several conventions from Apache Maven. In particular, it
uses the same default directory structure for source files and resources, and
it works with Maven-compatible repositories.

We will look at Java projects in detail in this chapter, but most of the
topics apply to other supported JVM languages as well, such as
[Kotlin](https://kotlinlang.org/docs/reference/using-gradle.html#targeting-
the-jvm), [Groovy](groovy_plugin.html#groovy_plugin) and
[Scala](scala_plugin.html#scala_plugin). If you don't have much experience
with building JVM-based projects with Gradle, take a look at the [Java
samples](../samples/index.html#java) for step-by-step instructions on how to
build various types of basic Java projects.

__ |

The example in this section use the Java Library Plugin. However the described
features are shared by all JVM plugins. Specifics of the different plugins are
available in their dedicated documentation.  
  
---|---  
  
__ |

There are a number of hands-on samples that you can explore for
[Java](../samples/index.html#java), [Groovy](../samples/index.html#groovy),
[Scala](../samples/index.html#scala) and
[Kotlin](../samples/index.html#kotlin)  
  
---|---  
  
## Introduction

The simplest build script for a Java project applies the [Java Library
Plugin](java_library_plugin.html) and optionally sets the project version and
selects the [Java toolchain](toolchains.html) to use:

Example 1. Applying the Java Library Plugin

build.gradle

    
    
    plugins {
        id 'java-library'
    }
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(11)
        }
    }
    
    version = '1.2.1'

build.gradle.kts

    
    
    plugins {
        `java-library`
    }
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(11))
        }
    }
    
    version = "1.2.1"

By applying the Java Library Plugin, you get a whole host of features:

  * A `compileJava` task that compiles all the Java source files under _src/main/java_

  * A `compileTestJava` task for source files under _src/test/java_

  * A `test` task that runs the tests from _src/test/java_

  * A `jar` task that packages the `main` compiled classes and resources from _src/main/resources_ into a single JAR named _< project>-<version>.jar_

  * A `javadoc` task that generates Javadoc for the `main` classes

This isn't sufficient to build any non-trivial Java project — at the very
least, you'll probably have some file dependencies. But it means that your
build script only needs the information that is specific to _your_ project.

__ |

Although the properties in the example are optional, we recommend that you
specify them in your projects. The toolchain options protects against problems
with the project being built with different Java versions. The version string
is important for tracking the progression of the project. The project version
is also used in archive names by default.  
  
---|---  
  
The Java Library Plugin also integrates the above tasks into the standard
[Base Plugin lifecycle tasks](base_plugin.html#sec:base_tasks):

  * `jar` is attached to `assemble` [1]

  * `test` is attached to `check`

The rest of the chapter explains the different avenues for customizing the
build to your requirements. You will also see later how to adjust the build
for libraries, applications, web apps and enterprise apps.

## Declaring your source files via source sets

Gradle's Java support was the first to introduce a new concept for building
source-based projects: _source sets_. The main idea is that source files and
resources are often logically grouped by type, such as application code, unit
tests and integration tests. Each logical group typically has its own sets of
file dependencies, classpaths, and more. Significantly, the files that form a
source set _don 't have to be located in the same directory_!

Source sets are a powerful concept that tie together several aspects of
compilation:

  * the source files and where they're located

  * the compilation classpath, including any required dependencies (via Gradle [configurations](dependency_management_terminology.html#sub:terminology_configuration))

  * where the compiled class files are placed

You can see how these relate to one another in this diagram:

![java sourcesets compilation](img/java-sourcesets-compilation.png)

Figure 1. Source sets and Java compilation

The shaded boxes represent properties of the source set itself. On top of
that, the Java Library Plugin automatically creates a compilation task for
every source set you or a plugin defines — named `compile _SourceSet_ Java` —
and several [dependency
configurations](java_plugin.html#java_source_set_configurations).

__ |

The `main` source set

Most language plugins, Java included, automatically create a source set called
`main`, which is used for the project's production code. This source set is
special in that its name is not included in the names of the configurations
and tasks, hence why you have just a `compileJava` task and `compileOnly` and
`implementation` configurations rather than `compileMainJava`,
`mainCompileOnly` and `mainImplementation` respectively.  
  
---|---  
  
Java projects typically include resources other than source files, such as
properties files, that may need processing — for example by replacing tokens
within the files — and packaging within the final JAR. The Java Library Plugin
handles this by automatically creating a dedicated task for each defined
source set called `process _SourceSet_ Resources` (or `processResources` for
the `main` source set). The following diagram shows how the source set fits in
with this task:

![java sourcesets process resources](img/java-sourcesets-process-
resources.png)

Figure 2. Processing non-source files for a source set

As before, the shaded boxes represent properties of the source set, which in
this case comprises the locations of the resource files and where they are
copied to.

In addition to the `main` source set, the Java Library Plugin defines a `test`
source set that represents the project's tests. This source set is used by the
`test` task, which runs the tests. You can learn more about this task and
related topics in the [Java testing](java_testing.html#java_testing) chapter.

Projects typically use this source set for unit tests, but you can also use it
for integration, acceptance and other types of test if you wish. The
alternative approach is to define a new source set for each of your other test
types, which is typically done for one or both of the following reasons:

  * You want to keep the tests separate from one another for aesthetics and manageability

  * The different test types require different compilation or runtime classpaths or some other difference in setup

You can see an example of this approach in the Java testing chapter, which
shows you [how to set up integration
tests](java_testing.html#sec:configuring_java_integration_tests) in a project.

You'll learn more about source sets and the features they provide in:

  * Customizing file and directory locations

  * [Configuring Java integration tests](java_testing.html#sec:configuring_java_integration_tests)

## Managing your dependencies

The vast majority of Java projects rely on libraries, so managing a project's
dependencies is an important part of building a Java project. Dependency
management is a big topic, so we will focus on the basics for Java projects
here. If you'd like to dive into the detail, check out the [introduction to
dependency management](core_dependency_management.html).

Specifying the dependencies for your Java project requires just three pieces
of information:

  * Which dependency you need, such as a name and version

  * What it's needed for, e.g. compilation or running

  * Where to look for it

The first two are specified in a `dependencies {}` block and the third in a
`repositories {}` block. For example, to tell Gradle that your project
requires version 3.6.7 of [Hibernate](http://hibernate.org/) Core to compile
and run your production code, and that you want to download the library from
the Maven Central repository, you can use the following fragment:

Example 2. Declaring dependencies

build.gradle

    
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation 'org.hibernate:hibernate-core:3.6.7.Final'
    }

build.gradle.kts

    
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation("org.hibernate:hibernate-core:3.6.7.Final")
    }

The Gradle terminology for the three elements is as follows:

  * _Repository_ (ex: `mavenCentral()`) — where to look for the modules you declare as dependencies

  * _Configuration_ (ex: `implementation`) — a named collection of dependencies, grouped together for a specific goal such as compiling or running a module — a more flexible form of Maven scopes

  * _Module coordinate_ (ex: `org.hibernate:hibernate-core-3.6.7.Final`) — the ID of the dependency, usually in the form ' _< group>_: _< module>_: _< version>_' (or ' _< groupId>_: _< artifactId>_: _< version>_' in Maven terminology)

You can find a more comprehensive glossary of dependency management terms
[here](dependency_management_terminology.html).

As far as configurations go, the main ones of interest are:

  * `compileOnly` — for dependencies that are necessary to compile your production code but shouldn't be part of the runtime classpath

  * `implementation` (supersedes `compile`) — used for compilation and runtime

  * `runtimeOnly` (supersedes `runtime`) — only used at runtime, not for compilation

  * `testCompileOnly` — same as `compileOnly` except it's for the tests

  * `testImplementation` — test equivalent of `implementation`

  * `testRuntimeOnly` — test equivalent of `runtimeOnly`

You can learn more about these and how they relate to one another in the
[plugin reference
chapter](java_plugin.html#sec:java_plugin_and_dependency_management).

Be aware that the [Java Library
Plugin](java_library_plugin.html#java_library_plugin) offers two additional
configurations — `api` and `compileOnlyApi` — for dependencies that are
required for compiling both the module and any modules that depend on it.

__ |

Why no `compile` configuration?

The Java Library Plugin has historically used the `compile` configuration for
dependencies that are required to both compile and run a project's production
code. It is now deprecated, and will issue warnings when used, because it
doesn't distinguish between dependencies that impact the public API of a Java
library project and those that don't. You can learn more about the importance
of this distinction in Building Java libraries.  
  
---|---  
  
We have only scratched the surface here, so we recommend that you read the
dedicated dependency management chapters once you're comfortable with the
basics of building Java projects with Gradle. Some common scenarios that
require further reading include:

  * Defining a custom [Maven-](declaring_repositories.html#sec:maven_repo) or [Ivy-compatible](declaring_repositories.html#sec:ivy_repositories) repository

  * Using dependencies from a [local filesystem directory](declaring_repositories.html#sub:flat_dir_resolver)

  * Declaring dependencies with [changing](dynamic_versions.html#sub:declaring_dependency_with_changing_version) (e.g. SNAPSHOT) and [dynamic](dynamic_versions.html#sub:declaring_dependency_with_dynamic_version) (range) versions

  * Declaring a sibling [project as a dependency](declaring_dependencies.html#sub:project_dependencies)

  * [Controlling transitive dependencies and their versions](dependency_constraints.html)

  * Testing your fixes to a 3rd-party dependency via [composite builds](composite_builds.html#composite_builds) (a better alternative to publishing to and consuming from [Maven Local](declaring_repositories.html#sub:maven_local))

You'll discover that Gradle has a rich API for working with dependencies — one
that takes time to master, but is straightforward to use for common scenarios.

## Compiling your code

Compiling both your production and test code can be trivially easy if you
follow the conventions:

  1. Put your production source code under the _src/main/java_ directory

  2. Put your test source code under _src/test/java_

  3. Declare your production compile dependencies in the `compileOnly` or `implementation` configurations (see previous section)

  4. Declare your test compile dependencies in the `testCompileOnly` or `testImplementation` configurations

  5. Run the `compileJava` task for the production code and `compileTestJava` for the tests

Other JVM language plugins, such as the one for
[Groovy](groovy_plugin.html#groovy_plugin), follow the same pattern of
conventions. We recommend that you follow these conventions wherever possible,
but you don't have to. There are several options for customization, as you'll
see next.

### Customizing file and directory locations

Imagine you have a legacy project that uses an _src_ directory for the
production code and _test_ for the test code. The conventional directory
structure won't work, so you need to tell Gradle where to find the source
files. You do that via source set configuration.

Each source set defines where its source code resides, along with the
resources and the output directory for the class files. You can override the
convention values by using the following syntax:

Example 3. Declaring custom source directories

build.gradle

    
    
    sourceSets {
        main {
             java {
                srcDirs = ['src']
             }
        }
    
        test {
            java {
                srcDirs = ['test']
            }
        }
    }

build.gradle.kts

    
    
    sourceSets {
        main {
            java {
                setSrcDirs(listOf("src"))
            }
        }
    
        test {
            java {
                setSrcDirs(listOf("test"))
            }
        }
    }

Now Gradle will only search directly in _src_ and _test_ for the respective
source code. What if you don't want to override the convention, but simply
want to _add_ an extra source directory, perhaps one that contains some third-
party source code you want to keep separate? The syntax is similar:

Example 4. Declaring custom source directories additively

build.gradle

    
    
    sourceSets {
        main {
            java {
                srcDir 'thirdParty/src/main/java'
            }
        }
    }

build.gradle.kts

    
    
    sourceSets {
        main {
            java {
                srcDir("thirdParty/src/main/java")
            }
        }
    }

Crucially, we're using the _method_ `srcDir()` here to append a directory
path, whereas setting the `srcDirs` property replaces any existing values.
This is a common convention in Gradle: setting a property replaces values,
while the corresponding method appends values.

You can see all the properties and methods available on source sets in the DSL
reference for [SourceSet](../dsl/org.gradle.api.tasks.SourceSet.html) and
[SourceDirectorySet](../dsl/org.gradle.api.file.SourceDirectorySet.html). Note
that `srcDirs` and `srcDir()` are both on `SourceDirectorySet`.

### Changing compiler options

Most of the compiler options are accessible through the corresponding task,
such as `compileJava` and `compileTestJava`. These tasks are of type
[JavaCompile](../dsl/org.gradle.api.tasks.compile.JavaCompile.html), so read
the task reference for an up-to-date and comprehensive list of the options.

For example, if you want to use a separate JVM process for the compiler and
prevent compilation failures from failing the build, you can use this
configuration:

Example 5. Setting Java compiler options

build.gradle

    
    
    compileJava {
        options.incremental = true
        options.fork = true
        options.failOnError = false
    }

build.gradle.kts

    
    
    tasks.compileJava {
        options.isIncremental = true
        options.isFork = true
        options.isFailOnError = false
    }

That's also how you can change the verbosity of the compiler, disable debug
output in the byte code and configure where the compiler can find annotation
processors.

### Targeting a specific Java version

By default, Gradle will compile Java code to the language level of the JVM
running Gradle. With the usage of [Java toolchains](toolchains.html), you can
break that link by making sure a given Java version, defined by the build, is
used for compilation, execution and documentation. It is however possible to
override some compiler and execution options at the task level.

Since version 9, the Java compiler can be configured to produce bytecode for
an older Java version while making sure the code does not use any APIs from a
more recent version. Gradle now supports this
[release](../dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:release)
flag on `CompileOptions` directly for Java compilation. This option takes
precedence over the properties described below.

__ |

Due to a [bug in Java 9](https://bugs.openjdk.java.net/browse/JDK-8139607)
that was fixed in Java 10, Gradle cannot leverage the `release` flag when
compiling with Java 9.  
  
---|---  
  
Example 6. Setting Java release flag

build.gradle

    
    
    compileJava {
        options.release = 7
    }

build.gradle.kts

    
    
    tasks.compileJava {
        options.release.set(7)
    }

Historical options for the Java compiler remain available:

`sourceCompatibility`

    

Defines which language version of Java your source files should be treated as.

`targetCompatibility`

    

Defines the minimum JVM version your code should run on, i.e. it determines
the version of byte code the compiler generates.

These options can be set per
[JavaCompile](../dsl/org.gradle.api.tasks.compile.JavaCompile.html) task, or
on the `java { }` extension for all compile tasks, using properties with the
same names.

__ |

Using a toolchain makes it illegal to configure the `sourceCompatibility` or
`targetCompatibility` at the `java { }` extension level.  
  
---|---  
  
However, these options do not protect against the use of APIs introduced in
later Java versions.

#### Compiling and testing Java 6/7

Gradle can only run on Java version 8 or higher. Gradle still supports
compiling, testing, generating Javadoc and executing applications for Java 6
and Java 7. Java 5 and below are not supported.

__ |

If using Java 10+, leveraging the `release` flag might be an easier solution,
see above.  
  
---|---  
  
To use Java 6 or Java 7, the following tasks need to be configured:

  * `JavaCompile` task to fork and use the correct Java home

  * `Javadoc` task to use the correct `javadoc` executable

  * `Test` and the `JavaExec` task to use the correct `java` executable.

With the usage of Java toolchains, this can be done as follows:

#### Example: Configure Java 7 build

build.gradle

    
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(7)
        }
    }

build.gradle.kts

    
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(7))
        }
    }

The only requirement is that Java 7 is installed and has to be either in [a
location Gradle can detect automatically](toolchains.html#sec:auto_detection)
or [explicitly configured](toolchains.html#sec:custom_loc).

### Compiling independent sources separately

Most projects have at least two independent sets of sources: the production
code and the test code. Gradle already makes this scenario part of its Java
convention, but what if you have other sets of sources? One of the most common
scenarios is when you have separate integration tests of some form or other.
In that case, a custom source set may be just what you need.

You can see a complete example for setting up integration tests in the [Java
testing chapter](java_testing.html#sec:configuring_java_integration_tests).
You can set up other source sets that fulfil different roles in the same way.
The question then becomes: when should you define a custom source set?

To answer that question, consider whether the sources:

  1. Need to be compiled with a unique classpath

  2. Generate classes that are handled differently from the `main` and `test` ones

  3. Form a natural part of the project

If your answer to both 3 and either one of the others is yes, then a custom
source set is probably the right approach. For example, integration tests are
typically part of the project because they test the code in `main`. In
addition, they often have either their own dependencies independent of the
`test` source set or they need to be run with a custom `Test` task.

Other common scenarios are less clear cut and may have better solutions. For
example:

  * Separate API and implementation JARs — it may make sense to have these as separate projects, particularly if you already have a multi-project build

  * Generated sources — if the resulting sources should be compiled with the production code, add their path(s) to the `main` source set and make sure that the `compileJava` task depends on the task that generates the sources

If you're unsure whether to create a custom source set or not, then go ahead
and do so. It should be straightforward and if it's not, then it's probably
not the right tool for the job.

## Managing resources

Many Java projects make use of resources beyond source files, such as images,
configuration files and localization data. Sometimes these files simply need
to be packaged unchanged and sometimes they need to be processed as template
files or in some other way. Either way, the Java Library Plugin adds a
specific [Copy](../dsl/org.gradle.api.tasks.Copy.html) task for each source
set that handles the processing of its associated resources.

The task's name follows the convention of `process _SourceSet_ Resources` — or
`processResources` for the `main` source set — and it will automatically copy
any files in _src/[sourceSet]/resources_ to a directory that will be included
in the production JAR. This target directory will also be included in the
runtime classpath of the tests.

Since `processResources` is an instance of the `Copy` task, you can perform
any of the processing described in the [Working With
Files](working_with_files.html#sec:copying_files) chapter.

### Java properties files and reproducible builds

You can easily create Java properties files via the
[WriteProperties](../dsl/org.gradle.api.tasks.WriteProperties.html) task,
which fixes a well-known problem with `Properties.store()` that can reduce the
usefulness of [incremental
builds](more_about_tasks.html#sec:up_to_date_checks).

The standard Java API for writing properties files produces a unique file
every time, even when the same properties and values are used, because it
includes a timestamp in the comments. Gradle's `WriteProperties` task
generates exactly the same output byte-for-byte if none of the properties have
changed. This is achieved by a few tweaks to how a properties file is
generated:

  * no timestamp comment is added to the output

  * the line separator is system independent, but can be configured explicitly (it defaults to `'\n'`)

  * the properties are sorted alphabetically

Sometimes it can be desirable to recreate archives in a byte for byte way on
different machines. You want to be sure that building an artifact from source
code produces the same result, byte for byte, no matter when and where it is
built. This is necessary for projects like reproducible-builds.org.

These tweaks not only lead to better incremental build integration, but they
also help with [reproducible builds](https://reproducible-builds.org). In
essence, reproducible builds guarantee that you will see the same results from
a build execution — including test results and production binaries — no matter
when or on what system you run it.

## Running tests

Alongside providing automatic compilation of unit tests in _src/test/java_ ,
the Java Library Plugin has native support for running tests that use JUnit 3,
4 & 5 (JUnit 5 support [came in Gradle
4.6](https://docs.gradle.org/4.6/release-notes.html#junit-5-support)) and
TestNG. You get:

  * An automatic `test` task of type [Test](../dsl/org.gradle.api.tasks.testing.Test.html), using the `test` source set

  * An HTML test report that includes the results from _all_ `Test` tasks that run

  * Easy filtering of which tests to run

  * Fine-grained control over how the tests are run

  * The opportunity to create your own test execution and test reporting tasks

You do _not_ get a `Test` task for every source set you declare, since not
every source set represents tests! That's why you typically need to create
your own `Test` tasks for things like integration and acceptance tests if they
can't be included with the `test` source set.

As there is a lot to cover when it comes to testing, the topic has its [own
chapter](java_testing.html#java_testing) in which we look at:

  * How tests are run

  * How to run a subset of tests via filtering

  * How Gradle discovers tests

  * How to configure test reporting and add your own reporting tasks

  * How to make use of specific JUnit and TestNG features

You can also learn more about configuring tests in the DSL reference for
[Test](../dsl/org.gradle.api.tasks.testing.Test.html).

## Packaging and publishing

How you package and potentially publish your Java project depends on what type
of project it is. Libraries, applications, web applications and enterprise
applications all have differing requirements. In this section, we will focus
on the bare bones provided by the Java Library Plugin.

By default, the Java Library Plugin provides the `jar` task that packages all
the compiled production classes and resources into a single JAR. This JAR is
also automatically built by the `assemble` task. Furthermore, the plugin can
be configured to provide the `javadocJar` and `sourcesJar` tasks to package
Javadoc and source code if so desired. If a publishing plugin is used, these
tasks will automatically run during publishing or can be called directly.

Example 7. Configure a project to publish Javadoc and sources

build.gradle

    
    
    java {
        withJavadocJar()
        withSourcesJar()
    }

build.gradle.kts

    
    
    java {
        withJavadocJar()
        withSourcesJar()
    }

If you want to create an 'uber' (AKA 'fat') JAR, then you can use a task
definition like this:

Example 8. Creating a Java uber or fat JAR

build.gradle

    
    
    plugins {
        id 'java'
    }
    
    version = '1.0.0'
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation 'commons-io:commons-io:2.6'
    }
    
    task uberJar(type: Jar) {
        archiveClassifier = 'uber'
    
        from sourceSets.main.output
    
        dependsOn configurations.runtimeClasspath
        from {
            configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }.collect { zipTree(it) }
        }
    }

build.gradle.kts

    
    
    plugins {
        java
    }
    
    version = "1.0.0"
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation("commons-io:commons-io:2.6")
    }
    
    tasks.register<Jar>("uberJar") {
        archiveClassifier.set("uber")
    
        from(sourceSets.main.get().output)
    
        dependsOn(configurations.runtimeClasspath)
        from({
            configurations.runtimeClasspath.get().filter { it.name.endsWith("jar") }.map { zipTree(it) }
        })
    }

See [Jar](../dsl/org.gradle.api.tasks.bundling.Jar.html) for more details on
the configuration options available to you. And note that you need to use
`archiveClassifier` rather than `archiveAppendix` here for correct publication
of the JAR.

You can use one of the publishing plugins to publish the JARs created by a
Java project:

  * [Maven Publish Plugin](publishing_maven.html#publishing_maven)

  * [Ivy Publish Plugin](publishing_ivy.html#publishing_ivy)

### Modifying the JAR manifest

Each instance of the `Jar`, `War` and `Ear` tasks has a `manifest` property
that allows you to customize the _MANIFEST.MF_ file that goes into the
corresponding archive. The following example demonstrates how to set
attributes in the JAR's manifest:

Example 9. Customization of MANIFEST.MF

build.gradle

    
    
    jar {
        manifest {
            attributes("Implementation-Title": "Gradle",
                       "Implementation-Version": archiveVersion)
        }
    }

build.gradle.kts

    
    
    tasks.jar {
        manifest {
            attributes(
                "Implementation-Title" to "Gradle",
                "Implementation-Version" to archiveVersion
            )
        }
    }

See [Manifest](../javadoc/org/gradle/api/java/archives/Manifest.html) for the
configuration options it provides.

You can also create standalone instances of `Manifest`. One reason for doing
so is to share manifest information between JARs. The following example
demonstrates how to share common attributes between JARs:

Example 10. Creating a manifest object.

build.gradle

    
    
    ext.sharedManifest = manifest {
        attributes("Implementation-Title": "Gradle",
                   "Implementation-Version": version)
    }
    task fooJar(type: Jar) {
        manifest = project.manifest {
            from sharedManifest
        }
    }

build.gradle.kts

    
    
    val sharedManifest = the<JavaPluginConvention>().manifest {
        attributes (
            "Implementation-Title" to "Gradle",
            "Implementation-Version" to version
        )
    }
    
    tasks.register<Jar>("fooJar") {
        manifest = project.the<JavaPluginConvention>().manifest {
            from(sharedManifest)
        }
    }

Another option available to you is to merge manifests into a single `Manifest`
object. Those source manifests can take the form of a text for or another
`Manifest` object. In the following example, the source manifests are all text
files except for `sharedManifest`, which is the `Manifest` object from the
previous example:

Example 11. Separate MANIFEST.MF for a particular archive

build.gradle

    
    
    task barJar(type: Jar) {
        manifest {
            attributes key1: 'value1'
            from sharedManifest, 'src/config/basemanifest.txt'
            from(['src/config/javabasemanifest.txt', 'src/config/libbasemanifest.txt']) {
                eachEntry { details ->
                    if (details.baseValue != details.mergeValue) {
                        details.value = baseValue
                    }
                    if (details.key == 'foo') {
                        details.exclude()
                    }
                }
            }
        }
    }

build.gradle.kts

    
    
    tasks.register<Jar>("barJar") {
        manifest {
            attributes("key1" to "value1")
            from(sharedManifest, "src/config/basemanifest.txt")
            from(listOf("src/config/javabasemanifest.txt", "src/config/libbasemanifest.txt")) {
                eachEntry(Action<ManifestMergeDetails> {
                    if (baseValue != mergeValue) {
                        value = baseValue
                    }
                    if (key == "foo") {
                        exclude()
                    }
                })
            }
        }
    }

Manifests are merged in the order they are declared in the `from` statement.
If the base manifest and the merged manifest both define values for the same
key, the merged manifest wins by default. You can fully customize the merge
behavior by adding `eachEntry` actions in which you have access to a
[ManifestMergeDetails](../javadoc/org/gradle/api/java/archives/ManifestMergeDetails.html)
instance for each entry of the resulting manifest. Note that the merge is done
lazily, either when generating the JAR or when `Manifest.writeTo()` or
`Manifest.getEffectiveManifest()` are called.

Speaking of `writeTo()`, you can use that to easily write a manifest to disk
at any time, like so:

Example 12. Saving a MANIFEST.MF to disk

build.gradle

    
    
    jar.manifest.writeTo("$buildDir/mymanifest.mf")

build.gradle.kts

    
    
    tasks.named<Jar>("jar") { manifest.writeTo("$buildDir/mymanifest.mf") }

## Generating API documentation

The Java Library Plugin provides a `javadoc` task of type
[Javadoc](../dsl/org.gradle.api.tasks.javadoc.Javadoc.html), that will
generate standard Javadocs for all your production code, i.e. whatever source
is in the `main` source set. The task supports the core Javadoc and standard
doclet options described in the [Javadoc reference
documentation](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html#options).
See
[CoreJavadocOptions](../javadoc/org/gradle/external/javadoc/CoreJavadocOptions.html)
and
[StandardJavadocDocletOptions](../javadoc/org/gradle/external/javadoc/StandardJavadocDocletOptions.html)
for a complete list of those options.

As an example of what you can do, imagine you want to use Asciidoc syntax in
your Javadoc comments. To do this, you need to add Asciidoclet to Javadoc's
doclet path. Here's an example that does just that:

Example 13. Using a custom doclet with Javadoc

build.gradle

    
    
    configurations {
        asciidoclet
    }
    
    dependencies {
        asciidoclet 'org.asciidoctor:asciidoclet:1.+'
    }
    
    task configureJavadoc {
        doLast {
            javadoc {
                options.doclet = 'org.asciidoctor.Asciidoclet'
                options.docletpath = configurations.asciidoclet.files.toList()
            }
        }
    }
    
    javadoc {
        dependsOn configureJavadoc
    }

build.gradle.kts

    
    
    val asciidoclet by configurations.creating
    
    dependencies {
        asciidoclet("org.asciidoctor:asciidoclet:1.+")
    }
    
    tasks.register("configureJavadoc") {
        doLast {
            tasks.javadoc {
                options.doclet = "org.asciidoctor.Asciidoclet"
                options.docletpath = asciidoclet.files.toList()
            }
        }
    }
    
    tasks.javadoc {
        dependsOn("configureJavadoc")
    }

You don't have to create a configuration for this, but it's an elegant way to
handle dependencies that are required for a unique purpose.

You might also want to create your own Javadoc tasks, for example to generate
API docs for the tests:

Example 14. Defining a custom Javadoc task

build.gradle

    
    
    task testJavadoc(type: Javadoc) {
        source = sourceSets.test.allJava
    }

build.gradle.kts

    
    
    tasks.register<Javadoc>("testJavadoc") {
        source = sourceSets.test.get().allJava
    }

These are just two non-trivial but common customizations that you might come
across.

## Cleaning the build

The Java Library Plugin adds a `clean` task to your project by virtue of
applying the [Base Plugin](base_plugin.html#base_plugin). This task simply
deletes everything in the `$buildDir` directory, hence why you should always
put files generated by the build in there. The task is an instance of
[Delete](../dsl/org.gradle.api.tasks.Delete.html) and you can change what
directory it deletes by setting its `dir` property.

## Building JVM components

All of the specific JVM plugins are built on top of the [Java
Plugin](java_plugin.html). The examples above only illustrated concepts
provided by this base plugin and shared with all JVM plugins.

Read on to understand which plugins fits which project type, as it is
recommended to pick a specific plugin instead of applying the Java Plugin
directly.

## Building Java libraries

The unique aspect of library projects is that they are used (or "consumed") by
other Java projects. That means the dependency metadata published with the JAR
file — usually in the form of a Maven POM — is crucial. In particular,
consumers of your library should be able to distinguish between two different
types of dependencies: those that are only required to compile your library
and those that are also required to compile the consumer.

Gradle manages this distinction via the [Java Library
Plugin](java_library_plugin.html#java_library_plugin), which introduces an
_api_ configuration in addition to the _implementation_ one covered in this
chapter. If the types from a dependency appear in public fields or methods of
your library's public classes, then that dependency is exposed via your
library's public API and should therefore be added to the _api_ configuration.
Otherwise, the dependency is an internal implementation detail and should be
added to _implementation_.

If you're unsure of the difference between an API and implementation
dependency, the [Java Library Plugin
chapter](java_library_plugin.html#sec:java_library_recognizing_dependencies)
has a detailed explanation. In addition, you can explore a basic, practical
[sample of building a Java
library](../samples/sample_building_java_libraries.html).

## Building Java applications

Java applications packaged as a JAR aren't set up for easy launching from the
command line or a desktop environment. The [Application
Plugin](application_plugin.html#application_plugin) solves the command line
aspect by creating a distribution that includes the production JAR, its
dependencies and launch scripts Unix-like and Windows systems.

See the plugin's chapter for more details, but here's a quick summary of what
you get:

  * `assemble` creates ZIP and TAR distributions of the application containing everything needed to run it

  * A `run` task that starts the application from the build (for easy testing)

  * Shell and Windows Batch scripts to start the application

You can see a basic example of building a Java application in the
corresponding [sample](../samples/building-java-applications.html).

## Building Java web applications

Java web applications can be packaged and deployed in a number of ways
depending on the technology you use. For example, you might use [Spring
Boot](https://projects.spring.io/spring-boot/) with a fat JAR or a
[Reactive](https://www.reactivemanifesto.org/)-based system running on
[Netty](https://netty.io/). Whatever technology you use, Gradle and its large
community of plugins will satisfy your needs. Core Gradle, though, only
directly supports traditional Servlet-based web applications deployed as WAR
files.

That support comes via the [War Plugin](war_plugin.html#war_plugin), which
automatically applies the Java Plugin and adds an extra packaging step that
does the following:

  * Copies static resources from _src/main/webapp_ into the root of the WAR

  * Copies the compiled production classes into a _WEB-INF/classes_ subdirectory of the WAR

  * Copies the library dependencies into a _WEB-INF/lib_ subdirectory of the WAR

This is done by the `war` task, which effectively replaces the `jar` task —
although that task remains — and is attached to the `assemble` lifecycle task.
See the plugin's chapter for more details and configuration options.

There is no core support for running your web application directly from the
build, but we do recommend that you try the
[Gretty](https://plugins.gradle.org/plugin/org.gretty) community plugin, which
provides an embedded Servlet container.

## Building Java EE applications

Java enterprise systems have changed a lot over the years, but if you're still
deploying to JEE application servers, you can make use of the [Ear
Plugin](ear_plugin.html#ear_plugin). This adds conventions and a task for
building EAR files. The plugin's chapter has more details.

## Building Java Platforms

A Java platform represents a set of dependency declarations and constraints
that form a cohesive unit to be applied on consuming projects. The platform
has no source and no artifact of its own. It maps in the Maven world to a
[BOM](https://maven.apache.org/guides/introduction/introduction-to-dependency-
mechanism.html#Dependency_Management).

The support comes via the [Java Platform plugin](java_platform_plugin.html),
which sets up the different configurations and publication components.

__ |

This plugin is the exception as it does not apply the Java Plugin.  
  
---|---  
  
## Enabling Java preview features

__ |

Using a Java preview feature is very likely to make your code incompatible
with that compiled without a feature preview. As a consequence, we strongly
recommend you not to publish libraries compiled with preview features and
restrict the use of feature previews to toy projects.  
  
---|---  
  
To enable Java [preview features](https://openjdk.java.net/jeps/12) for
compilation, test execution and runtime, you can use the following DSL
snippet:

Example 15. Enabling Java feature preview

build.gradle

    
    
    tasks.withType(JavaCompile) {
        options.compilerArgs += "--enable-preview"
    }
    tasks.withType(Test) {
        jvmArgs += "--enable-preview"
    }
    tasks.withType(JavaExec) {
        jvmArgs += "--enable-preview"
    }

build.gradle.kts

    
    
    tasks.withType<JavaCompile> {
        options.compilerArgs.add("--enable-preview")
    }
    tasks.withType<Test> {
        jvmArgs("--enable-preview")
    }
    tasks.withType<JavaExec> {
        jvmArgs("--enable-preview")
    }

## Building other JVM language projects

If you want to leverage the multi language aspect of the JVM, most of what was
described here will still apply.

Gradle itself provides [Groovy](groovy_plugin.html) and
[Scala](scala_plugin.html) plugins. The plugins automatically apply support
for compiling Java code and can be further enhanced by combining them with the
`java-library` plugin.

### Compilation dependency between languages

These plugins create a dependency between Groovy/Scala compilation and Java
compilation (of source code in the `java` folder of a source set). You can
change this default behavior by adjusting the classpath of the involved
compile tasks as shown in the following example:

Example 16. Changing the classpath of compile tasks

build.gradle

    
    
    tasks.named('compileGroovy') {
        // Groovy only needs the declared dependencies
        // (and not longer the output of compileJava)
        classpath = sourceSets.main.compileClasspath
    }
    tasks.named('compileJava') {
        // Java also depends on the result of Groovy compilation
        // (which automatically makes it depend of compileGroovy)
        classpath += files(sourceSets.main.groovy.classesDirectory)
    }

build.gradle.kts

    
    
    tasks.named<AbstractCompile>("compileGroovy") {
        // Groovy only needs the declared dependencies
        // (and not longer the output of compileJava)
        classpath = sourceSets.main.get().compileClasspath
    }
    tasks.named<AbstractCompile>("compileJava") {
        // Java also depends on the result of Groovy compilation
        // (which automatically makes it depend of compileGroovy)
        classpath += files(sourceSets.main.get().withConvention(GroovySourceSet::class) { groovy }.classesDirectory)
    }

  1. By setting the `compileGroovy` classpath to be only `sourceSets.main.compileClasspath`, we effectively remove the previous dependency on `compileJava` that was declared by having the classpath also take into consideration `sourceSets.main.java.classesDirectory`

  2. By adding `sourceSets.main.groovy.classesDirectory` to the `compileJava` `classpath`, we effectively declare a dependency on the `compileGroovy` task

All of this is possible through the use of [directory
properties](lazy_configuration.html).

### Extra language support

Beyond core Gradle, there are other [great
plugins](https://plugins.gradle.org/search?term=jvm) for more JVM languages!

* * *

1. In fact, any artifact added to the `archives` configuration will be built by `assemble`

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

