

[ Gradle ](https://docs.gradle.org/ "Gradle Docs")

用户手册

  * 社区 Open Community Menu

[ 社区之家 ](https://gradle.org/)

[ 社区论坛 ](https://discuss.gradle.org/)

[ 社区插件 ](https://plugins.gradle.org/)

  * [训练](https://gradle.com/training/)
  * 新闻 Open Community Menu

[ 通讯 ](https://newsletter.gradle.com/)

[ 博客 ](https://blog.gradle.org/)

[ 推特 ](https://twitter.com/gradle)

  * [企业](https://gradle.com/)
  * [github](https://github.com/gradle/gradle "GitHub上的Gradle")

  * [文件首页](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.html)
  * [样品](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html)
  * [发行说明](file:///Users/dxs/temp/gradle-6.7.1/docs/release-notes.html)
  * [Gradle API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#gradle-api)
    * [Java文档](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/index.html?overview-summary.html)
    * [Groovy DSL参考](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/index.html)
    * [Groovy DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/kotlin_dsl.html)

### 用户手册

[ PDF格式 ](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.pdf)

  * [什么是Gradle？](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/what_is_gradle.html)
  * [入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/getting_started.html)
  * [安装Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/installation.html)
  * [升级Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#upgrading-gradle)
    * [版本6.X到最新](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_6.html)
    * [版本5.X到6.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_5.html)
    * [版本4.X到5.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_4.html)
    * [Gradle的功能生命周期](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_lifecycle.html)
  * [迁移至Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#migrating-to-gradle)
    * [从Maven](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_maven.html)
    * [来自蚂蚁](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_ant.html)
  * [相容性说明](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/compatibility.html)
  * [对构建进行故障排除](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/troubleshooting.html)

### 运行Gradle构建

  * [自定义执行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#customizing-execution)
    * [配置构建环境](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_environment.html)
    * [配置Gradle守护程序](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_daemon.html)
    * [使用初始化脚本](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/init_scripts.html)
  * [执行多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/intro_multi_project_builds.html)
  * [检查Gradle构建](https://scans.gradle.com/)
  * [优化构建时间](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#optimizing-build-performance)
    * [构建绩效指南](https://guides.gradle.org/performance/)
    * [启用和配置构建缓存](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_cache.html)
    * [使用配置缓存](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/configuration_cache.html)

### 编写Gradle构建

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#learning-the-basics)
    * [介绍构建脚本的基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/tutorial_using_tasks.html)
    * [处理任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html)
    * [了解有关构建脚本的更多信息](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/writing_build_scripts.html)
    * [处理文件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/working_with_files.html)
    * [使用Gradle插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html)
    * [Understanding the Build Lifecycle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_lifecycle.html)
    * [Working with Logging](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/logging.html)
    * [Avoiding Traps](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/potential_traps.html)
  * [创作多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#authoring-multi-project-builds)
    * [Creating a Basic Multi-Project Build](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_configuration_and_execution.html)
  * [创作可持续建筑](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#authoring-sustainable-builds)
    * [Organizing Build Logic](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html)
    * [Following Best Practices](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/authoring_maintainable_build_scripts.html)
  * [先进技术](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#advanced-techniques)
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/test_kit.html)
    * [Using Ant from Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/ant.html)

### 编写JVM构建

  * [构建Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html)
  * [测试Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html)
  * [Java项目的工具链](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html)
  * [管理依赖关系](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_for_java_projects.html)
  * [JVM插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#jvm-plugins)
    * [Java Library Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)
    * [Java Application Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/application_plugin.html)
    * [Java Platform Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_platform_plugin.html)
    * [Groovy Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html)
    * [Scala Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/scala_plugin.html)

### 编写C ++ / Swift构建

  * [构建C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_cpp_projects.html)
  * [测试C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cpp_testing.html)
  * [建立Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_swift_projects.html)
  * [测试Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/swift_testing.html)

### 使用依赖项

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#learning-the-basics-dependency-management)
    * [What is Dependency Management?](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/core_dependency_management.html)
    * [Declaring Repositories](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html)
    * [Declaring Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_resolution.html)
    * [Verifying dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_verification.html)
  * [声明版本](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#declaring-dependency-versions)
    * [Declaring Versions and Ranges](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/single_versions.html)
    * [Declaring Rich Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/rich_versions.html)
    * [Handling Changing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dynamic_versions.html)
    * [Locking Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_locking.html)
  * [控制翻译](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#controlling-transitive-dependencies)
    * [Upgrading Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_constraints.html)
    * [Downgrading and Excluding](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/platforms.html)
    * [Aligning Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_metadata_rules.html)
    * [Customizing Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_rules.html)
    * [Preventing accidental upgrades](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_strategy_tuning.html)
  * [图书馆的生产和消费形式](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#modeling-features)
    * [Declaring Capabilities of a Library](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_variants.html)
    * [Understanding Variant Selection](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html)
    * [Declaring Variant Attributes](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cross_project_publications.html)
    * [Transforming Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html)
  * [在多仓库环境中工作](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#multi-repo)
    * [Composing Builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/composite_builds.html)
  * [出版图书馆](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#publishing)
    * [Setting up Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_signing.html)
    * [Customizing Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_customization.html)
    * [Maven Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_maven.html)
    * [Ivy Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html)
  * [术语](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_terminology.html)

### 扩展摇篮

  * [插件开发教程](https://gradle.org/guides/?q=Plugin%20Development)
  * [编写Gradle任务类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html)
  * [编写Gradle插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html)
  * [编写自定义Gradle类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html)
  * [延迟配置任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html)
  * [使用避免任务配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/task_configuration_avoidance.html)

### 参考

  * [核心插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugin_reference.html)
  * [命令行界面](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/command_line_interface.html)
  * [Gradle和第三方工具](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/third_party_integration.html)
  * [摇篮包装](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_wrapper.html)
  * [Gradle管理的目录](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/directory_layout.html)

# 开发自定义Gradle任务类型

version 6.7.1

内容

  * [打包任务类](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:packaging_a_task_class)
  * [编写一个简单的任务类](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:writing_a_simple_task_class)
  * [一个独立的项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:custom_tasks_standalone_project)
  * [增量任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#incremental_tasks)
  * [声明和使用命令行选项](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:declaring_and_using_command_line_options)
  * [工作者API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#worker_api)
  * [取消和超时](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#cancellation_and_timeouts)
  * [更多细节](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#more_details)

Gradle支持两种类型的任务。一种这样的类型是简单任务，您可以在其中用动作关闭定义任务。我们已经在[Build Script
Basics中](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/tutorial_using_tasks.html#tutorial_using_tasks)看到了这些。对于这种类型的任务，动作关闭确定任务的行为。这种类型的任务非常适合在构建脚本中实施一次性任务。

任务的另一种类型是增强型任务，其中行为内置于任务中，并且该任务提供了一些可用于配置行为的属性。我们已经在[创作任务中](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html#more_about_tasks)看到了这些。大多数Gradle插件使用增强的任务。使用增强型任务，您无需像处理简单任务那样实现任务行为。您只需声明任务并使用其属性配置任务。通过这种方式，增强的任务使您可以在许多不同的地方（可能跨不同的构建）重用某种行为。

增强型任务的行为和属性由任务的类定义。声明增强的任务时，可以指定任务的类型或类。

在Gradle中实现自己的自定义任务类很容易。您可以使用任何您喜欢的语言来实现自定义任务类，只要最终将其编译为JVM字节码即可。在我们的示例中，我们将使用Groovy作为实现语言。Groovy，Java或Kotlin都是用于实现任务类的语言，都是不错的选择，因为Gradle
API被设计为与这些语言很好地兼容。通常，使用Java或Kotlin（静态类型）实现的任务将比使用Groovy实现的任务执行得更好。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:packaging_a_task_class)[打包任务类](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:packaging_a_task_class)

您可以在几个地方放置任务类的源代码。

构建脚本

    

You can include the task class directly in the build script. This has the
benefit that the task class is automatically compiled and included in the
classpath of the build script without you having to do anything. However, the
task class is not visible outside the build script, and so you cannot reuse
the task class outside the build script it is defined in.

`buildSrc` project

    

You can put the source for the task class in the `_rootProjectDir_
/buildSrc/src/main/groovy` directory (or `_rootProjectDir_
/buildSrc/src/main/java` or `_rootProjectDir_ /buildSrc/src/main/kotlin`
depending on which language you prefer). Gradle will take care of compiling
and testing the task class and making it available on the classpath of the
build script. The task class is visible to every build script used by the
build. However, it is not visible outside the build, and so you cannot reuse
the task class outside the build it is defined in. Using the `buildSrc`
project approach separates the task declaration — that is, what the task
should do — from the task implementation — that is, how the task does it.

See [Organizing Gradle
Projects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html#organizing_gradle_projects)
for more details about the `buildSrc` project.

Standalone project

    

您可以为任务类创建一个单独的项目。这个项目产生并发布了一个JAR，您可以在多个版本中使用它并与他人共享。通常，此JAR可能包含一些自定义插件，或将几个相关的任务类捆绑到一个库中。或两者的某种组合。

在我们的示例中，我们将从构建脚本中的任务类开始，以使事情变得简单。然后，我们将考虑创建一个独立的项目。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:writing_a_simple_task_class)[编写一个简单的任务类](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:writing_a_simple_task_class)

要实现自定义任务类，可以扩展[DefaultTask](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.DefaultTask.html)。

例子1.定义一个自定义任务

`Groovy``Kotlin`

build.gradle

    
    
    class GreetingTask extends DefaultTask {
    }

build.gradle.kts

    
    
    open class GreetingTask : DefaultTask() {
    }

该任务没有做任何有用的事情，因此让我们添加一些行为。为此，我们向任务添加一个方法，并使用[TaskAction](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/TaskAction.html)批注对其进行标记。任务执行时，Gradle将调用该方法。您不必使用方法来定义任务的行为。例如，您可以在任务构造函数中调用`doFirst()`或`doLast()`使用闭包来添加行为。

例子2.你好世界任务

`Groovy``Kotlin`

build.gradle

    
    
    class GreetingTask extends DefaultTask {
        @TaskAction
        def greet() {
            println 'hello from GreetingTask'
        }
    }
    
    // Create a task using the task type
    task hello(type: GreetingTask)

build.gradle.kts

    
    
    open class GreetingTask : DefaultTask() {
        @TaskAction
        fun greet() {
            println("hello from GreetingTask")
        }
    }
    
    // Create a task using the task type
    tasks.register<GreetingTask>("hello")

输出 **`gradle -q hello`**

    
    
    > gradle -q你好
    你好，来自GreetingTask

让我们为任务添加一个属性，以便我们可以对其进行自定义。任务只是POGO，声明任务时，可以在任务对象上设置属性或调用方法。在这里，我们添加一个`greeting`属性，并在声明`greeting`任务时设置值。

例子3.一个可定制的hello world任务

`Groovy``Kotlin`

build.gradle

    
    
    class GreetingTask extends DefaultTask {
        @Input
        String greeting = 'hello from GreetingTask'
    
        @TaskAction
        def greet() {
            println greeting
        }
    }
    
    // Use the default greeting
    task hello(type: GreetingTask)
    
    // Customize the greeting
    task greeting(type: GreetingTask) {
        greeting = 'greetings from GreetingTask'
    }

build.gradle.kts

    
    
    open class GreetingTask : DefaultTask() {
        @get:Input
        var greeting = "hello from GreetingTask"
    
        @TaskAction
        fun greet() {
            println(greeting)
        }
    }
    
    // Use the default greeting
    tasks.register<GreetingTask>("hello")
    
    // Customize the greeting
    tasks.register<GreetingTask>("greeting") {
        greeting = "greetings from GreetingTask"
    }

输出 **`gradle -q hello greeting`**

    
    
    > gradle -q你好问候
    你好，来自GreetingTask
    来自GreetingTask的问候

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:custom_tasks_standalone_project)[一个独立的项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:custom_tasks_standalone_project)

现在，我们将把任务移到一个独立的项目中，以便我们可以发布它并与他人共享它。这个项目只是一个Groovy项目，它产生一个包含任务类的JAR。这是该项目的简单构建脚本。它应用了Groovy插件，并将Gradle
API添加为编译时依赖项。

例子4.一个自定义任务的构建

`Groovy``Kotlin`

build.gradle

    
    
    plugins {
        id 'groovy'
    }
    
    dependencies {
        implementation gradleApi()
    }

build.gradle.kts

    
    
    plugins {
        groovy
    }
    
    dependencies {
        implementation(gradleApi())
    }

我们只是遵循任务类源应该放在哪里的约定。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_a_custom_task)[示例：自定义任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_a_custom_task)

src / main / groovy / org / gradle / GreetingTask.groovy

    
    
    package org.gradle
    
    import org.gradle.api.DefaultTask
    import org.gradle.api.tasks.TaskAction
    import org.gradle.api.tasks.Input
    
    class GreetingTask extends DefaultTask {
    
        @Input
        String greeting = 'hello from GreetingTask'
    
        @TaskAction
        def greet() {
            println greeting
        }
    }

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:using_your_task_class_in_another_project)[在另一个项目中使用您的任务类](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:using_your_task_class_in_another_project)

要在构建脚本中使用任务类，您需要将该类添加到构建脚本的类路径中。为此，请使用一个`buildscript {
}`块，如[构建脚本的外部依赖项中所述](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/tutorial_using_tasks.html#sec:build_script_external_dependencies)。以下示例显示了包含任务类的JAR已发布到本地存储库时如何执行此操作：

例子5.在另一个项目中使用自定义任务

`Groovy``Kotlin`

build.gradle

    
    
    buildscript {
        repositories {
            maven {
                url = uri(repoLocation)
            }
        }
        dependencies {
            classpath 'org.gradle:task:1.0-SNAPSHOT'
        }
    }
    
    task greeting(type: org.gradle.GreetingTask) {
        greeting = 'howdy!'
    }

build.gradle.kts

    
    
    buildscript {
        repositories {
            maven {
                url = uri(repoLocation)
            }
        }
        dependencies {
            classpath("org.gradle:task:1.0-SNAPSHOT")
        }
    }
    
    tasks.register<org.gradle.GreetingTask>("greeting") {
        greeting = "howdy!"
    }

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:writing_tests_for_your_task_class)[为任务类编写测试](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:writing_tests_for_your_task_class)

您可以使用[ProjectBuilder](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/testfixtures/ProjectBuilder.html)类创建在测试任务类时要使用的[Project](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.Project.html)实例。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_testing_a_custom_task)[示例：测试自定义任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_testing_a_custom_task)

src / test / groovy / org / gradle / GreetingTaskTest.groovy

    
    
    class GreetingTaskTest {
        @Test
        void canAddTaskToProject() {
            Project project = ProjectBuilder.builder().build()
            def task = project.task('greeting', type: GreetingTask)
            assertTrue(task instanceof GreetingTask)
        }
    }

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#incremental_tasks)[增量任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#incremental_tasks)

使用Gradle，实现一个在所有输入和输出都是最新的情况下将被跳过的任务非常简单（请参阅“[增量构建”](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html#sec:up_to_date_checks)）。但是，自上次执行以来，有时只有少数输入文件已更改，因此您希望避免重新处理所有未更改的输入。这对于将输入文件按1：1转换为输出文件的转换器任务特别有用。

如果您想优化构建，以便仅处理过时的输入文件，则可以使用 _增量任务来完成_ 。

__ |

有[IncrementalTask​​Inputs](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/incremental/IncrementalTaskInputs.html)
API，在5.4之前的Gradle版本中可用。使用[IncrementalTask​​Inputs时](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/incremental/IncrementalTaskInputs.html)，只能查询任务输入的所有文件更改。无法查询各个输入文件属性的更改。此外，旧的API不能区分增量任务输入和非增量任务输入，因此任务本身需要确定更改源自何处。因此，不建议使用此API，并最终将其删除。本文记录了新的[InputChanges](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html)
API，它取代了旧的API并解决了其缺点。如果需要使用旧的API，请查看[Gradle
5.3.1用户手册](https://docs.gradle.org/5.3.1/userguide/custom_tasks.html#incremental_tasks)中的文档。  
  
---|---  
  
###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:implementing_an_incremental_task)[实施增量任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:implementing_an_incremental_task)

为了使任务增量处理输入，该任务必须包含一个 _增量任务action_
。这是一个具有单个[InputChanges](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html)参数的任务操作方法。该参数告诉Gradle该操作仅想处理更改的输入。另外，任务需要使用[@Incremental](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/work/Incremental.html)或[@SkipWhenEmpty](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/SkipWhenEmpty.html)声明至少一个增量文件输入属性。

__ |

要查询输入文件属性的增量更改，该属性始终需要返回相同的实例。完成此操作的最简单方法是对此类属性使用以下类型之一：[RegularFileProperty](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/file/RegularFileProperty.html)，[DirectoryProperty](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/file/DirectoryProperty.html)或[ConfigurableFileCollection](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/file/ConfigurableFileCollection.html)。

您可以详细了解`RegularFileProperty`，并`DirectoryProperty`在[懒惰配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html#lazy_configuration)一章，特别是在部分[使用只读和可配置性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html#lazy_properties)和[懒惰的文件属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html#working_with_files_in_lazy_properties)。  
  
---|---  
  
增量任务操作可以使用[InputChanges.getFileChanges（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges\(org.gradle.api.file.FileCollection\))来找出哪些文件已更改为给定的基于文件的输入特性，是类型的它`RegularFileProperty`，`DirectoryProperty`或`ConfigurableFileCollection`。该方法返回[FileChanges](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/work/FileChange.html)`Iterable`类型的，可以依次查询以下内容：[](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/work/FileChange.html)

  * 在[受影响的文件](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/work/FileChange.html#getFile--)

  * 的[变化类型](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/work/FileChange.html#getChangeType--)（`ADDED`，`REMOVED`或`MODIFIED`）

  * 更改文件的[规范化路径](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/work/FileChange.html#getNormalizedPath--)

  * 更改文件的[文件类型](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/work/FileChange.html#getFileType--)

以下示例演示了具有目录输入的增量任务。假定目录包含文本文件的集合，然后将它们复制到输出目录，以反转每个文件中的文本。需要注意的关键事项是`inputDir`属性的类型，其批注以及action（`execute()`）如何`getFileChanges()`处理自上次构建以来实际上已更改的文件的子集。您还可以查看如果删除了相应的输入文件，则该操作如何删除目标文件：

例子6.定义一个增量任务动作

`Groovy``Kotlin`

build.gradle

    
    
    abstract class IncrementalReverseTask extends DefaultTask {
        @Incremental
        @PathSensitive(PathSensitivity.NAME_ONLY)
        @InputDirectory
        abstract DirectoryProperty getInputDir()
    
        @OutputDirectory
        abstract DirectoryProperty getOutputDir()
    
        @Input
        abstract Property<String> getInputProperty()
    
        @TaskAction
        void execute(InputChanges inputChanges) {
            println(inputChanges.incremental
                ? 'Executing incrementally'
                : 'Executing non-incrementally'
            )
    
            inputChanges.getFileChanges(inputDir).each { change ->
                if (change.fileType == FileType.DIRECTORY) return
    
                println "${change.changeType}: ${change.normalizedPath}"
                def targetFile = outputDir.file(change.normalizedPath).get().asFile
                if (change.changeType == ChangeType.REMOVED) {
                    targetFile.delete()
                } else {
                    targetFile.text = change.file.text.reverse()
                }
            }
        }
    }

build.gradle.kts

    
    
    abstract class IncrementalReverseTask : DefaultTask() {
        @get:Incremental
        @get:PathSensitive(PathSensitivity.NAME_ONLY)
        @get:InputDirectory
        abstract val inputDir: DirectoryProperty
    
        @get:OutputDirectory
        abstract val outputDir: DirectoryProperty
    
        @get:Input
        abstract val inputProperty: Property<String>
    
        @TaskAction
        fun execute(inputChanges: InputChanges) {
            println(
                if (inputChanges.isIncremental) "Executing incrementally"
                else "Executing non-incrementally"
            )
    
            inputChanges.getFileChanges(inputDir).forEach { change ->
                if (change.fileType == FileType.DIRECTORY) return@forEach
    
                println("${change.changeType}: ${change.normalizedPath}")
                val targetFile = outputDir.file(change.normalizedPath).get().asFile
                if (change.changeType == ChangeType.REMOVED) {
                    targetFile.delete()
                } else {
                    targetFile.writeText(change.file.readText().reversed())
                }
            }
        }
    }

If for some reason the task is executed non-incrementally, for example by
running with `--rerun-tasks`, all files are reported as `ADDED`, irrespective
of the previous state. In this case, Gradle automatically removes the previous
outputs, so the incremental task only needs to process the given files.

For a simple transformer task like the above example, the task action simply
needs to generate output files for any out-of-date inputs and delete output
files for any removed inputs.

__ |

A task may only contain a single incremental task action.  
  
---|---  
  
###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:which_inputs_are_considered_out_of_date)[Which
inputs are considered out of
date?](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:which_inputs_are_considered_out_of_date)

当以前执行任务时，自执行以来唯一的更改是增量输入文件属性，则Gradle能够确定需要处理哪些输入文件（增量执行）。在这种情况下，[InputChanges.getFileChanges（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges\(org.gradle.api.file.FileCollection\))方法返回
_添加_ ， _修改_ 或 _删除_ 的给定属性的所有输入文件的详细信息。

但是，在许多情况下，Gradle无法确定需要处理哪些输入文件（非增量执行）。示例包括：

  * 没有上一次执行的历史记录。

  * 您正在使用其他版本的Gradle进行构建。当前，Gradle不使用其他版本的任务历史记录。

  * 一个[`upToDateWhen`](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-groovy.lang.Closure-)标准添加到任务的回报`false`。

  * 自上次执行以来，输入属性已更改。

  * 自上次执行以来，非增量输入文件属性已更改。

  * 自上次执行以来，一个或多个输出文件已更改。

在所有这些情况下，Gradle将报告所有输入文件，`ADDED`并且该`getFileChanges()`方法将返回组成给定输入属性的所有文件的详细信息。

您可以使用[InputChanges.isIncremental（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges.html##org.gradle.work.InputChanges:incremental)方法检查任务执行是否为增量执行。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:an_incremental_task_in_action)[增量任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:an_incremental_task_in_action)

给出的例子增量任务执行[上面](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#taskDefinition)，通过基于它的一些场景，让我们走。

首先，考虑一个实例，`IncrementalReverseTask`它是第一次针对一组输入执行的。在这种情况下，所有输入将被视为已添加，如下所示：

例子7.第一次运行增量任务

`Groovy``Kotlin`

build.gradle

    
    
    task incrementalReverse(type: IncrementalReverseTask) {
        inputDir = file('inputs')
        outputDir = file("$buildDir/outputs")
        inputProperty = project.properties['taskInputProperty'] ?: 'original'
    }

build.gradle.kts

    
    
    tasks.register<IncrementalReverseTask>("incrementalReverse") {
        inputDir.set(file("inputs"))
        outputDir.set(file("$buildDir/outputs"))
        inputProperty.set(project.properties["taskInputProperty"] as String? ?: "original")
    }

构建布局

    
    
    。
    ├──build.gradle
    └──输入
        ├──1.txt
        ├──2.txt
        └──3.txt

输出 `gradle -q incrementalReverse`

    
    
    > gradle -q增量反向
    非增量执行
    添加：1.txt
    添加：2.txt
    添加：3.txt

自然地，如果再次执行任务且没有任何更改，则整个任务都是最新的，并且不执行任务动作：

例子8.在输入不变的情况下运行增量任务

输出 `gradle incrementalReverse`

    
    
    > gradle增量反向
    >任务：递增逆向最新
    
    在0秒内成功建立
    1个可执行任务：1个最新任务

当以某种方式修改输入文件或添加新的输入文件时，然后重新执行任务将导致这些文件由[InputChanges.getFileChanges（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges\(org.gradle.api.file.FileCollection\))返回。下面的示例在运行增量任务之前修改一个文件的内容并添加另一个文件的内容：

示例9.使用更新的输入文件运行增量任务

`Groovy``Kotlin`

build.gradle

    
    
    task updateInputs() {
        doLast {
            file('inputs/1.txt').text = 'Changed content for existing file 1.'
            file('inputs/4.txt').text = 'Content for new file 4.'
        }
    }

build.gradle.kts

    
    
    tasks.register("updateInputs") {
        doLast {
            file("inputs/1.txt").writeText("Changed content for existing file 1.")
            file("inputs/4.txt").writeText("Content for new file 4.")
        }
    }

输出 `gradle -q updateInputs incrementalReverse`

    
    
    > gradle -q updateInputs增量反向
    逐步执行
    修改后：1.txt
    添加：4.txt

__ |
各种变异任务（`updateInputs`，`removeInput`等）仅用于演示增量任务的行为。不应将它们视为您应该在自己的构建脚本中拥有的任务或任务实现类型。  
---|---  
  
当现有的输入文件被删除，然后重新执行该文件中的任务结果被返回[InputChanges.getFileChanges（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges\(org.gradle.api.file.FileCollection\))为`REMOVED`。下面的示例在执行增量任务之前删除现有文件之一：

例子10.在删除输入文件的情况下运行增量任务

`Groovy``Kotlin`

build.gradle

    
    
    task removeInput() {
        doLast {
            file('inputs/3.txt').delete()
        }
    }

build.gradle.kts

    
    
    tasks.register("removeInput") {
        doLast {
            file("inputs/3.txt").delete()
        }
    }

输出 `gradle -q removeInput incrementalReverse`

    
    
    > gradle -q removeInput增量反向
    逐步执行
    删除：3.txt

当 _输出_
文件被删除（或修改）时，Gradle无法确定哪些输入文件已过期。在这种情况下，[InputChanges.getFileChanges（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges\(org.gradle.api.file.FileCollection\))返回给定属性的
_所有_
输入文件的详细信息。以下示例仅从构建目录中删除输出文件之一，但请注意如何将所有输入文件视为：[](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges\(org.gradle.api.file.FileCollection\))`ADDED`

示例11.在删除输出文件的情况下运行增量任务

`Groovy``Kotlin`

build.gradle

    
    
    task removeOutput() {
        doLast {
            file("$buildDir/outputs/1.txt").delete()
        }
    }

build.gradle.kts

    
    
    tasks.register("removeOutput") {
        doLast {
            file("$buildDir/outputs/1.txt").delete()
        }
    }

输出 `gradle -q removeOutput incrementalReverse`

    
    
    > gradle -q removeOutput增量反向
    非增量执行
    添加：1.txt
    添加：2.txt
    添加：3.txt

我们要讨论的最后一个场景涉及修改基于非文件的输入属性时发生的情况。在这种情况下，Gradle无法确定属性如何影响任务输出，因此任务将以非增量方式执行。这意味着给定属性的
_所有_
输入文件都由[InputChanges.getFileChanges（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges\(org.gradle.api.file.FileCollection\))返回，并且都被视为`ADDED`。下面的示例`taskInputProperty`在运行`incrementalReverse`任务时将项目属性设置为新值，并且该项目属性用于初始化任务的`inputProperty`属性，如[本节](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#ex:incremental_task_definition)的[第一个示例所示](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#ex:incremental_task_definition)。在这种情况下，您可以期待以下输出：

例子12.在输入属性改变的情况下运行增量任务

输出 `gradle -q -PtaskInputProperty=changed incrementalReverse`

    
    
    > gradle -q -PtaskInputProperty=changed incrementalReverse
    Executing non-incrementally
    ADDED: 1.txt
    ADDED: 2.txt
    ADDED: 3.txt

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:storing_incremental_task_state)[Storing
incremental state for cached
tasks](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:storing_incremental_task_state)

Using Gradle’s `InputChanges` is not the only way to create tasks that only
work on changes since the last execution. Tools like the Kotlin compiler
provide incrementality as a built-in feature. The way this is typically
implemented is that the tool stores some analysis data about the state of the
previous execution in some file. If such state files are
[relocatable](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_cache.html#sec:task_output_caching_inputs),
then they can be declared as outputs of the task. This way when the task’s
results are loaded from cache, the next execution can already use the analysis
data loaded from cache, too.

However, if the state files are non-relocatable, then they can’t be shared via
the build cache. Indeed, when the task is loaded from cache, any such state
files must be cleaned up to prevent stale state from confusing the tool during
the next execution. Gradle can ensure such stale files are removed if they are
declared via
[task.localState.register()](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/TaskLocalState.html#register-
java.lang.Object...-) or if a property is marked with the
[@LocalState](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/LocalState.html)
annotation.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:declaring_and_using_command_line_options)[Declaring
and Using Command Line
Options](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:declaring_and_using_command_line_options)

Sometimes a user wants to declare the value of an exposed task property on the
command line instead of the build script. Being able to pass in property
values on the command line is particularly helpful if they change more
frequently. The task API supports a mechanism for marking a property to
automatically generate a corresponding command line parameter with a specific
name at runtime.

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:declaring_task_option)[Declaring
a command-line
option](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:declaring_task_option)

Exposing a new command line option for a task property is straightforward. You
just have to annotate the corresponding setter method of a property with
[Option](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/options/Option.html).
An option requires a mandatory identifier. Additionally, you can provide an
optional description. A task can expose as many command line options as
properties available in the class.

Let’s have a look at an example to illustrate the functionality. The custom
task `UrlVerify` verifies whether a given URL can be resolved by making a HTTP
call and checking the response code. The URL to be verified is configurable
through the property `url`. The setter method for the property is annotated
with
[@Option](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/options/Option.html).

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_declaring_a_command_line_option)[Example:
Declaring a command line
option](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_declaring_a_command_line_option)

UrlVerify.java

    
    
    import org.gradle.api.tasks.options.Option;
    
    public class UrlVerify extends DefaultTask {
        private String url;
    
        @Option(option = "url", description = "Configures the URL to be verified.")
        public void setUrl(String url) {
            this.url = url;
        }
    
        @Input
        public String getUrl() {
            return url;
        }
    
        @TaskAction
        public void verify() {
            getLogger().quiet("Verifying URL '{}'", url);
    
            // verify URL by making a HTTP call
        }
    }

All options declared for a task can be [rendered as console
output](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:listing_task_options)
by running the `help` task and the `--task` option.

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:using_task_option_command_line)[Using
an option on the command
line](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:using_task_option_command_line)

Using an option on the command line has to adhere to the following rules:

  * The option uses a double-dash as prefix e.g. `--url`. A single dash does not qualify as valid syntax for a task option.

  * option参数紧跟在任务声明之后，例如`verifyUrl --url=http://www.google.com/`。

  * 可以在命令行中以任意顺序在任务名称之后声明任务的多个选项。

回到上一个示例，构建脚本创建一个type的任务实例，`UrlVerify`并通过暴露选项从命令行提供一个值。

例子13.使用命令行选项

`Groovy``Kotlin`

build.gradle

    
    
    task verifyUrl(type: UrlVerify)

build.gradle.kts

    
    
    tasks.register<UrlVerify>("verifyUrl")

输出 **`gradle -q verifyUrl --url=http://www.google.com/`**

    
    
    > gradle -q verifyUrl --url = http：//www.google.com/
    验证网址“ http://www.google.com/”

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:supported_task_option_data_types)[选项支持的数据类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:supported_task_option_data_types)

Gradle限制了可用于声明命令行选项的数据类型集。命令行上的用法因类型而异。

`boolean`，`Boolean`，`Property<Boolean>`

    

描述值为`true`或的选项`false`。在命令行中传递选项会将值视为`true`。例如`--enabled`等于`true`。没有该选项将使用属性的默认值。

`String`， `Property<String>`

    

描述具有任意String值的选项。在命令行上传递选项还需要一个值，例如`--container-id=2x94held`或`--container-id
2x94held`。

`enum`， `Property<enum>`

    

将选项描述为枚举类型。在命令行上传递选项还需要一个值，例如`--log-level=DEBUG`或`--log-level debug`。该值不区分大小写。

`List<String>`， `List<enum>`

    

描述可以采用给定类型的多个值的选项。该选项的值必须作为多个声明提供，例如`--image-id=123 --image-
id=456`。当前不支持其他表示法，例如以逗号分隔的列表或由空格字符分隔的多个值。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:documenting_available_task_option_values)[记录选项的可用值](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:documenting_available_task_option_values)

理论上，属性类型的选项`String`或`List<String>`可以接受任意值。可以在注释[OptionValues](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/options/OptionValues.html)的帮助下以编程方式记录此选项的期望值。可以将此注释分配给任何返回`List`支持的数据类型之一的方法。另外，您必须提供选项标识符以指示选项和可用值之间的关系。

__ |

在选项中不支持的命令行上传递值不会使构建失败或引发异常。您必须在任务操作中为此类行为实现自定义逻辑。  
  
---|---  
  
本示例说明了单个任务使用多个选项的情况。任务实现提供了该选项的可用值列表`output-type`。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_declaring_available_values_for_an_option)[示例：声明选项的可用值](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_declaring_available_values_for_an_option)

UrlProcess.java

    
    
    import org.gradle.api.tasks.options.Option;
    import org.gradle.api.tasks.options.OptionValues;
    
    public class UrlProcess extends DefaultTask {
        private String url;
        private OutputType outputType;
    
        @Option(option = "url", description = "Configures the URL to be write to the output.")
        public void setUrl(String url) {
            this.url = url;
        }
    
        @Input
        public String getUrl() {
            return url;
        }
    
        @Option(option = "output-type", description = "Configures the output type.")
        public void setOutputType(OutputType outputType) {
            this.outputType = outputType;
        }
    
        @OptionValues("output-type")
        public List<OutputType> getAvailableOutputTypes() {
            return new ArrayList<OutputType>(Arrays.asList(OutputType.values()));
        }
    
        @Input
        public OutputType getOutputType() {
            return outputType;
        }
    
        @TaskAction
        public void process() {
            getLogger().quiet("Writing out the URL response from '{}' to '{}'", url, outputType);
    
            // retrieve content from URL and write to output
        }
    
        private static enum OutputType {
            CONSOLE, FILE
        }
    }

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:listing_task_options)[列出命令行选项](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:listing_task_options)

使用注释[Option](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/options/Option.html)和[OptionValues的](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/options/OptionValues.html)命令行选项是自记录的。您将在任务的控制台输出中看到[声明的选项](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:declaring_task_option)及其[可用值](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#sec:documenting_available_task_option_values)`help`。输出以字母顺序呈现选项。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_listing_available_values_for_option)[示例：列出选项的可用值](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#example_listing_available_values_for_option)

输出 **`gradle -q help --task processUrl`**

    
    
    > gradle -q帮助--task processUrl
    processUrl的详细任务信息
    
    路径
         ：processUrl
    
    类型
         UrlProcess（UrlProcess）
    
    选件
         --output-type配置输出类型。
                           可用值为：
                                安慰
                                文件
    
         --url配置要写入输出的URL。
    
    描述
         --
    
    组
         --

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#limitations)[局限性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#limitations)

当前支持声明命令行选项有一些限制。

  * 只能通过注释为自定义任务声明命令行选项。没有用于定义选项的程序化等效项。

  * 选项不能全局声明，例如在项目级别或作为插件的一部分。

  * 在命令行上分配选项时，需要显式地说明公开该选项的任务，例如`gradle check --tests abc`，即使该`check`任务取决于任务，该`test`任务也不起作用。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#worker_api)[工作者API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#worker_api)

__ |

Worker
API是一个[孵化](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_lifecycle.html#feature_lifecycle)功能。  
  
---|---  
  
从对[增量任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#incremental_tasks)的讨论中可以看出，任务执行的工作可以看作是离散的单元（即，将输入的子集转换为一定的输出子集）。很多时候，这些工作单元彼此高度独立，这意味着它们可以以任何顺序执行，并且可以简单地汇总在一起以形成任务的整体动作。在单线程执行中，这些工作单元将按顺序执行，但是，如果我们有多个处理器，则希望同时执行独立的工作单元。这样，我们可以在构建时充分利用可用资源，并更快地完成任务的活动。

Worker API提供了一种完成此操作的机制。它允许在任务动作期间安全，并行地执行多项工作。但是，Worker
API的好处不仅限于并行执行任务。您还可以配置所需的隔离级别，以便可以在隔离的类加载器中甚至在隔离的进程中执行工作。此外，好处甚至超出了执行单个任务的范围。默认情况下，使用Worker
API，Gradle可以开始并行执行任务。换句话说，一旦任务提交了要异步执行的工作并退出了任务动作，Gradle便可以并行开始执行其他独立任务，即使这些任务在同一项目中也是如此。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#using-
the-worker-api)[使用Worker
API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#using-
the-worker-api)

为了将工作提交给Worker API，必须提供两件事：工作单元的实现以及工作单元的参数。

工作单元的参数定义为实现[WorkParameters](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkParameters.html)的接口或抽象类。参数类型必须是[托管类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#managed_types)。

您可以在[开发自定义Gradle类型中](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#custom_gradle_types)找到有关实现工作参数的更多信息。

该实现是扩展[WorkAction](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkAction.html)的类。此类应该是抽象的，并且不应实现该`getParameters()`方法。Gradle将在运行时为每个工作单元的参数对象注入此方法的实现。

例子14.定义工作单位参数和实现

`Groovy``Kotlin`

build.gradle

    
    
    // The parameters for a single unit of work
    interface ReverseParameters extends WorkParameters {
        RegularFileProperty getFileToReverse()
        DirectoryProperty getDestinationDir()
    }
    
    // The implementation of a single unit of work.
    abstract class ReverseFile implements WorkAction<ReverseParameters> {
        private final FileSystemOperations fileSystemOperations
    
        @Inject
        public ReverseFile(FileSystemOperations fileSystemOperations) {
            this.fileSystemOperations = fileSystemOperations
        }
    
        @Override
        void execute() {
            fileSystemOperations.copy {
                from parameters.fileToReverse
                into parameters.destinationDir
                filter { String line -> line.reverse() }
            }
        }
    }

build.gradle.kts

    
    
    import javax.inject.Inject
    
    // The parameters for a single unit of work
    interface ReverseParameters : WorkParameters {
        val fileToReverse : RegularFileProperty
        val destinationDir : DirectoryProperty
    }
    
    // The implementation of a single unit of work
    abstract class ReverseFile @Inject constructor(val fileSystemOperations: FileSystemOperations) : WorkAction<ReverseParameters> {
        override fun execute() {
            fileSystemOperations.copy {
                from(parameters.fileToReverse)
                into(parameters.destinationDir)
                filter { line: String -> line.reversed() }
            }
        }
    }

一个`WorkAction`实现可以注入提供工作执行过程中的功能，如服务[FileSystemOperations](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/file/FileSystemOperations.html)在上面的示例服务。有关注入服务类型的更多信息，请参见[服务注入](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#service_injection)。

为了提交工作单元，必须首先获得[WorkerExecutor](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutor.html)。要做到这一点，一个任务应该有注释构造与`javax.inject.Inject`接受一个[WorkerExecutor](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutor.html)参数。创建任务时，Gradle将在运行时注入[WorkerExecutor](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutor.html)的实例。然后可以创建一个[WorkQueue](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkQueue.html)对象，并可以提交各个工作项。

例子15.提交工作单元以执行

`Groovy``Kotlin`

build.gradle

    
    
    class ReverseFiles extends SourceTask {
        private final WorkerExecutor workerExecutor
    
        @OutputDirectory
        File outputDir
    
        // The WorkerExecutor will be injected by Gradle at runtime
        @Inject
        ReverseFiles(WorkerExecutor workerExecutor) {
            this.workerExecutor = workerExecutor
        }
    
        @TaskAction
        void reverseFiles() {
            // Create a WorkQueue to submit work items
            WorkQueue workQueue = workerExecutor.noIsolation()
    
            // Create and submit a unit of work for each file
            source.each { file ->
                workQueue.submit(ReverseFile.class) { ReverseParameters parameters ->
                    parameters.fileToReverse = file
                    parameters.destinationDir = outputDir
                }
            }
        }
    }

build.gradle.kts

    
    
    // The WorkerExecutor will be injected by Gradle at runtime
    open class ReverseFiles @Inject constructor(private val workerExecutor: WorkerExecutor) : SourceTask() {
        @OutputDirectory
        lateinit var outputDir: File
    
        @TaskAction
        fun reverseFiles() {
            // Create a WorkQueue to submit work items
            val workQueue = workerExecutor.noIsolation()
    
            // Create and submit a unit of work for each file
            source.forEach { file ->
                workQueue.submit(ReverseFile::class) {
                    fileToReverse.set(file)
                    destinationDir.set(outputDir)
                }
            }
        }
    }

Once all of the work for a task action has been submitted, it is safe to exit
the task action. The work will be executed asynchronously and in parallel (up
to the setting of `max-workers`). Of course, any tasks that are dependent on
this task (and any subsequent task actions of this task) will not begin
executing until all of the asynchronous work completes. However, other
independent tasks that have no relationship to this task can begin executing
immediately.

If any failures occur while executing the asynchronous work, the task will
fail and a
[WorkerExecutionException](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutionException.html)
will be thrown detailing the failure for each failed work item. This will be
treated like any failure during task execution and will prevent any dependent
tasks from executing.

In some cases, however, it might be desirable to wait for work to complete
before exiting the task action. This is possible using the
[WorkQueue.await()](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkQueue.html#await--)
method. As in the case of allowing the work to complete asynchronously, any
failures that occur while executing an item of work will be surfaced as a
[WorkerExecutionException](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutionException.html)
thrown from the
[WorkQueue.await()](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkQueue.html#await--)
method.

__ |

Note that Gradle will only begin running other independent tasks in parallel
when a task has exited a task action and returned control of execution to
Gradle. When
[WorkQueue.await()](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkQueue.html#await--)
is used, execution does not leave the task action. This means that Gradle will
not allow other tasks to begin executing and will wait for the task action to
complete before doing so.  
  
---|---  
  
例子16.等待异步工作完成

`Groovy``Kotlin`

build.gradle

    
    
            // Create a WorkQueue to submit work items
            WorkQueue workQueue = workerExecutor.noIsolation()
    
            // Create and submit a unit of work for each file
            source.each { file ->
                workQueue.submit(ReverseFile.class) { ReverseParameters parameters ->
                    parameters.fileToReverse = file
                    parameters.destinationDir = outputDir
                }
            }
    
            // Wait for all asynchronous work submitted to this queue to complete before continuing
            workQueue.await()
            logger.lifecycle("Created ${outputDir.listFiles().size()} reversed files in ${projectLayout.projectDirectory.asFile.relativePath(outputDir)}")

build.gradle.kts

    
    
            // Create a WorkQueue to submit work items
            val workQueue = workerExecutor.noIsolation()
    
            // Create and submit a unit of work for each file
            source.forEach { file ->
                workQueue.submit(ReverseFile::class) {
                    fileToReverse.set(file)
                    destinationDir.set(outputDir)
                }
            }
    
            // Wait for all asynchronous work submitted to this queue to complete before continuing
            workQueue.await()
            logger.lifecycle("Created ${outputDir.listFiles().size} reversed files in ${outputDir.toRelativeString(projectLayout.projectDirectory.asFile)}")

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#isolation-
modes)[隔离模式](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#isolation-
modes)

摇篮提供了可以在创建时被配置三种隔离模式[工作队列](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkQueue.html)上使用下列方法中的一个被指定和[WorkerExecutor](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutor.html)：

[WorkerExecutor.noIsolation（）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutor.html#noIsolation--)

    

这表明工作应在具有最小隔离度的线程中运行。例如，它将共享从中加载任务的同一类加载器。这是最快的隔离级别。

[WorkerExecutor.classLoaderIsolation（）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutor.html#classLoaderIsolation-
org.gradle.api.Action-)

    

这表明工作应在具有隔离类加载器的线程中运行。类加载器将具有来自加载了工作单元实现类的类加载器的类路径，以及通过[ClassLoaderWorkerSpec.getClasspath（）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/ClassLoaderWorkerSpec.html#getClasspath--)添加的任何其他类路径条目。

[WorkerExecutor.processIsolation（）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/WorkerExecutor.html#processIsolation-
org.gradle.api.Action-)

    

这表明应通过在单独的进程中执行工作来最大程度地隔离工作。流程的类加载器将使用加载了工作单元的类加载器中的类路径，以及通过[ClassLoaderWorkerSpec.getClasspath（）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/ClassLoaderWorkerSpec.html#getClasspath--)添加的任何其他类路径条目。此外，该过程将是一个
_工作守护程序_ ，该 _守护程序_
将保持活动状态，并且可以重复用于将来可能具有相同要求的工作项。可以使用[ProcessWorkerSpec.forkOptions（org.gradle.api.Action）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/ProcessWorkerSpec.html#forkOptions-
org.gradle.api.Action-)使用与Gradle JVM不同的设置来配置此过程。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#worker-
daemons)[工人守护进程](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#worker-
daemons)

使用时`processIsolation()`，gradle将启动一个长期存在的 _Worker Daemon_ 进程，该进程可用于将来的工作项。

例子17.提交要在worker守护进程中运行的工作项

`Groovy``Kotlin`

build.gradle

    
    
            // Create a WorkQueue with process isolation
            WorkQueue workQueue = workerExecutor.processIsolation() { ProcessWorkerSpec spec ->
                // Configure the options for the forked process
                forkOptions { JavaForkOptions options ->
                    options.maxHeapSize = "512m"
                    options.systemProperty "org.gradle.sample.showFileSize", "true"
                }
            }
    
            // Create and submit a unit of work for each file
            source.each { file ->
                workQueue.submit(ReverseFile.class) { ReverseParameters parameters ->
                    parameters.fileToReverse = file
                    parameters.destinationDir = outputDir
                }
            }

build.gradle.kts

    
    
            // Create a WorkQueue with process isolation
            val workQueue = workerExecutor.processIsolation() {
                // Configure the options for the forked process
                forkOptions {
                    maxHeapSize = "512m"
                    systemProperty("org.gradle.sample.showFileSize", "true")
                }
            }
    
            // Create and submit a unit of work for each file
            source.forEach { file ->
                workQueue.submit(ReverseFile::class) {
                    fileToReverse.set(file)
                    destinationDir.set(outputDir)
                }
            }

提交工作程序守护程序的工作单元时，Gradle首先会查看是否存在兼容的空闲守护程序。如果是这样，它将把工作单元发送到空闲的守护程序，将其标记为忙。如果没有，它将启动一个新的守护程序。在评估兼容性时，Gradle会考虑许多标准，所有这些标准都可以通过[ProcessWorkerSpec.forkOptions（org.gradle.api.Action）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/workers/ProcessWorkerSpec.html#forkOptions-
org.gradle.api.Action-)进行控制。

默认情况下，辅助守护程序的最大堆启动为512MB。可以通过调整worker fork选项来更改。

可执行文件

    

守护程序仅在使用相同的Java可执行文件时才被认为是兼容的。

类路径

    

如果守护程序的类路径包含所有请求的类路径条目，则该守护程序被认为是兼容的。请注意，只有当类路径与请求的类路径完全匹配时，守护程序才被认为是兼容的。

堆设置

    

如果守护程序至少具有与请求相同的堆大小设置，则认为该守护程序是兼容的。换句话说，具有高于请求的堆设置的守护程序将被视为兼容。

jvm参数

    

如果守护程序已设置所有请求的jvm参数，则该守护程序被认为是兼容的。请注意，如果守护程序除了请求的参数之外还具有其他jvm参数，则该守护程序被认为是兼容的（除了专门处理的参数，例如堆设置，断言，调试等）。

系统属性

    

如果守护程序已将请求的所有系统属性设置为相同的值，则认为该守护程序是兼容的。请注意，如果守护程序具有除请求的属性之外的其他系统属性，则该守护程序被认为是兼容的。

环境变量

    

如果守护程序已将所有请求的环境变量设置为相同的值，则认为该守护程序是兼容的。请注意，如果守护程序除请求的环境变量之外还具有更多环境变量，则该守护程序被认为是兼容的。

引导类路径

    

如果守护程序包含所有请求的引导类路径条目，则该守护程序被认为是兼容的。请注意，如果守护程序除请求的引导程序类路径条目之外还有更多的引导程序类路径条目，则该守护程序被认为是兼容的。

调试

    

仅当将debug设置为与请求相同的值（真或假）时，守护程序才被视为兼容。

启用断言

    

仅当将启用断言设置为与请求相同的值（true或false）时，守护程序才被视为兼容。

默认字符编码

    

仅当默认字符编码设置为与请求相同的值时，守护程序才被视为兼容。

辅助守护程序将保持运行状态，直到启动它们的构建守护程序停止或系统内存不足为止。当可用系统内存不足时，Gradle将开始停止工作程序守护程序，以尽量减少内存消耗。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#cancellation_and_timeouts)[取消和超时](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#cancellation_and_timeouts)

为了支持取消操作（例如，当用户使用CTRL +
C停止构建时）和任务超时，自定义任务应对被中断的执行线程做出反应。通过工作人员API提交的工作项也是如此。如果任务在10秒内未响应中断，则守护程序将关闭以释放系统资源。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#more_details)[更多细节](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#more_details)

在自定义Gradle插件中打包自定义任务类型通常是一种好方法。该插件可以为任务类型提供有用的默认值和约定，并提供一种从构建脚本或其他插件使用任务类型的便捷方法。请参阅[开发自定义Gradle插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#custom_plugins)以获取更多详细信息。

Gradle提供了许多功能，这些功能在开发Gradle类型（包括任务）时很有用。有关更多详细信息，请参见[开发自定义Gradle类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html)。

**文件**

  * [用户手册](file:///userguide/userguide.html)
  * [DSL参考](file:///dsl/)
  * [发行说明](file:///release-notes.html)
  * [Java文档](file:///javadoc/)

**新闻**

  * [博客](https://blog.gradle.org/)
  * [通讯](https://newsletter.gradle.com/)
  * [推特](https://twitter.com/gradle)
  * [状态页](https://status.gradle.com/)

**产品展示**

  * [构建扫描](https://gradle.com/build-scans/)
  * [构建缓存](https://gradle.com/build-cache/)
  * [企业文件](https://gradle.com/enterprise/resources/)

**得到帮助**

  * [论坛](https://discuss.gradle.org/c/help-discuss)
  * [的GitHub](https://github.com/gradle/)
  * [训练](https://gradle.com/training/)
  * [服务](https://gradle.org/services/)

##### 随时`UP-TO-DATE`关注新功能和新闻

输入您的电子邮件，即表示您同意我们的[条款](https://gradle.com/legal/terms-of-
service/)和[隐私政策](https://gradle.com/legal/privacy/)，包括接收电子邮件。您可以随时取消订阅。

订阅

© [Gradle Inc.](https://gradle.com/) 2020年 版权所有。

[ gradle ](file:///)

[招贤纳士](https://gradle.com/careers/)| [隐私](https://gradle.com/legal/privacy/)|
[服务条款](https://gradle.com/legal/terms-of-service/)|
[联系](https://gradle.org/contact/)

![Google 翻译](./开发自定义Gradle任务类型_files/translate_24dp.png)

# 原文

提供更好的翻译建议

* * *

