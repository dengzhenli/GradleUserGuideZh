

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Composing builds

version 6.7.1

Contents

  * What is a composite build?
  * Defining a composite build
  * Interacting with a composite build
  * Declaring the dependencies substituted by an included build
  * Depending on tasks in an included build
  * Current limitations and future plans for composite builds

## What is a composite build?

A composite build is simply a build that includes other builds. In many ways a
composite build is similar to a Gradle multi-project build, except that
instead of including single `projects`, complete `builds` are included.

Composite builds allow you to:

  * combine builds that are usually developed independently, for instance when trying out a bug fix in a library that your application uses

  * decompose a large multi-project build into smaller, more isolated chunks that can be worked in independently or together as needed

A build that is included in a composite build is referred to, naturally
enough, as an "included build". Included builds do not share any configuration
with the composite build, or the other included builds. Each included build is
configured and executed in isolation.

Included builds interact with other builds via [_dependency
substitution_](resolution_rules.html#sec:dependency_substitution_rules). If
any build in the composite has a dependency that can be satisfied by the
included build, then that dependency will be replaced by a project dependency
on the included build. _Because of the reliance on dependency substitution,
composite builds may force configurations to be resolved earlier, when
composing the task execution graph. This can have a negative impact on overall
build performance, because these configurations are not resolved in parallel._

By default, Gradle will attempt to determine the dependencies that can be
substituted by an included build. However for more flexibility, it is possible
to explicitly declare these substitutions if the default ones determined by
Gradle are not correct for the composite. See Declaring substitutions.

As well as consuming outputs via project dependencies, a composite build can
directly declare task dependencies on included builds. Included builds are
isolated, and are not able to declare task dependencies on the composite build
or on other included builds. See Depending on tasks in an included build.

## Defining a composite build

The following examples demonstrate the various ways that 2 Gradle builds that
are normally developed separately can be combined into a composite build. For
these examples, the `my-utils` multi-project build produces 2 different java
libraries (`number-utils` and `string-utils`), and the `my-app` build produces
an executable using functions from those libraries.

The `my-app` build does not have direct dependencies on `my-utils`. Instead,
it declares binary dependencies on the libraries produced by `my-utils`.

Example 1. Dependencies of my-app

my-app/app/build.gradle

    
    
    plugins {
        id 'application'
    }
    
    group 'org.sample'
    version '1.0'
    
    application {
        mainClass = 'org.sample.myapp.Main'
    }
    
    dependencies {
    // tag::app_dependencies[]
        implementation 'org.sample:number-utils:1.0'
        implementation 'org.sample:string-utils:1.0'
    // end::app_dependencies[]
    }
    
    repositories {
        jcenter()
    }

my-app/app/build.gradle.kts

    
    
    plugins {
        application
    }
    
    group = "org.sample"
    version = "1.0"
    
    application {
        mainClass.set("org.sample.myapp.Main")
    }
    
    dependencies {
    // tag::app_dependencies[]
        implementation("org.sample:number-utils:1.0")
        implementation("org.sample:string-utils:1.0")
    // end::app_dependencies[]
    }
    
    repositories {
        jcenter()
    }

### Defining a composite build via `--include-build`

The `--include-build` command-line argument turns the executed build into a
composite, substituting dependencies from the included build into the executed
build.

### Example: Declaring a command-line composite

Output of **`gradle --include-build ../my-utils run`**

    
    
    > gradle --include-build ../my-utils run
    > Task :app:processResources NO-SOURCE
    > Task :my-utils:string-utils:compileJava
    > Task :my-utils:string-utils:processResources NO-SOURCE
    > Task :my-utils:string-utils:classes
    > Task :my-utils:string-utils:jar
    > Task :my-utils:number-utils:compileJava
    > Task :my-utils:number-utils:processResources NO-SOURCE
    > Task :my-utils:number-utils:classes
    > Task :my-utils:number-utils:jar
    > Task :app:compileJava
    > Task :app:classes
    
    > Task :app:run
    The answer is 42
    
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

### Defining a composite build via the settings file

It's possible to make the above arrangement persistent, by using
[Settings.includeBuild(java.lang.Object)](../dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:includeBuild\(java.lang.Object\))
to declare the included build in the `settings.gradle` (or
`settings.gradle.kts` in Kotlin) file. The settings file can be used to add
subprojects and included builds at the same time. Included builds are added by
location. See the examples below for more details.

### Defining a separate composite build

One downside of the above approach is that it requires you to modify an
existing build, rendering it less useful as a standalone build. One way to
avoid this is to define a separate composite build, whose only purpose is to
combine otherwise separate builds.

Example 2. Declaring a separate composite

settings.gradle

    
    
    rootProject.name = 'my-composite'
    
    includeBuild 'my-app'
    includeBuild 'my-utils'

settings.gradle.kts

    
    
    rootProject.name = "my-composite"
    
    includeBuild("my-app")
    includeBuild("my-utils")

In this scenario, the 'main' build that is executed is the composite, and it
doesn't define any useful tasks to execute itself. In order to execute the
'run' task in the 'my-app' build, the composite build must define a delegating
task.

Example 3. Depending on task from included build

build.gradle

    
    
    tasks.register('run') {
        dependsOn gradle.includedBuild('my-app').task(':app:run')
    }

build.gradle.kts

    
    
    tasks.register("run") {
        dependsOn(gradle.includedBuild("my-app").task(":app:run"))
    }

More details about tasks that depend on included build tasks are below.

### Restrictions on included builds

Most builds can be included into a composite, including other composite
builds. However there are some limitations.

Every included build:

  * must not have a `rootProject.name` the same as another included build.

  * must not have a `rootProject.name` the same as a top-level project of the composite build.

  * must not have a `rootProject.name` the same as the composite build `rootProject.name`.

## Interacting with a composite build

In general, interacting with a composite build is much the same as a regular
multi-project build. Tasks can be executed, tests can be run, and builds can
be imported into the IDE.

### Executing tasks

Tasks from the composite build can be executed from the command line, or from
your IDE. Executing a task will result in direct task dependencies being
executed, as well as those tasks required to build dependency artifacts from
included builds.

__ |

There is not (yet) any means to directly execute a task from an included build
via the command line. Included build tasks are automatically executed in order
to generate required dependency artifacts, or the including build can declare
a dependency on a task from an included build.  
  
---|---  
  
### Importing into the IDE

One of the most useful features of composite builds is IDE integration. By
applying the [idea](idea_plugin.html#idea_plugin) or
[eclipse](eclipse_plugin.html#eclipse_plugin) plugin to your build, it is
possible to generate a single IDEA or Eclipse project that permits all builds
in the composite to be developed together.

In addition to these Gradle plugins, recent versions of [IntelliJ
IDEA](https://www.jetbrains.com/idea/) and [Eclipse
Buildship](https://projects.eclipse.org/projects/tools.buildship) support
direct import of a composite build.

Importing a composite build permits sources from separate Gradle builds to be
easily developed together. For every included build, each sub-project is
included as an IDEA Module or Eclipse Project. Source dependencies are
configured, providing cross-build navigation and refactoring.

## Declaring the dependencies substituted by an included build

By default, Gradle will configure each included build in order to determine
the dependencies it can provide. The algorithm for doing this is very simple:
Gradle will inspect the group and name for the projects in the included build,
and substitute project dependencies for any external dependency matching
`${project.group}:${project.name}`.

There are cases when the default substitutions determined by Gradle are not
sufficient, or they are not correct for a particular composite. For these
cases it is possible to explicitly declare the substitutions for an included
build. Take for example a single-project build 'anonymous-library', that
produces a java utility library but does not declare a value for the group
attribute:

Example 4. Build that does not declare group attribute

build.gradle

    
    
    plugins {
        id 'java'
    }

build.gradle.kts

    
    
    plugins {
        java
    }

When this build is included in a composite, it will attempt to substitute for
the dependency module "undefined:anonymous-library" ("undefined" being the
default value for `project.group`, and "anonymous-library" being the root
project name). Clearly this isn't going to be very useful in a composite
build. To use the unpublished library unmodified in a composite build, the
composing build can explicitly declare the substitutions that it provides:

Example 5. Declaring the substitutions for an included build

settings.gradle

    
    
    rootProject.name = 'declared-substitution'
    
    include 'app'
    
    // tag::composite_substitution[]
    includeBuild('anonymous-library') {
        dependencySubstitution {
            substitute module('org.sample:number-utils') with project(':')
        }
    }
    // end::composite_substitution[]

settings.gradle.kts

    
    
    rootProject.name = "declared-substitution"
    
    include("app")
    
    // tag::composite_substitution[]
    includeBuild("anonymous-library") {
        dependencySubstitution {
            substitute(module("org.sample:number-utils")).with(project(":"))
        }
    }
    // end::composite_substitution[]

With this configuration, the "my-app" composite build will substitute any
dependency on `org.sample:number-utils` with a dependency on the root project
of "anonymous-library".

### Cases where included build substitutions must be declared

Many builds that use the `uploadArchives` task to publish artifacts will
function automatically as an included build, without declared substitutions.
Here are some common cases where declared substitutions are required:

  * When the `archivesBaseName` property is used to set the name of the published artifact.

  * When a configuration other than `default` is published: this usually means a task other than `uploadArchives` is used.

  * When the `MavenPom.addFilter()` is used to publish artifacts that don't match the project name.

  * When the `maven-publish` or `ivy-publish` plugins are used for publishing, and the publication coordinates don't match `${project.group}:${project.name}`.

### Cases where composite build substitutions won't work

Some builds won't function correctly when included in a composite, even when
dependency substitutions are explicitly declared. This limitation is due to
the fact that a project dependency that is substituted will always point to
the `default` configuration of the target project. Any time that the artifacts
and dependencies specified for the default configuration of a project don't
match what is actually published to a repository, then the composite build may
exhibit different behaviour.

Here are some cases where the publish module metadata may be different from
the project default configuration:

  * When a configuration other than `default` is published.

  * When the `maven-publish` or `ivy-publish` plugins are used.

  * When the `POM` or `ivy.xml` file is tweaked as part of publication.

Builds using these features function incorrectly when included in a composite
build. We plan to improve this in the future.

## Depending on tasks in an included build

While included builds are isolated from one another and cannot declare direct
dependencies, a composite build is able to declare task dependencies on its
included builds. The included builds are accessed using
[Gradle.getIncludedBuilds()](../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuilds)
or
[Gradle.includedBuild(java.lang.String)](../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuild\(java.lang.String\)),
and a task reference is obtained via the
[IncludedBuild.task(java.lang.String)](../dsl/org.gradle.api.initialization.IncludedBuild.html#org.gradle.api.initialization.IncludedBuild:task\(java.lang.String\))
method.

Using these APIs, it is possible to declare a dependency on a task in a
particular included build, or tasks with a certain path in all or some of the
included builds.

Example 6. Depending on a single task from an included build

build.gradle

    
    
    tasks.register('run') {
        dependsOn gradle.includedBuild('my-app').task(':app:run')
    }

build.gradle.kts

    
    
    tasks.register("run") {
        dependsOn(gradle.includedBuild("my-app").task(":app:run"))
    }

Example 7. Depending on a task with path in all included builds

build.gradle

build.gradle.kts

## Current limitations and future plans for composite builds

We think composite builds are pretty useful already. However, there are some
things that don't yet work the way we'd like, and other improvements that we
think will make things work even better.

Limitations of the current implementation include:

  * No support for included builds that have publications that don't mirror the project default configuration. See Cases where composite builds won't work.

  * Software model based native builds are not supported. (Binary dependencies are not yet supported for native builds).

  * Multiple composite builds may conflict when run in parallel, if more than one includes the same build. Gradle does not share the project lock of a shared composite build to between Gradle invocation to prevent concurrent execution.

Improvements we have planned for upcoming releases include:

  * Better detection of dependency substitution, for builds that publish with custom coordinates, builds that produce multiple components, etc. This will reduce the cases where dependency substitution needs to be explicitly declared for an included build.

  * The ability to target a task or tasks in an included build directly from the command line. We are currently exploring syntax options for allowing this functionality, which will remove many cases where a delegating task is required in the composite.

  * Making the implicit `buildSrc` project an included build.

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

