

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Testing in Java & JVM projects

version 6.9-20201126230040+0000

Contents

  * The basics
  * Test execution
  * Test filtering
  * Test reporting
  * Test detection
  * Test grouping
  * Using JUnit 5
  * Test execution order in TestNG
  * Configuring integration tests
  * Testing Java Modules
  * Skipping the tests
  * Forcing tests to run
  * Debugging when running tests
  * Using test fixtures

Testing on the JVM is a rich subject matter. There are many different testing
libraries and frameworks, as well as many different types of test. All need to
be part of the build, whether they are executed frequently or infrequently.
This chapter is dedicated to explaining how Gradle handles differing
requirements between and within builds, with significant coverage of how it
integrates with the two most common testing frameworks:
[JUnit](https://junit.org/) and [TestNG](https://testng.org/).

It explains:

  * Ways to control how the tests are run (Test execution)

  * How to select specific tests to run (Test filtering)

  * What test reports are generated and how to influence the process (Test reporting)

  * How Gradle finds tests to run (Test detection)

  * How to make use of the major frameworks' mechanisms for grouping tests together (Test grouping)

But first, we look at the basics of JVM testing in Gradle.

## The basics

All JVM testing revolves around a single task type:
[Test](../dsl/org.gradle.api.tasks.testing.Test.html). This runs a collection
of test cases using any supported test library — JUnit, JUnit Platform or
TestNG — and collates the results. You can then turn those results into a
report via an instance of the
[TestReport](../dsl/org.gradle.api.tasks.testing.TestReport.html) task type.

In order to operate, the `Test` task type requires just two pieces of
information:

  * Where to find the compiled test classes (property: [Test.getTestClassesDirs()](../dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:testClassesDirs))

  * The execution classpath, which should include the classes under test as well as the test library that you're using (property: [Test.getClasspath()](../dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:classpath))

When you're using a JVM language plugin — such as the [Java
Plugin](java_plugin.html#java_plugin) — you will automatically get the
following:

  * A dedicated `test` source set for unit tests

  * A `test` task of type `Test` that runs those unit tests

The JVM language plugins use the source set to configure the task with the
appropriate execution classpath and the directory containing the compiled test
classes. In addition, they attach the `test` task to the `check` [lifecycle
task](more_about_tasks.html#sec:lifecycle_tasks).

It's also worth bearing in mind that the `test` source set automatically
creates [corresponding dependency
configurations](java_plugin.html#java_source_set_configurations) — of which
the most useful are `testImplementation` and `testRuntimeOnly` — that the
plugins tie into the `test` task's classpath.

All you need to do in most cases is configure the appropriate compilation and
runtime dependencies and add any necessary configuration to the `test` task.
The following example shows a simple setup that uses JUnit 4.x and changes the
maximum heap size for the tests' JVM to 1 gigabyte:

Example 1. A basic configuration for the 'test' task

build.gradle

    
    
    dependencies {
        testImplementation 'junit:junit:4.13'
    }
    
    test {
        useJUnit()
    
        maxHeapSize = '1G'
    }

build.gradle.kts

    
    
    dependencies {
        testImplementation("junit:junit:4.13")
    }
    
    tasks.test {
        useJUnit()
    
        maxHeapSize = "1G"
    }

The [Test](../dsl/org.gradle.api.tasks.testing.Test.html) task has many
generic configuration options as well as several framework-specific ones that
you can find described in
[JUnitOptions](../javadoc/org/gradle/api/tasks/testing/junit/JUnitOptions.html),
[JUnitPlatformOptions](../javadoc/org/gradle/api/tasks/testing/junitplatform/JUnitPlatformOptions.html)
and
[TestNGOptions](../javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html).
We cover a significant number of them in the rest of the chapter.

If you want to set up your own `Test` task with its own set of test classes,
then the easiest approach is to create your own source set and `Test` task
instance, as shown in Configuring integration tests.

## Test execution

Gradle executes tests in a separate ('forked') JVM, isolated from the main
build process. This prevents classpath pollution and excessive memory
consumption for the build process. It also allows you to run the tests with
different JVM arguments than the build is using.

You can control how the test process is launched via several properties on the
`Test` task, including the following:

`maxParallelForks` — default: 1

    

You can run your tests in parallel by setting this property to a value greater
than 1. This may make your test suites complete faster, particularly if you
run them on a multi-core CPU. When using parallel test execution, make sure
your tests are properly isolated from one another. Tests that interact with
the filesystem are particularly prone to conflict, causing intermittent test
failures.

Your tests can distinguish between parallel test processes by using the value
of the `org.gradle.test.worker` property, which is unique for each process.
You can use this for anything you want, but it's particularly useful for
filenames and other resource identifiers to prevent the kind of conflict we
just mentioned.

`forkEvery` — default: 0 (no maximum)

    

This property specifies the maximum number of test classes that Gradle should
run on a test process before its disposed of and a fresh one created. This is
mainly used as a way to manage leaky tests or frameworks that have static
state that can't be cleared or reset between tests.

**Warning: a low value (other than 0) can severely hurt the performance of the
tests**

`ignoreFailures` — default: false

    

If this property is `true`, Gradle will continue with the project's build once
the tests have completed, even if some of them have failed. Note that, by
default, the `Test` task always executes every test that it detects,
irrespective of this setting.

`failFast` — (since Gradle 4.6) default: false

    

Set this to `true` if you want the build to fail and finish as soon as one of
your tests fails. This can save a lot of time when you have a long-running
test suite and is particularly useful when running the build on continuous
integration servers. When a build fails before all tests have run, the test
reports only include the results of the tests that have completed,
successfully or not.

You can also enable this behavior by using the `--fail-fast` command line
option.

`testLogging` — default: _not set_

    

This property represents a set of options that control which test events are
logged and at what level. You can also configure other logging behavior via
this property. See
[TestLoggingContainer](../javadoc/org/gradle/api/tasks/testing/logging/TestLoggingContainer.html)
for more detail.

See [Test](../dsl/org.gradle.api.tasks.testing.Test.html) for details on all
the available configuration options.

__ |

The test process can exit unexpectedly if configured incorrectly. For
instance, if the Java executable does not exist or an invalid JVM argument is
provided, the test process will fail to start. Similarly, if a test makes
programmatic changes to the test process, this can also cause unexpected
failures.

For example, issues may occur if a
`[SecurityManager](https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html)`
is modified in a test because Gradle's internal messaging depends on
reflection and socket communication, which may be disrupted if the permissions
on the security manager change. In this particular case, you should restore
the original `SecurityManager` after the test so that the gradle test worker
process can continue to function.  
  
---|---  
  
## Test filtering

It's a common requirement to run subsets of a test suite, such as when you're
fixing a bug or developing a new test case. Gradle provides two mechanisms to
do this:

  * Filtering (the preferred option)

  * Test inclusion/exclusion

Filtering supersedes the inclusion/exclusion mechanism, but you may still come
across the latter in the wild.

With Gradle's test filtering you can select tests to run based on:

  * A fully-qualified class name or fully qualified method name, e.g. `org.gradle.SomeTest`, `org.gradle.SomeTest.someMethod`

  * A simple class name or method name if the pattern starts with an upper-case letter, e.g. `SomeTest`, `SomeTest.someMethod` (since Gradle 4.7)

  * '*' wildcard matching

You can enable filtering either in the build script or via the `--tests`
command-line option. Here's an example of some filters that are applied every
time the build runs:

Example 2. Filtering tests in the build script

build.gradle

    
    
    test {
        filter {
            //include specific method in any of the tests
            includeTestsMatching "*UiCheck"
    
            //include all tests from package
            includeTestsMatching "org.gradle.internal.*"
    
            //include all integration tests
            includeTestsMatching "*IntegTest"
        }
    }

build.gradle.kts

    
    
    tasks.test {
        filter {
            //include specific method in any of the tests
            includeTestsMatching("*UiCheck")
    
            //include all tests from package
            includeTestsMatching("org.gradle.internal.*")
    
            //include all integration tests
            includeTestsMatching("*IntegTest")
        }
    }

For more details and examples of declaring filters in the build script, please
see the [TestFilter](../javadoc/org/gradle/api/tasks/testing/TestFilter.html)
reference.

The command-line option is especially useful to execute a single test method.
When you use `--tests`, be aware that the inclusions declared in the build
script are still honored. It is also possible to supply multiple `--tests`
options, all of whose patterns will take effect. The following sections have
several examples of using the command-line option.

__ |

Not all test frameworks play well with filtering. Some advanced, synthetic
tests may not be fully compatible. However, the vast majority of tests and use
cases work perfectly well with Gradle's filtering mechanism.  
  
---|---  
  
The following two sections look at the specific cases of simple class/method
names and fully-qualified names.

### Simple name pattern

Since 4.7, Gradle has treated a pattern starting with an uppercase letter as a
simple class name, or a class name + method name. For example, the following
command lines run either all or exactly one of the tests in the
`SomeTestClass` test case, regardless of what package it's in:

    
    
    # Executes all tests in SomeTestClass
    gradle test --tests SomeTestClass
    
    # Executes a single specified test in SomeTestClass
    gradle test --tests SomeTestClass.someSpecificMethod
    
    gradle test --tests SomeTestClass.*someMethod*

### Fully-qualified name pattern

Prior to 4.7 or if the pattern doesn't start with an uppercase letter, Gradle
treats the pattern as fully-qualified. So if you want to use the test class
name irrespective of its package, you would use `--tests *.SomeTestClass`.
Here are some more examples:

    
    
    # specific class
    gradle test --tests org.gradle.SomeTestClass
    
    # specific class and method
    gradle test --tests org.gradle.SomeTestClass.someSpecificMethod
    
    # method name containing spaces
    gradle test --tests "org.gradle.SomeTestClass.some method containing spaces"
    
    # all classes at specific package (recursively)
    gradle test --tests 'all.in.specific.package*'
    
    # specific method at specific package (recursively)
    gradle test --tests 'all.in.specific.package*.someSpecificMethod'
    
    gradle test --tests '*IntegTest'
    
    gradle test --tests '*IntegTest*ui*'
    
    gradle test --tests '*ParameterizedTest.foo*'
    
    # the second iteration of a parameterized test
    gradle test --tests '*ParameterizedTest.*[2]'

Note that the wildcard '*' has no special understanding of the '.' package
separator. It's purely text based. So `--tests *.SomeTestClass` will match any
package, regardless of its 'depth'.

You can also combine filters defined at the command line with [continuous
build](command_line_interface.html#sec:continuous_build) to re-execute a
subset of tests immediately after every change to a production or test source
file. The following executes all tests in the 'com.mypackage.foo' package or
subpackages whenever a change triggers the tests to run:

    
    
    gradle test --continuous --tests "com.mypackage.foo.*"

## Test reporting

The `Test` task generates the following results by default:

  * An HTML test report

  * XML test results in a format compatible with the Ant JUnit report task — one that is supported by many other tools, such as CI servers

  * An efficient binary format of the results used by the `Test` task to generate the other formats

In most cases, you'll work with the standard HTML report, which automatically
includes the results from _all_ your `Test` tasks, even the ones you
explicitly add to the build yourself. For example, if you add a `Test` task
for integration tests, the report will include the results of both the unit
tests and the integration tests if both tasks are run.

Unlike with many of the testing configuration options, there are several
project-level [convention properties that affect the test
reports](java_plugin.html#sec:java_convention_properties). For example, you
can change the destination of the test results and reports like so:

Example 3. Changing the default test report and results directories

build.gradle

    
    
    reporting.baseDir = "my-reports"
    testResultsDirName = "$buildDir/my-test-results"
    
    task showDirs {
        doLast {
            logger.quiet(rootDir.toPath().relativize(project.reportsDir.toPath()).toString())
            logger.quiet(rootDir.toPath().relativize(project.testResultsDir.toPath()).toString())
        }
    }

build.gradle.kts

    
    
    reporting.baseDir = file("my-reports")
    project.setProperty("testResultsDirName", "$buildDir/my-test-results")
    
    tasks.register("showDirs") {
        doLast {
            logger.quiet(rootDir.toPath().relativize((project.properties["reportsDir"] as File).toPath()).toString())
            logger.quiet(rootDir.toPath().relativize((project.properties["testResultsDir"] as File).toPath()).toString())
        }
    }

Output of **`gradle -q showDirs`**

    
    
    > gradle -q showDirs
    my-reports
    build/my-test-results

Follow the link to the convention properties for more details.

There is also a standalone
[TestReport](../dsl/org.gradle.api.tasks.testing.TestReport.html) task type
that you can use to generate a custom HTML test report. All it requires are a
value for `destinationDir` and the test results you want included in the
report. Here is a sample which generates a combined report for the unit tests
from all subprojects:

Example 4. Creating a unit test report for subprojects

buildSrc/src/main/groovy/myproject.java-conventions.gradle

    
    
    plugins {
        id 'java'
    }
    
    // Disable the test report for the individual test task
    test {
        reports.html.enabled = false
    }
    
    // Share the test report data to be aggregated for the whole project
    configurations {
        binaryTestResultsElements {
            canBeResolved = false
            canBeConsumed = true
            attributes {
                attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
                attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'test-report-data'))
            }
            outgoing.artifact(test.binaryResultsDirectory)
        }
    }

build.gradle

    
    
    // A resolvable configuration to collect test reports data
    configurations {
        testReportData {
            canBeResolved = true
            canBeConsumed = false
            attributes {
                attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
                attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'test-report-data'))
            }
        }
    }
    
    dependencies {
        testReportData project(':core')
        testReportData project(':util')
    }
    
    tasks.register('testReport', TestReport) {
        destinationDir = file("$buildDir/reports/allTests")
        // Use test results from testReportData configuration
        testResultDirs.from(configurations.testReportData)
    }

buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts

    
    
    plugins {
        id("java")
    }
    
    // Disable the test report for the individual test task
    tasks.named<Test>("test") {
        reports.html.isEnabled = false
    }
    
    // Share the test report data to be aggregated for the whole project
    configurations.create("binaryTestResultsElements") {
        isCanBeResolved = false
        isCanBeConsumed = true
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.DOCUMENTATION))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named("test-report-data"))
        }
        outgoing.artifact(tasks.test.map { task -> task.getBinaryResultsDirectory().get() })
    }

build.gradle.kts

    
    
    val testReportData by configurations.creating {
        isCanBeResolved = true
        isCanBeConsumed = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.DOCUMENTATION))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named("test-report-data"))
        }
    }
    
    dependencies {
        testReportData(project(":core"))
        testReportData(project(":util"))
    }
    
    tasks.register<TestReport>("testReport") {
        destinationDir = file("$buildDir/reports/allTests")
        // Use test results from testReportData configuration
        (getTestResultDirs() as ConfigurableFileCollection).from(testReportData)
    }

In this example, we use a convention plugin `myproject.java-conventions` to
expose the test results from a project to Gradle's [variant aware dependency
management engine](variant_model.html).

The plugin declares a consumable `binaryTestResultsElements` configuration
that represents the binary test results of the `test` task. In the aggregation
project's build file, we declare the `testReportData` configuration and depend
on all of the projects that we want to aggregate the results from. Gradle will
automatically select the binary test result variant from each of the
subprojects instead of the project's jar file. Lastly, we add a `testReport`
task that aggregates the test results from the `testResultsDirs` property,
which contains all of the binary test results resolved from the
`testReportData` configuration.

You should note that the `TestReport` type combines the results from multiple
test tasks and needs to aggregate the results of individual test classes. This
means that if a given test class is executed by multiple test tasks, then the
test report will include executions of that class, but it can be hard to
distinguish individual executions of that class and their output.

### Communicating test results to CI servers and other tools via XML files

The Test tasks creates XML files describing the test results, in the “JUnit
XML” pseudo standard. It is common for CI servers and other tooling to observe
test results via these XML files.

By default, the files are written to `$buildDir/test-results/$testTaskName`
with a file per test class. The location can be changed for all test tasks of
a project, or individually per test task.

Example 5. Changing JUnit XML results location for all test tasks

build.gradle

    
    
    testResultsDirName = "$buildDir/junit-xml"

build.gradle.kts

    
    
    project.setProperty("testResultsDirName", "$buildDir/junit-xml")

With the above configuration, the XML files will be written to
`$buildDir/junit-xml/$testTaskName`.

Example 6. Changing JUnit XML results location for a particular test task

build.gradle

    
    
    test {
        reports {
            junitXml.outputLocation.set(layout.buildDirectory.dir("test-junit-xml"))
        }
    }

build.gradle.kts

    
    
    tasks.test {
        reports {
            junitXml.outputLocation.set(layout.buildDirectory.dir("test-junit-xml"))
        }
    }

With the above configuration, the XML files for the `test` task will be
written to `$buildDir/test-results/test-junit-xml`. The location of the XML
files for other test tasks will be unchanged.

#### Configuration options

The content of the XML files can also be configured to convey the results
differently, by configuring the
[JUnitXmlReport](../javadoc/org/gradle/api/tasks/testing/JUnitXmlReport.html)
options.

Example 7. Configuring how the results are conveyed

build.gradle

    
    
    test {
        reports {
            junitXml {
                outputPerTestCase = true // defaults to false
                mergeReruns = true // defaults to false
            }
        }
    }

build.gradle.kts

    
    
    tasks.test {
        reports {
            junitXml.apply {
                isOutputPerTestCase = true // defaults to false
                mergeReruns.set(true) // defaults to false
            }
        }
    }

##### outputPerTestCase

The `outputPerTestCase` option, when enabled, associates any output logging
generated during a test case to that test case in the results. When disabled
(the default) output is associated with the test class as whole and not the
individual test cases (e.g. test methods) that produced the logging output.
Most modern tools that observe JUnit XML files support the “output per test
case” format.

If you are using the XML files to communicate test results, it is recommended
to enable this option as it provides more useful reporting.

##### mergeReruns

When `mergeReruns` is enabled, if a test fails but is then retried and
succeeds, its failures will be recorded as `<flakyFailure>` instead of
`<failure>`, within one `<testcase>`. This is effectively the reporting
produced by the [surefire plugin of Apache
Maven™](https://maven.apache.org/components/surefire/maven-surefire-
plugin/examples/rerun-failing-tests.html) when enabling reruns. If your CI
server understands this format, it will indicate that the test was flaky. If
it does not, it will indicate that the test succeeded as it will ignore the
`<flakyFailure>` information. If the test does not succeed (i.e. it fails for
every retry), it will be indicated as having failed whether your tool
understands this format or not.

When `mergeReruns` is disabled (the default), each execution of a test will be
listed as a separate test case.

If you are using [build scans](https://scans.gradle.com) or [Gradle
Enterprise](https://gradle.com/gradle-enterprise-solution-overview/failure-
analytics/), flaky tests will be detected regardless of this setting.

Enabling this option is especially useful when using a CI tool that uses the
XML test results to determine build failure instead of relying on Gradle's
determination of whether the build failed or not, and you wish to not consider
the build failed if all failed tests passed when retried. This is the case for
the Jenkins CI server and its [JUnit
plugin](https://plugins.jenkins.io/junit/). With `mergeReruns` enabled, tests
that pass-on-retry will no longer cause this Jenkins plugin to consider the
build to have failed. However, failed test executions will be omitted from the
Jenkins test result visualizations as it does not consider `<flakyFailure>`
information. The separate [Flaky Test Handler Jenkins
plugin](https://plugins.jenkins.io/flaky-test-handler) can be used in addition
to the JUnit Jenkins plugin to have such “flaky failures” also be visualized.

Tests are grouped and merged based on their reported name. When using any kind
of test parameterization that affects the reported test name, or any other
kind of mechanism that produces a potentially dynamic test name, care should
be taken to ensure that the test name is stable and does not unnecessarily
change.

Enabling the `mergeReruns` option does not add any retry/rerun functionality
to test execution. Rerunning can be enabled by the test execution framework
(e.g. JUnit's [@RepeatedTest](https://junit.org/junit5/docs/current/user-
guide/#writing-tests-repeated-tests)), or via the separate [Test Retry Gradle
plugin](https://github.com/gradle/test-retry-gradle-plugin).

## Test detection

By default, Gradle will run all tests that it detects, which it does by
inspecting the compiled test classes. This detection uses different criteria
depending on the test framework used.

For _JUnit_ , Gradle scans for both JUnit 3 and 4 test classes. A class is
considered to be a JUnit test if it:

  * Ultimately inherits from `TestCase` or `GroovyTestCase`

  * Is annotated with `@RunWith`

  * Contains a method annotated with `@Test` or a super class does

For _TestNG_ , Gradle scans for methods annotated with `@Test`.

Note that abstract classes are not executed. In addition, be aware that Gradle
scans up the inheritance tree into jar files on the test classpath. So if
those JARs contain test classes, they will also be run.

If you don't want to use test class detection, you can disable it by setting
the `scanForTestClasses` property on
[Test](../dsl/org.gradle.api.tasks.testing.Test.html) to `false`. When you do
that, the test task uses only the `includes` and `excludes` properties to find
test classes.

If `scanForTestClasses` is false and no include or exclude patterns are
specified, Gradle defaults to running any class that matches the patterns
`**/*Tests.class` and `**/*Test.class`, excluding those that match
`**/Abstract*.class`.

__ |

With [JUnit Platform](http://junit.org/junit5/docs/current/user-guide), only
`includes` and `excludes` are used to filter test classes —
`scanForTestClasses` has no effect.  
  
---|---  
  
## Test grouping

JUnit, JUnit Platform and TestNG allow sophisticated groupings of test
methods.

JUnit 4.8 introduced the concept of categories for grouping JUnit 4 tests
classes and methods.[1]
[Test.useJUnit(org.gradle.api.Action)](../dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:useJUnit\(org.gradle.api.Action\))
allows you to specify the JUnit categories you want to include and exclude.
For example, the following configuration includes tests in `CategoryA` and
excludes those in `CategoryB` for the `test` task:

Example 8. JUnit Categories

build.gradle

    
    
    test {
        useJUnit {
            includeCategories 'org.gradle.junit.CategoryA'
            excludeCategories 'org.gradle.junit.CategoryB'
        }
    }

build.gradle.kts

    
    
    tasks.test {
        useJUnit {
            includeCategories("org.gradle.junit.CategoryA")
            excludeCategories("org.gradle.junit.CategoryB")
        }
    }

[JUnit Platform](http://junit.org/junit5/docs/current/user-guide) introduced
[tagging](http://junit.org/junit5/docs/current/user-guide/#writing-tests-
tagging-and-filtering) to replace categories. You can specify the
included/excluded tags via
[Test.useJUnitPlatform(org.gradle.api.Action)](../javadoc/org/gradle/api/tasks/testing/Test.html#useJUnitPlatform-
org.gradle.api.Action-), as follows:

Example 9. JUnit Platform Tags

build.gradle

    
    
    test {
        useJUnitPlatform {
            includeTags 'fast'
            excludeTags 'slow'
        }
    }

build.gradle.kts

    
    
    tasks.test {
        useJUnitPlatform {
            includeTags("fast")
            excludeTags("slow")
        }
    }

The TestNG framework uses the concept of test groups for a similar effect.[2]
You can configure which test groups to include or exclude during the test
execution via the
[Test.useTestNG(org.gradle.api.Action)](../dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:useTestNG\(org.gradle.api.Action\))
setting, as seen here:

Example 10. Grouping TestNG tests

build.gradle

    
    
    test {
        useTestNG {
            excludeGroups 'integrationTests'
            includeGroups 'unitTests'
        }
    }

build.gradle.kts

    
    
    tasks.named<Test>("test") {
        useTestNG {
            val options = this as TestNGOptions
            options.excludeGroups("integrationTests")
            options.includeGroups("unitTests")
        }
    }

## Using JUnit 5

[JUnit 5](http://junit.org/junit5) is the latest version of the well-known
JUnit test framework. Unlike its predecessor, JUnit 5 is modularized and
composed of several modules:

    
    
    JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage

The JUnit Platform serves as a foundation for launching testing frameworks on
the JVM. JUnit Jupiter is the combination of the new [programming
model](http://junit.org/junit5/docs/current/user-guide/#writing-tests) and
[extension model](http://junit.org/junit5/docs/current/user-guide/#extensions)
for writing tests and extensions in JUnit 5. JUnit Vintage provides a
`TestEngine` for running JUnit 3 and JUnit 4 based tests on the platform.

The following code enables JUnit Platform support in `build.gradle`:

Example 11. Enabling JUnit Platform to run your tests

build.gradle

    
    
    test {
        useJUnitPlatform()
    }

build.gradle.kts

    
    
    tasks.named<Test>("test") {
        useJUnitPlatform()
    }

See
[Test.useJUnitPlatform()](../javadoc/org/gradle/api/tasks/testing/Test.html#useJUnitPlatform--)
for more details.

__ |

There are some known limitations of using JUnit 5 with Gradle, for example
that tests in static nested classes won't be discovered. These will be fixed
in future version of Gradle. If you find more, please tell us at
<https://github.com/gradle/gradle/issues/new>  
  
---|---  
  
### Compiling and executing JUnit Jupiter tests

To enable JUnit Jupiter support in Gradle, all you need to do is add the
following dependencies:

Example 12. JUnit Jupiter dependencies

build.gradle

    
    
    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
    }

build.gradle.kts

    
    
    dependencies {
        testImplementation("org.junit.jupiter:junit-jupiter-api:5.6.0")
        testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
    }

You can then put your test cases into _src/test/java_ as normal and execute
them with `gradle test`.

### Executing legacy tests with JUnit Vintage

If you want to run JUnit 3/4 tests on JUnit Platform, or even mix them with
Jupiter tests, you should add extra JUnit Vintage Engine dependencies:

Example 13. JUnit Vintage dependencies

build.gradle

    
    
    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
        testCompileOnly 'junit:junit:4.13'
        testRuntimeOnly 'org.junit.vintage:junit-vintage-engine'
    }

build.gradle.kts

    
    
    dependencies {
        testImplementation("org.junit.jupiter:junit-jupiter-api:5.6.0")
        testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
        testCompileOnly("junit:junit:4.13")
        testRuntimeOnly("org.junit.vintage:junit-vintage-engine")
    }

In this way, you can use `gradle test` to test JUnit 3/4 tests on JUnit
Platform, without the need to rewrite them.

### Filtering test engine

JUnit Platform allows you to use different test engines. JUnit currently
provides two `TestEngine` implementations out of the box: [junit-jupiter-
engine](https://junit.org/junit5/docs/current/api/org.junit.jupiter.engine/module-
summary.html) and [junit-vintage-
engine](https://junit.org/junit5/docs/current/api/org.junit.vintage.engine/module-
summary.html). You can also write and plug in your own `TestEngine`
implementation as documented
[here](https://junit.org/junit5/docs/current/user-guide/#launcher-api-engines-
custom).

By default, all test engines on the test runtime classpath will be used. To
control specific test engine implementations explicitly, you can add the
following setting to your build script:

Example 14. Filter specific engines

build.gradle

    
    
    test {
        useJUnitPlatform {
            includeEngines 'junit-vintage'
            // excludeEngines 'junit-jupiter'
        }
    }

build.gradle.kts

    
    
    tasks.test {
        useJUnitPlatform {
            includeEngines("junit-vintage")
            // excludeEngines("junit-jupiter")
        }
    }

## Test execution order in TestNG

TestNG allows explicit control of the execution order of tests when you use a
_testng.xml_ file. Without such a file — or an equivalent one configured by
[TestNGOptions.getSuiteXmlBuilder()](../javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html#getSuiteXmlBuilder--)
— you can't specify the test execution order. However, what you _can_ do is
control whether all aspects of a test — including its associated `@BeforeXXX`
and `@AfterXXX` methods, such as those annotated with `@Before/AfterClass` and
`@Before/AfterMethod` — are executed before the next test starts. You do this
by setting the
[TestNGOptions.getPreserveOrder()](../javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html#getPreserveOrder--)
property to `true`. If you set it to `false`, you may encounter scenarios in
which the execution order is something like: `TestA.doBeforeClass()` ->
`TestB.doBeforeClass()` -> `TestA` tests.

While preserving the order of tests is the default behavior when directly
working with _testng.xml_ files, the [TestNG
API](https://jitpack.io/com/github/cbeust/testng/master/javadoc/org/testng/TestNG.html)
that is used by Gradle's TestNG integration executes tests in unpredictable
order by default.[3] The ability to preserve test execution order was
introduced with TestNG version 5.14.5. Setting the `preserveOrder` property to
`true` for an older TestNG version will cause the build to fail.

Example 15. Preserving order of TestNG tests

build.gradle

    
    
    test {
        useTestNG {
            preserveOrder true
        }
    }

build.gradle.kts

    
    
    tasks.test {
        useTestNG {
            preserveOrder = true
        }
    }

The `groupByInstance` property controls whether tests should be grouped by
instance rather than by class. The [TestNG
documentation](http://testng.org/doc/documentation-main.html#dependencies-
with-annotations) explains the difference in more detail, but essentially, if
you have a test method `A()` that depends on `B()`, grouping by instance
ensures that each A-B pairing, e.g. `B(1)`-`A(1)`, is executed before the next
pairing. With group by class, all `B()` methods are run and then all `A()`
ones.

Note that you typically only have more than one instance of a test if you're
using a data provider to parameterize it. Also, grouping tests by instances
was introduced with TestNG version 6.1. Setting the `groupByInstances`
property to `true` for an older TestNG version will cause the build to fail.

Example 16. Grouping TestNG tests by instances

build.gradle

    
    
    test {
        useTestNG {
            groupByInstances = true
        }
    }

build.gradle.kts

    
    
    tasks.test {
        useTestNG {
            groupByInstances = true
        }
    }

### TestNG parameterized methods and reporting

TestNG supports [parameterizing test
methods](http://testng.org/doc/documentation-main.html#parameters), allowing a
particular test method to be executed multiple times with different inputs.
Gradle includes the parameter values in its reporting of the test method
execution.

Given a parameterized test method named `aTestMethod` that takes two
parameters, it will be reported with the name
`aTestMethod(toStringValueOfParam1, toStringValueOfParam2)`. This makes it
easy to identify the parameter values for a particular iteration.

## Configuring integration tests

A common requirement for projects is to incorporate integration tests in one
form or another. Their aim is to verify that the various parts of the project
are working together properly. This often means that they require special
execution setup and dependencies compared to unit tests.

The simplest way to add integration tests to your build is by taking these
steps:

  1. Create a new [source set](building_java_projects.html#sec:java_source_sets) for them

  2. Add the dependencies you need to the appropriate configurations for that source set

  3. Configure the compilation and runtime classpaths for that source set

  4. Create a task to run the integration tests

You may also need to perform some additional configuration depending on what
form the integration tests take. We will discuss those as we go.

Let's start with a practical example that implements the first three steps in
a build script, centered around a new source set `intTest`:

Example 17. Setting up working integration tests

build.gradle

    
    
    sourceSets {
        intTest {
            compileClasspath += sourceSets.main.output
            runtimeClasspath += sourceSets.main.output
        }
    }
    
    configurations {
        intTestImplementation.extendsFrom implementation
        intTestRuntimeOnly.extendsFrom runtimeOnly
    }
    
    dependencies {
        intTestImplementation 'junit:junit:4.13'
    }

build.gradle.kts

    
    
    sourceSets {
        create("intTest") {
            compileClasspath += sourceSets.main.get().output
            runtimeClasspath += sourceSets.main.get().output
        }
    }
    
    val intTestImplementation by configurations.getting {
        extendsFrom(configurations.implementation.get())
    }
    
    configurations["intTestRuntimeOnly"].extendsFrom(configurations.runtimeOnly.get())
    
    dependencies {
        intTestImplementation("junit:junit:4.13")
    }

This will set up a new source set called `intTest` that automatically creates:

  * `intTestImplementation`, `intTestCompileOnly`, `intTestRuntimeOnly` configurations (and [a few others](java_plugin.html#java_source_set_configurations) that are less commonly needed)

  * A `compileIntTestJava` task that will compile all the source files under _src/intTest/java_

The example also does the following, not all of which you may need for your
specific integration tests:

  * Adds the production classes from the `main` source set to the compilation and runtime classpaths of the integration tests — `sourceSets.main.output` is a [file collection](working_with_files.html#sec:file_collections) of all the directories containing compiled production classes and resources

  * Makes the `intTestImplementation` configuration extend from `implementation`, which means that all the declared dependencies of the production code also become dependencies of the integration tests

  * Does the same for the `intTestRuntimeOnly` configuration

In most cases, you want your integration tests to have access to the classes
under test, which is why we ensure that those are included on the compilation
and runtime classpaths in this example. But some types of test interact with
the production code in a different way. For example, you may have tests that
run your application as an executable and verify the output. In the case of
web applications, the tests may interact with your application via HTTP. Since
the tests don't need direct access to the classes under test in such cases,
you don't need to add the production classes to the test classpath.

Another common step is to attach all the unit test dependencies to the
integration tests as well — via `intTestImplementation.extendsFrom
testImplementation` — but that only makes sense if the integration tests
require _all_ or nearly all the same dependencies that the unit tests have.

There are a couple of other facets of the example you should take note of:

  * `+=` allows you to append paths and collections of paths to `compileClasspath` and `runtimeClasspath` instead of overwriting them

  * If you want to use the convention-based configurations, such as `intTestImplementation`, you _must_ declare the dependencies _after_ the new source set

Creating and configuring a source set automatically sets up the compilation
stage, but it does nothing with respect to running the integration tests. So
the last piece of the puzzle is a custom test task that uses the information
from the new source set to configure its runtime classpath and the test
classes:

Example 18. Defining a working integration test task

build.gradle

    
    
    task integrationTest(type: Test) {
        description = 'Runs integration tests.'
        group = 'verification'
    
        testClassesDirs = sourceSets.intTest.output.classesDirs
        classpath = sourceSets.intTest.runtimeClasspath
        shouldRunAfter test
    }
    
    check.dependsOn integrationTest

build.gradle.kts

    
    
    val integrationTest = task<Test>("integrationTest") {
        description = "Runs integration tests."
        group = "verification"
    
        testClassesDirs = sourceSets["intTest"].output.classesDirs
        classpath = sourceSets["intTest"].runtimeClasspath
        shouldRunAfter("test")
    }
    
    tasks.check { dependsOn(integrationTest) }

Again, we're accessing a source set to get the relevant information, i.e.
where the compiled test classes are — the `testClassesDirs` property — and
what needs to be on the classpath when running them — `classpath`.

Users commonly want to run integration tests after the unit tests, because
they are often slower to run and you want the build to fail early on the unit
tests rather than later on the integration tests. That's why the above example
adds a `shouldRunAfter()` declaration. This is preferred over `mustRunAfter()`
so that Gradle has more flexibility in executing the build in parallel.

## Testing Java Modules

If you are [developing Java Modules](java_library_plugin.html), everything
described in this chapter still applies and any of the supported test
frameworks can be used. However, there are some things to consider depending
on whether you need module information to be available, and module boundaries
to be enforced, during test execution. In this context, the terms _whitebox
testing_ (module boundaries are deactivated or relaxed) and _blackbox testing_
(module boundaries are in place) are often used. Whitebox testing is
used/needed for unit testing and blackbox testing fits functional or
integration test requirements.

Sample: [Java Modules multi-project with integration
tests](../samples/sample_java_modules_multi_project_with_integration_tests.html)

### Whitebox unit test execution on the classpath

The simplest setup to write unit tests for functions or classes in modules is
to _not_ use module specifics during test execution. For this, you just need
to write tests the same way you would write them for normal libraries. If you
don't have a `module-info.java` file in your test source set (`src/test/java`)
this source set will be considered as traditional Java library during
compilation and test runtime. This means, all dependencies, including Jars
with module information, are put on the classpath. The advantage is that all
internal classes of your (or other) modules are then accessible directly in
tests. This may be a totally valid setup for unit testing, where we do not
care about the larger module structure, but only about testing single
functions.

__ |

If you are using Eclipse: By default, Eclipse also runs unit tests as modules
using module patching (see below). In an imported Gradle project, unit testing
a module with the Eclipse test runner might fail. You then need to manually
adjust the classpath/module path in the test run configuration or delegate
test execution to Gradle. This only concerns the test execution. Unit test
compilation and development works fine in Eclipse.  
  
---|---  
  
### Blackbox integration testing

For integration tests, you have the option to define the test set itself as
additional module. You do this similar to how you turn your main sources into
a module: by adding a `module-info.java` file to the corresponding source set
(e.g. `integrationTests/java/module-info.java`).

You can find a full example that includes blackbox integration tests
[here](../samples/sample_java_modules_multi_project_with_integration_tests.html).

__ |

In Eclipse, compiling multiple modules in one project is [currently not
support](https://bugs.eclipse.org/bugs/show_bug.cgi?id=520667). Therefore the
integration test (blackbox) setup described here only works in Eclipse if the
tests are moved to a separate subproject.  
  
---|---  
  
### Whitebox test execution with module patching

Another approach for whitebox testing is to stay in the module world by
_patching_ the tests into the module under test. This way, module boundaries
stay in place, but the tests themselves become part of the module under test
and can then access the module's internals.

For which uses cases this is relevant and how this is best done is a topic of
discussion. There is no general best approach at the moment. Thus, there is no
special support for this in Gradle right now.

You can however, setup module patching for tests like this:

  * Add a `module-info.java` to your test source set that is a copy of the main `module-info.java` with additional dependencies needed for testing (e.g. `requires org.junit.jupiter.api`).

  * Configure both the `testCompileJava` and `test` tasks with arguments to patch the the main classes with the test classes as shown below.

Example 19. Patch module for testing using command line arguments

build.gradle

    
    
    def moduleName = "org.gradle.sample"
    def patchArgs = ["--patch-module", "$moduleName=${tasks.compileJava.destinationDirectory.asFile.get().path}"]
    tasks.compileTestJava {
        options.compilerArgs += patchArgs
    }
    tasks.test {
        jvmArgs += patchArgs
    }

build.gradle.kts

    
    
    val moduleName = "org.gradle.sample"
    val patchArgs = listOf("--patch-module", "$moduleName=${tasks.compileJava.get().destinationDirectory.asFile.get().path}")
    tasks.compileTestJava {
        options.compilerArgs.addAll(patchArgs)
    }
    tasks.test {
        jvmArgs(patchArgs)
    }

__ |

If custom arguments are used for patching, these are not picked up by Eclipse
and IDEA. You will most likely see invalid compilation errors in the IDE.  
  
---|---  
  
## Skipping the tests

If you want to skip the tests when running a build, you have a few options.
You can either do it via [command line
arguments](command_line_interface.html#sec:excluding_tasks_from_the_command_line)
or [in the build script](more_about_tasks.html#sec:skipping_tasks). To do it
on the command line, you can use the `-x` or `--exclude-task` option like so:

    
    
    gradle build -x test

This excludes the `test` task and any other task that it _exclusively_ depends
on, i.e. no other task depends on the same task. Those tasks will not be
marked "SKIPPED" by Gradle, but will simply not appear in the list of tasks
executed.

Skipping a test via the build script can be done a few ways. One common
approach is to make test execution conditional via the
[Task.onlyIf(org.gradle.api.specs.Spec)](../dsl/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf\(org.gradle.api.specs.Spec\))
method. The following sample skips the `test` task if the project has a
property called `mySkipTests`:

Example 20. Skipping the unit tests based on a project property

build.gradle

    
    
    test.onlyIf { !project.hasProperty('mySkipTests') }

build.gradle.kts

    
    
    tasks.test { onlyIf { !project.hasProperty("mySkipTests") } }

In this case, Gradle will mark the skipped tests as "SKIPPED" rather than
exclude them from the build.

## Forcing tests to run

In well-defined builds, you can rely on Gradle to only run tests if the tests
themselves or the production code change. However, you may encounter
situations where the tests rely on a third-party service or something else
that might change but can't be modeled in the build.

You can force tests to run in this situation by cleaning the output of the
relevant `Test` task — say `test` — and running the tests again, like so:

    
    
    gradle cleanTest test

`cleanTest` is based on a [task rule](more_about_tasks.html#sec:task_rules)
provided by the [Base Plugin](base_plugin.html#sec:base_tasks). You can use it
for _any_ task.

## Debugging when running tests

On the few occasions that you want to debug your code while the tests are
running, it can be helpful if you can attach a debugger at that point. You can
either set the
[Test.getDebug()](../dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:debug)
property to `true` or use the `--debug-jvm` command line option.

When debugging for tests is enabled, Gradle will start the test process
suspended and listening on port 5005.

You can also enable debugging in the DSL, where you can also configure other
properties:

    
    
    test {
        debugOptions {
            enabled = true
            port = 4455
            server = true
            suspend = true
        }
    }

With this configuration the test JVM will behave just like when passing the
`--debug-jvm` argument but it will listen on port 4455.

## Using test fixtures

### Producing and using test fixtures within a single project

Test fixtures are commonly used to setup the code under test, or provide
utilities aimed at facilitating the tests of a component. Java projects can
enable test fixtures support by applying the `java-test-fixtures` plugin, in
addition to the `java` or `java-library` plugins:

Example 21. Applying the Java test fixtures plugin

lib/build.gradle

    
    
    plugins {
        // A Java Library
        id 'java-library'
        // which produces test fixtures
        id 'java-test-fixtures'
        // and is published
        id 'maven-publish'
    }

lib/build.gradle.kts

    
    
    plugins {
        // A Java Library
        `java-library`
        // which produces test fixtures
        `java-test-fixtures`
        // and is published
        `maven-publish`
    }

This will automatically create a `testFixtures` source set, in which you can
write your test fixtures. Test fixtures are configured so that:

  * they can see the _main_ source set classes

  * _test_ sources can see the _test fixtures_ classes

For example for this main class:

src/main/java/com/acme/Person.java

    
    
    public class Person {
        private final String firstName;
        private final String lastName;
    
        public Person(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }
    
        public String getFirstName() {
            return firstName;
        }
    
        public String getLastName() {
            return lastName;
        }
    
        // ...

A test fixture can be written in `src/testFixtures/java`:

src/testFixtures/java/com/acme/Simpsons.java

    
    
    public class Simpsons {
        private static final Person HOMER = new Person("Homer", "Simpson");
        private static final Person MARGE = new Person("Marjorie", "Simpson");
        private static final Person BART = new Person("Bartholomew", "Simpson");
        private static final Person LISA = new Person("Elisabeth Marie", "Simpson");
        private static final Person MAGGIE = new Person("Margaret Eve", "Simpson");
        private static final List<Person> FAMILY = new ArrayList<Person>() {{
            add(HOMER);
            add(MARGE);
            add(BART);
            add(LISA);
            add(MAGGIE);
        }};
    
        public static Person homer() { return HOMER; }
    
        public static Person marge() { return MARGE; }
    
        public static Person bart() { return BART; }
    
        public static Person lisa() { return LISA; }
    
        public static Person maggie() { return MAGGIE; }
    
        // ...

### Declaring dependencies of test fixtures

Similarly to the [Java Library Plugin](java_library_plugin.html), test
fixtures expose an API and an implementation configuration:

Example 22. Declaring test fixture dependencies

lib/build.gradle

    
    
    dependencies {
        testImplementation 'junit:junit:4.13'
    
        // API dependencies are visible to consumers when building
        testFixturesApi 'org.apache.commons:commons-lang3:3.9'
    
        // Implementation dependencies are not leaked to consumers when building
        testFixturesImplementation 'org.apache.commons:commons-text:1.6'
    }

lib/build.gradle.kts

    
    
    dependencies {
        testImplementation("junit:junit:4.13")
    
        // API dependencies are visible to consumers when building
        testFixturesApi("org.apache.commons:commons-lang3:3.9")
    
        // Implementation dependencies are not leaked to consumers when building
        testFixturesImplementation("org.apache.commons:commons-text:1.6")
    }

It's worth noticing that if a dependency is an _implementation_ dependency of
test fixtures, then _when compiling tests that depend on those test fixtures_
, the implementation dependencies will _not leak_ into the compile classpath.
This results in improved separation of concerns and better compile avoidance.

### Consuming test fixtures of another project

Test fixtures are not limited to a single project. It is often the case that a
dependent project tests also needs the test fixtures of the dependency. This
can be achieved very easily using the `testFixtures` keyword:

Example 23. Adding a dependency on test fixtures of another project

build.gradle

    
    
    dependencies {
        implementation(project(":lib"))
    
        testImplementation 'junit:junit:4.13'
        testImplementation(testFixtures(project(":lib")))
    }

build.gradle.kts

    
    
    dependencies {
        implementation(project(":lib"))
    
        testImplementation("junit:junit:4.13")
        testImplementation(testFixtures(project(":lib")))
    }

### Publishing test fixtures

One of the advantages of using the `java-test-fixtures` plugin is that test
fixtures are published. By convention, test fixtures will be published with an
artifact having the `test-fixtures` classifier. For both Maven and Ivy, an
artifact with that classifier is simply published alongside the regular
artifacts. However, if you use the `maven-publish` or `ivy-publish` plugin,
test fixtures are published as additional variants in [Gradle Module
Metadata](https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-
module-metadata-1.0-specification.md) and you can directly depend on test
fixtures of external libraries in another Gradle project:

Example 24. Adding a dependency on test fixtures of an external library

build.gradle

    
    
    dependencies {
        // Adds a dependency on the test fixtures of Gson, however this
        // project doesn't publish such a thing
        functionalTest testFixtures("com.google.code.gson:gson:2.8.5")
    }

build.gradle.kts

    
    
    dependencies {
        // Adds a dependency on the test fixtures of Gson, however this
        // project doesn't publish such a thing
        functionalTest(testFixtures("com.google.code.gson:gson:2.8.5"))
    }

It's worth noting that if the external project is _not_ publishing Gradle
Module Metadata, then resolution will fail with an error indicating that such
a variant cannot be found:

Output of **`gradle dependencyInsight --configuration functionalTestClasspath
--dependency gson`**

    
    
    > gradle dependencyInsight --configuration functionalTestClasspath --dependency gson
    
    > Task :dependencyInsight
    com.google.code.gson:gson:2.8.5 FAILED
       Failures:
          - Could not resolve com.google.code.gson:gson:2.8.5.
              - Unable to find a variant of com.google.code.gson:gson:2.8.5 providing the requested capability com.google.code.gson:gson-test-fixtures:
                   - Variant compile provides com.google.code.gson:gson:2.8.5
                   - Variant runtime provides com.google.code.gson:gson:2.8.5
                   - Variant platform-compile provides com.google.code.gson:gson-derived-platform:2.8.5
                   - Variant platform-runtime provides com.google.code.gson:gson-derived-platform:2.8.5
                   - Variant enforced-platform-compile provides com.google.code.gson:gson-derived-enforced-platform:2.8.5
                   - Variant enforced-platform-runtime provides com.google.code.gson:gson-derived-enforced-platform:2.8.5
    
    com.google.code.gson:gson:2.8.5 FAILED
    \--- functionalTestClasspath
    
    A web-based, searchable dependency report is available by adding the --scan option.
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

The error message mentions the missing `com.google.code.gson:gson-test-
fixtures` capability, which is indeed not defined for this library. That's
because by convention, for projects that use the `java-test-fixtures` plugin,
Gradle automatically creates test fixtures variants with a capability whose
name is the name of the main component, with the appendix `-test-fixtures`.

__ |

If you publish your library and use test fixtures, but do not want to publish
the fixtures, you can deactivate publishing of the _test fixtures variants_ as
shown below.  
  
---|---  
  
Example 25. Disable publishing of test fixtures variants

build.gradle

    
    
    components.java.withVariantsFromConfiguration(configurations.testFixturesApiElements) { skip() }
    components.java.withVariantsFromConfiguration(configurations.testFixturesRuntimeElements) { skip() }

build.gradle.kts

    
    
    val javaComponent = components["java"] as AdhocComponentWithVariants
    javaComponent.withVariantsFromConfiguration(configurations["testFixturesApiElements"]) { skip() }
    javaComponent.withVariantsFromConfiguration(configurations["testFixturesRuntimeElements"]) { skip() }

* * *

1. The JUnit wiki contains a detailed description on how to work with JUnit categories: <https://github.com/junit-team/junit/wiki/Categories>. 

2. The TestNG documentation contains more details about test groups: <http://testng.org/doc/documentation-main.html#test-groups>. 

3. The TestNG documentation contains more details about test ordering when working with `testng.xml` files: <http://testng.org/doc/documentation-main.html#testng-xml>. 

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

