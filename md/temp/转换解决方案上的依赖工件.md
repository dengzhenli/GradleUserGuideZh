

[ Gradle ](https://docs.gradle.org/ "Gradle Docs")

用户手册

  * 社区 Open Community Menu

[ 社区之家 ](https://gradle.org/)

[ 社区论坛 ](https://discuss.gradle.org/)

[ 社区插件 ](https://plugins.gradle.org/)

  * [训练](https://gradle.com/training/)
  * 新闻 Open Community Menu

[ 通讯 ](https://newsletter.gradle.com/)

[ 博客 ](https://blog.gradle.org/)

[ 推特 ](https://twitter.com/gradle)

  * [企业](https://gradle.com/)
  * [github](https://github.com/gradle/gradle "GitHub上的Gradle")

  * [文件首页](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.html)
  * [样品](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html)
  * [发行说明](file:///Users/dxs/temp/gradle-6.7.1/docs/release-notes.html)
  * [Gradle API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#gradle-api)
    * [Java文档](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/index.html?overview-summary.html)
    * [Groovy DSL参考](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/index.html)
    * [Groovy DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/kotlin_dsl.html)

### 用户手册

[ PDF格式 ](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.pdf)

  * [什么是Gradle？](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/what_is_gradle.html)
  * [入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/getting_started.html)
  * [安装Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/installation.html)
  * [升级Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#upgrading-gradle)
    * [version 6.X to latest](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_lifecycle.html)
  * [迁移至Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#migrating-to-gradle)
    * [from Maven](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_maven.html)
    * [from Ant](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_ant.html)
  * [相容性说明](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/compatibility.html)
  * [对构建进行故障排除](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/troubleshooting.html)

### 运行Gradle构建

  * [自定义执行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#customizing-execution)
    * [Configuring the Build Environment](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_environment.html)
    * [Configuring the Gradle Daemon](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_daemon.html)
    * [Using Initialization Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/init_scripts.html)
  * [执行多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/intro_multi_project_builds.html)
  * [检查Gradle构建](https://scans.gradle.com/)
  * [优化构建时间](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#optimizing-build-performance)
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_cache.html)
    * [Using the Configuration Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/configuration_cache.html)

### 编写Gradle构建

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#learning-the-basics)
    * [Introducing the Basics of Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/tutorial_using_tasks.html)
    * [Working with Tasks](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/writing_build_scripts.html)
    * [Working with Files](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/working_with_files.html)
    * [Using Gradle Plugins](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html)
    * [Understanding the Build Lifecycle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_lifecycle.html)
    * [Working with Logging](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/logging.html)
    * [Avoiding Traps](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/potential_traps.html)
  * [创作多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#authoring-multi-project-builds)
    * [Creating a Basic Multi-Project Build](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_configuration_and_execution.html)
  * [创作可持续建筑](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#authoring-sustainable-builds)
    * [Organizing Build Logic](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html)
    * [Following Best Practices](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/authoring_maintainable_build_scripts.html)
  * [先进技术](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#advanced-techniques)
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/test_kit.html)
    * [Using Ant from Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/ant.html)

### 编写JVM构建

  * [构建Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html)
  * [测试Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html)
  * [Java项目的工具链](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html)
  * [管理依赖关系](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_for_java_projects.html)
  * [JVM插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#jvm-plugins)
    * [Java Library Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)
    * [Java Application Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/application_plugin.html)
    * [Java Platform Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_platform_plugin.html)
    * [Groovy Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html)
    * [Scala Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/scala_plugin.html)

### 编写C ++ / Swift构建

  * [构建C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_cpp_projects.html)
  * [测试C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cpp_testing.html)
  * [建立Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_swift_projects.html)
  * [测试Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/swift_testing.html)

### 使用依赖项

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#learning-the-basics-dependency-management)
    * [What is Dependency Management?](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/core_dependency_management.html)
    * [Declaring Repositories](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html)
    * [Declaring Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_resolution.html)
    * [Verifying dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_verification.html)
  * [声明版本](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#declaring-dependency-versions)
    * [Declaring Versions and Ranges](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/single_versions.html)
    * [Declaring Rich Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/rich_versions.html)
    * [Handling Changing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dynamic_versions.html)
    * [Locking Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_locking.html)
  * [控制翻译](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#controlling-transitive-dependencies)
    * [Upgrading Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_constraints.html)
    * [Downgrading and Excluding](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/platforms.html)
    * [Aligning Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_metadata_rules.html)
    * [Customizing Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_rules.html)
    * [Preventing accidental upgrades](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_strategy_tuning.html)
  * [图书馆的生产和消费形式](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#modeling-features)
    * [声明图书馆的能力](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_capabilities.html)
    * [建模功能变体和可选依赖项](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_variants.html)
    * [了解变体选择](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html)
    * [声明变体属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_attributes.html)
    * [共享项目成果](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cross_project_publications.html)
    * [改造神器](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html)
  * [在多仓库环境中工作](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#multi-repo)
    * [Composing Builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/composite_builds.html)
  * [出版图书馆](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#publishing)
    * [Setting up Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_signing.html)
    * [Customizing Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_customization.html)
    * [Maven Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_maven.html)
    * [Ivy Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html)
  * [术语](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_terminology.html)

### 扩展摇篮

  * [插件开发教程](https://gradle.org/guides/?q=Plugin%20Development)
  * [编写Gradle任务类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html)
  * [编写Gradle插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html)
  * [编写自定义Gradle类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html)
  * [延迟配置任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html)
  * [使用避免任务配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/task_configuration_avoidance.html)

### 参考

  * [核心插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugin_reference.html)
  * [命令行界面](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/command_line_interface.html)
  * [Gradle和第三方工具](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/third_party_integration.html)
  * [摇篮包装](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_wrapper.html)
  * [Gradle管理的目录](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/directory_layout.html)

# 转换解决方案上的依赖工件

version 6.7.1

内容

  * [工件转换的选择和执行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#artifact_transform_selection_and_execution)
  * [实现工件转换](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#sec:implementing-artifact-transforms)
  * [注册工件转换](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#registering_artifact_transforms)
  * [实现增量工件转换](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#implementing_incremental_artifact_transforms)

如在[不同类型的配置中所述](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html#sec:resolvable-
consumable-configs)，对于相同的依赖项可能会有不同的变体。例如，外部Maven依赖项具有针对依赖项（`java-
api`）进行编译时应使用的变体，以及用于运行使用依赖项（`java-
runtime`）的应用程序的变体。项目依赖项甚至具有更多的变体，例如，用于编译的项目类可作为类目录（`org.gradle.usage=java-api,
org.gradle.libraryelements=classes`）或JAR（`org.gradle.usage=java-api,
org.gradle.libraryelements=jar`）获得。

依赖项的变体在其传递性依赖项或工件本身中可能有所不同。例如，Maven依赖项的`java-api`和`java-
runtime`变体仅在传递性依赖项上有所不同，并且都使用相同的工件-JAR文件。对于项目依赖项，`java-api,classes`和`java-
api,jars`变量具有相同的传递依赖项和不同的工件—分别是类目录和JAR文件。

Gradle通过其[属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:abm_configuration_attributes)集唯一地标识依赖项的变体。的`java-
api`依赖关系的变体是由所识别的所述变体`org.gradle.usage`与值属性`java-api`。

当Gradle解析配置时，解析的配置上的[属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:abm_configuration_attributes)将确定
_请求的属性_ 。对于配置中的所有依赖关系，在解析配置时都会选择具有请求属性的变量。例如，当配置请求`org.gradle.usage=java-api,
org.gradle.libraryelements=classes`项目依赖项时，则将classes目录选择为工件。

如果依赖项没有具有所请求属性的变量，则解析配置失败。有时可以在不更改传递依赖项的情况下将依赖项的工件转换为请求的变体。例如，解压缩JAR会将`java-
api,jars`变体的工件转换为`java-api,classes`变体。这种转换称为“ _伪影转换”_
。Gradle允许注册工件转换，并且当依赖项没有所请求的变体时，Gradle将尝试查找一系列工件转换以创建变体。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#artifact_transform_selection_and_execution)[工件转换的选择和执行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#artifact_transform_selection_and_execution)

如上所述，当Gradle解析配置并且该配置中的依赖项不具有带有请求属性的变体时，Gradle会尝试查找一系列工件转换以创建变体。查找伪影变换的匹配链的过程称为
_伪影变换选择_ 。每个注册的转换都从一组属性转换为一组属性。例如，解压缩转换可以从转换`org.gradle.usage=java-api,
org.gradle.libraryelements=jars`为`org.gradle.usage=java-api,
org.gradle.libraryelements=classes`。

为了找到一条链，Gradle从请求的属性开始，然后将所有修改某些请求的属性的转换视为通向那里的可能路径。倒退，Gradle尝试使用转换获取到某些现有变体的路径。

例如，考虑一个`minified`具有两个值的属性：`true`和`false`。minified属性表示依赖项的变体，其中删除了不必要的类文件。注册了一个伪像转换，它可以`minified`从转换`false`为`true`。当`minified=true`要求提供依赖项时，并且只有带有的变体`minified=false`，然后Gradle选择注册的缩小变换。该缩小变换是能够与改造依赖的神器`minified=false`与神器`minified=true`。

在找到的所有变换链中，Gradle尝试选择最佳的变换链：

  * 如果只有一个转换链，则选择它。

  * 如果有两个变换链，并且一个是另一个的后缀，则将其选中。

  * 如果存在最短的变换链，则将其选中。

  * 在所有其他情况下，选择将失败并报告错误。

__ |

当已经存在与请求属性匹配的依赖项变体时，Gradle不会尝试选择工件转换。  
  
---|---  
  
__ |

该`artifactType`属性是特殊的，因为它仅存在于已解析的工件上，而不存在于依赖项上。结果，`artifactType`当仅使用`artifactType`所请求属性解析配置时，将永远不会选择仅变异的任何变换。仅在使用[ArtifactView](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/ArtifactView.html)时才考虑使用。  
  
---|---  
  
选择所需的工件变换后，Gradle会解析链中初始变换所需的依赖项变体。通过下载外部依赖项或执行生成工件的任务，Gradle完成解析变体的工件后，Gradle便开始使用选定的工件转换链来转换变体的工件。Gradle在可能的情况下并行执行变换链。

拿起上面的minify示例，考虑具有两个依赖项的配置，外部`guava`依赖项和项目的项目依赖项`producer`。该配置具有属性`org.gradle.usage=java-
runtime,org.gradle.libraryelements=jar,minified=true`。外部`guava`依赖项有两个变体：

  * `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false` 和

  * `org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false`。

使用缩小变换，摇篮可以转换的变型`org.gradle.usage=java-
runtime,org.gradle.libraryelements=jar,minified=false`的`guava`到`org.gradle.usage=java-
runtime,org.gradle.libraryelements=jar,minified=true`，这是请求的属性。项目依赖项还具有变体：

  * `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false`，

  * `org.gradle.usage=java-runtime,org.gradle.libraryelements=classes,minified=false`，

  * `org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false`，

  * `org.gradle.usage=java-api,org.gradle.libraryelements=classes,minified=false`

  * 还有一些。

同样，使用minify变换，Gradle可以将`org.gradle.usage=java-
runtime,org.gradle.libraryelements=jar,minified=false`项目的变体转换`producer`为`org.gradle.usage=java-
runtime,org.gradle.libraryelements=jar,minified=true`，这是请求的属性。

解决配置问题后，Gradle需要下载`guava`JAR并将其缩小。Gradle还需要执行`producer:jar`任务以生成项目的JAR工件，然后将其最小化。事件的下载和最小化与任务`guava.jar`的执行`producer:jar`和结果JAR的最小化同时进行。

这是设置`minified`属性的方法，以便上面的方法起作用。您需要在模式中注册新属性，将其添加到所有JAR工件中，并在所有可解析配置中请求它。

例子1.工件转换属性设置

`Groovy``Kotlin`

build.gradle

    
    
    def artifactType = Attribute.of('artifactType', String)
    def minified = Attribute.of('minified', Boolean)
    dependencies {
        attributesSchema {
            attribute(minified)                      __**( 1)**
        }
        artifactTypes.getByName("jar") {
            attributes.attribute(minified, false)    __**( 2)**
        }
    }
    
    configurations.all {
        afterEvaluate {
            if (canBeResolved) {
                attributes.attribute(minified, true) __**( 3)**
            }
        }
    }
    
    dependencies {
        registerTransform(Minify) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
        }
    }
    
    dependencies {                                 __**( 4)**
        implementation('com.google.guava:guava:27.1-jre')
        implementation(project(':producer'))
    }

build.gradle.kts

    
    
    val artifactType = Attribute.of("artifactType", String::class.java)
    val minified = Attribute.of("minified", Boolean::class.javaObjectType)
    dependencies {
        attributesSchema {
            attribute(minified)                      __**( 1)**
        }
        artifactTypes.getByName("jar") {
            attributes.attribute(minified, false)    __**( 2)**
        }
    }
    
    configurations.all {
        afterEvaluate {
            if (isCanBeResolved) {
                attributes.attribute(minified, true) __**( 3)**
            }
        }
    }
    
    dependencies {
        registerTransform(Minify::class) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
        }
    }
    
    dependencies {                                 __**( 4)**
        implementation("com.google.guava:guava:27.1-jre")
        implementation(project(":producer"))
    }

__**1** | 将属性添加到架构  
---|---  
__**2** | 所有JAR文件未压缩  
__**3** | 请求`minified=true`所有可解析的配置  
__**4** | 添加将要转换的依赖项  
  
现在，您可以看到当我们运行`resolveRuntimeClasspath`解析`runtimeClasspath`配置的任务时会发生什么。观察到Gradle在`resolveRuntimeClasspath`任务开始之前会转换项目依赖关系。Gradle执行`resolveRuntimeClasspath`任务时会转换二进制依赖关系。

解决runtimeClasspath配置时的输出

    
    
    > gradle resolveRuntimeClasspath
    
    >任务：producer：compileJava
    >任务：producer：processResources NO-SOURCE
    >任务：生产者：类
    >任务：producer：jar
    
    >使用Minify转换producer.jar（project：producer）
    没什么可缩小的-使用producer.jar不变
    
    >任务：resolveRuntimeClasspath
    缩小番石榴27.1-jre.jar
    没什么可减少的-使用listenablefuture-9999.0-empty-to-以避免冲突与guava.jar保持不变
    没什么可缩小的-使用jsr305-3.0.2.jar不变
    没什么好用的-使用checker-qual-2.5.2.jar不变
    没什么可缩小的-使用error_prone_annotations-2.2.0.jar不变
    没什么可缩小的-不变地使用j2objc-annotations-1.1.jar
    没什么可减少的-使用animal-sniffer-annotations-1.17.jar不变
    没什么可缩小的-使用failureaccess-1.0.1.jar不变
    
    在0秒内成功建立
    3个可执行的任务：3个已执行

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#sec:implementing-
artifact-
transforms)[实现工件转换](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#sec:implementing-
artifact-transforms)

与任务类型相似，工件转换由一个动作和一些参数组成。与自定义任务类型的主要区别在于，操作和参数被实现为两个单独的类。

工件转换动作的实现是实现[TransformAction](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.artifacts.transform.TransformAction.html)的类。您需要`transform()`在action上实现该方法，该方法将输入工件转换为零，一个或多个输出工件。大多数伪像转换将是一对一的，因此transform方法会将输入伪像转换为恰好一个输出伪像。

工件转换动作的实现需要通过调用[TransformOutputs.dir（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:dir\(java.lang.Object\))或[TransformOutputs.file（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:file\(java.lang.Object\))来注册每个输出工件
。

您只能提供`dir`或`file`方法的两种类型的路径：

  * 输入工件或输入工件中（输入目录）的绝对路径。

  * 相对路径。

Gradle使用绝对路径作为输出工件的位置。例如，如果输入工件是爆炸的WAR，则transform操作可以调用`TransformOutputs.file()`目录中的所有jar文件`WEB-
INF/lib`。转换的输出将是Web应用程序的库JAR。

对于相对路径，`dir()`or`file()`方法将工作空间返回到transform操作。转换动作的实现需要在提供的工作空间的位置处创建转换后的工件。

输出工件按注册的顺序替换了转换后的变体中的输入工件。例如，如果该配置包括伪影`lib1.jar`，`lib2.jar`，`lib3.jar`，和变换动作寄存器一个缩小的输出伪像`<artifact-
name>-min.jar`的伪像输入，然后转化配置由伪影`lib1-min.jar`，`lib2-min.jar`和`lib3-min.jar`。

这是一个`Unzip`转换的实现，该转换通过解压缩JAR文件将其转换为类目录。该`Unzip`转换不需要任何参数。注意实现如何`@InputArtifact`用于注入工件以转换为动作。它使用来请求`TransformOutputs.dir()`解压缩类的目录，然后将JAR文件解压缩到该目录中。

例子2.没有参数的工件转换

`Groovy``Kotlin`

build.gradle

    
    
    abstract class Unzip implements TransformAction<TransformParameters.None> { __**( 1)**
        @InputArtifact                                                          __**( 2)**
        abstract Provider<FileSystemLocation> getInputArtifact()
    
        @Override
        void transform(TransformOutputs outputs) {
            def input = inputArtifact.get().asFile
            def unzipDir = outputs.dir(input.name)                              __**( 3)**
            unzipTo(input, unzipDir)                                            __**( 4)**
        }
    
        private static void unzipTo(File zipFile, File unzipDir) {
            // implementation...
        }
    }

build.gradle.kts

    
    
    abstract class Unzip : TransformAction<TransformParameters.None> {          __**( 1)**
        @get:InputArtifact                                                      __**( 2)**
        abstract val inputArtifact: Provider<FileSystemLocation>
    
        override
        fun transform(outputs: TransformOutputs) {
            val input = inputArtifact.get().asFile
            val unzipDir = outputs.dir(input.name)                              __**( 3)**
            unzipTo(input, unzipDir)                                            __**( 4)**
        }
    
        private fun unzipTo(zipFile: File, unzipDir: File) {
            // implementation...
        }
    }

__**1** | 使用`TransformParameters.None`如果转换不使用参数  
---|---  
__**2** | 注入输入工件  
__**3** | 请求解压缩文件的输出位置  
__**4** | 做转换的实际工作  
  
伪像变换可能需要参数，例如`String`确定某些过滤器或某些文件集合，这些参数用于支持输入伪像的转换。为了将这些参数传递给转换动作，您需要使用所需参数定义一个新类型。该类型需要实现标记接口[TransformParameters](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/TransformParameters.html)。必须使用[托管属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#managed_properties)来表示参数，并且参数类型必须是[托管类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#managed_types)。您可以使用接口或抽象类声明getter，然后Gradle将生成实现。所有吸气剂都需要具有正确的输入注释，请参阅“[增量构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html#table:incremental_build_annotations)”部分中的表。

您可以在[开发自定义Gradle类型中](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#custom_gradle_types)找到有关实现工件转换参数的更多信息。

这是`Minify`通过仅保留某些类来使JAR变小的转换的实现。该`Minify`变换需要的类，以保持作为参数。观察如何通过获取参数`TransformAction.getParameters()`的`transform()`方法。该`transform()`方法的实现通过使用来请求缩小的JAR的位置`TransformOutputs.file()`，然后在该位置创建缩小的JAR。

例子3.缩小转换实现

`Groovy``Kotlin`

build.gradle

    
    
    abstract class Minify implements TransformAction<Parameters> { __**( 1)**
        interface Parameters extends TransformParameters {         __**( 2)**
            @Input
            Map<String, Set<String>> getKeepClassesByArtifact()
            void setKeepClassesByArtifact(Map<String, Set<String>> keepClasses)
        }
    
        @PathSensitive(PathSensitivity.NAME_ONLY)
        @InputArtifact
        abstract Provider<FileSystemLocation> getInputArtifact()
    
        @Override
        void transform(TransformOutputs outputs) {
            def fileName = inputArtifact.get().asFile.name
            for (entry in parameters.keepClassesByArtifact) {      __**( 3)**
                if (fileName.startsWith(entry.key)) {
                    def nameWithoutExtension = fileName.substring(0, fileName.length() - 4)
                    minify(inputArtifact.get().asFile, entry.value, outputs.file("${nameWithoutExtension}-min.jar"))
                    return
                }
            }
            println "Nothing to minify - using ${fileName} unchanged"
            outputs.file(inputArtifact)                            __**( 4)**
        }
    
        private void minify(File artifact, Set<String> keepClasses, File jarFile) {
            println "Minifying ${artifact.name}"
            // Implementation ...
        }
    }

build.gradle.kts

    
    
    abstract class Minify : TransformAction<Minify.Parameters> {   __**( 1)**
        interface Parameters : TransformParameters {               __**( 2)**
            @get:Input
            var keepClassesByArtifact: Map<String, Set<String>>
    
        }
    
        @get:PathSensitive(PathSensitivity.NAME_ONLY)
        @get:InputArtifact
        abstract val inputArtifact: Provider<FileSystemLocation>
    
        override
        fun transform(outputs: TransformOutputs) {
            val fileName = inputArtifact.get().asFile.name
            for (entry in parameters.keepClassesByArtifact) {      __**( 3)**
                if (fileName.startsWith(entry.key)) {
                    val nameWithoutExtension = fileName.substring(0, fileName.length - 4)
                    minify(inputArtifact.get().asFile, entry.value, outputs.file("${nameWithoutExtension}-min.jar"))
                    return
                }
            }
            println("Nothing to minify - using ${fileName} unchanged")
            outputs.file(inputArtifact)                            __**( 4)**
        }
    
        private fun minify(artifact: File, keepClasses: Set<String>, jarFile: File) {
            println("Minifying ${artifact.name}")
            // Implementation ...
        }
    }

__**1** | 声明参数类型  
---|---  
__**2** | 转换参数的接口  
__**3** | 使用参数  
__**4** | 不需要缩小时使用不变的输入工件  
  
请记住，输入工件是一个依赖项，它可能具有自己的依赖项。如果您的工件转换需要访问那些传递性依赖项，则可以声明一个抽象getter返回a
`FileCollection`，并使用[@InputArtifactDependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html)对其进行[注释](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html)。运行转换时，Gradle将`FileCollection`通过实现getter将可传递依赖项注入该属性。请注意，在转换中使用输入工件依赖项会影响性能，只有在确实需要它们时才注入它们。

此外，工件转换可以将[构建缓存](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_cache.html#build_cache)用于其输出。要为工件转换启用构建缓存，请在操作类上添加注释。对于可缓存的转换，必须使用规范化注释（例如[@PathSensitive）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/PathSensitive.html)注释其[@InputArtifact](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/InputArtifact.html)属性（以及标有[@InputArtifactDependencies的](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html)任何属性）。`@[CacheableTransform](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/CacheableTransform.html)`[](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/InputArtifact.html)[](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html)[](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/tasks/PathSensitive.html)

下面的示例显示一个更复杂的转换。它将JAR的某些选定类移动到不同的包，并使用移动的类重写类和所有类的字节码（类重定位）。为了确定要重定位的类，它查看输入工件的包和输入工件的依赖项。它还不会在外部类路径中重新放置JAR文件中包含的包。

例子4.用于类重定位的工件转换

`Groovy``Kotlin`

build.gradle

    
    
    @CacheableTransform                                                          __**( 1)**
    abstract class ClassRelocator implements TransformAction<Parameters> {
        interface Parameters extends TransformParameters {                       __**( 2)**
            @CompileClasspath                                                    __**( 3)**
            ConfigurableFileCollection getExternalClasspath()
            @Input
            Property<String> getExcludedPackage()
        }
    
        @Classpath                                                               __**( 4)**
        @InputArtifact
        abstract Provider<FileSystemLocation> getPrimaryInput()
    
        @CompileClasspath
        @InputArtifactDependencies                                               __**( 5)**
        abstract FileCollection getDependencies()
    
        @Override
        void transform(TransformOutputs outputs) {
            def primaryInputFile = primaryInput.get().asFile
            if (parameters.externalClasspath.contains(primaryInput)) {           __**( 6)**
                outputs.file(primaryInput)
            } else {
                def baseName = primaryInputFile.name.substring(0, primaryInputFile.name.length - 4)
                relocateJar(outputs.file("$baseName-relocated.jar"))
            }
        }
    
        private relocateJar(File output) {
            // implementation...
            def relocatedPackages = (dependencies.collectMany { readPackages(it) } + readPackages(primaryInput.get().asFile)) as Set
            def nonRelocatedPackages = parameters.externalClasspath.collectMany { readPackages(it) }
            def relocations = (relocatedPackages - nonRelocatedPackages).collect { packageName ->
                def toPackage = "relocated.$packageName"
                println("$packageName -> $toPackage")
                new Relocation(packageName, toPackage)
            }
            new JarRelocator(primaryInput.get().asFile, output, relocations).run()
        }
    }

build.gradle.kts

    
    
    @CacheableTransform                                                          __**( 1)**
    abstract class ClassRelocator : TransformAction<ClassRelocator.Parameters> {
        interface Parameters : TransformParameters {                             __**( 2)**
            @get:CompileClasspath                                                __**( 3)**
            val externalClasspath: ConfigurableFileCollection
            @get:Input
            val excludedPackage: Property<String>
        }
    
        @get:Classpath                                                           __**( 4)**
        @get:InputArtifact
        abstract val primaryInput: Provider<FileSystemLocation>
    
        @get:CompileClasspath
        @get:InputArtifactDependencies                                           __**( 5)**
        abstract val dependencies: FileCollection
    
        override
        fun transform(outputs: TransformOutputs) {
            val primaryInputFile = primaryInput.get().asFile
            if (parameters.externalClasspath.contains(primaryInputFile)) {       __**( 6)**
                outputs.file(primaryInput)
            } else {
                val baseName = primaryInputFile.name.substring(0, primaryInputFile.name.length - 4)
                relocateJar(outputs.file("$baseName-relocated.jar"))
            }
        }
    
        private fun relocateJar(output: File) {
            // implementation...
            val relocatedPackages = (dependencies.flatMap { it.readPackages() } + primaryInput.get().asFile.readPackages()).toSet()
            val nonRelocatedPackages = parameters.externalClasspath.flatMap { it.readPackages() }
            val relocations = (relocatedPackages - nonRelocatedPackages).map { packageName ->
                val toPackage = "relocated.$packageName"
                println("$packageName -> $toPackage")
                Relocation(packageName, toPackage)
            }
            JarRelocator(primaryInput.get().asFile, output, relocations).run()
        }
    }

__**1** | 声明可缓存的转换  
---|---  
__**2** | 转换参数的接口  
__**3** | 声明每个参数的输入类型  
__**4** | 声明输入工件的规范化  
__**5** | 注入输入工件依赖项  
__**6** | 使用参数  
  
##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#registering_artifact_transforms)[注册工件转换](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#registering_artifact_transforms)

您需要注册工件转换动作，并在必要时提供参数，以便在解析依赖项时可以选择它们。

为了注册工件转换，必须在块内使用[registerTransform（）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:registerTransform\(java.lang.Class,%20org.gradle.api.Action\))`dependencies
{}`。

使用时需要注意以下几点`registerTransform()`：

  * 将`from`和`to`属性是必需的。

  * 转换动作本身可以具有配置选项。您可以使用`parameters {}`块组态它们。

  * 您必须在具有将要解决的配置的项目上注册转换。

  * 您可以提供任何实现[TransformAction的](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.artifacts.transform.TransformAction.html)类型给该`registerTransform()`方法。

例如，假设您想解压缩一些依赖项并将解压缩的目录和文件放在类路径中。您可以通过注册type的工件转换操作来做到这一点`Unzip`，如下所示：

例子5.没有参数的工件变换配准

`Groovy``Kotlin`

build.gradle

    
    
    def artifactType = Attribute.of('artifactType', String)
    
    dependencies {
        registerTransform(Unzip) {
            from.attribute(artifactType, 'jar')
            to.attribute(artifactType, 'java-classes-directory')
        }
    }

build.gradle.kts

    
    
    val artifactType = Attribute.of("artifactType", String::class.java)
    
    dependencies {
        registerTransform(Unzip::class) {
            from.attribute(artifactType, "jar")
            to.attribute(artifactType, "java-classes-directory")
        }
    }

另一个示例是您想通过仅保留其中的一些`class`文件来缩小JAR 。注意使用该`parameters
{}`块来提供类，以将最小的JAR保留在`Minify`转换中。

例子6.带参数的工件转换配准

`Groovy``Kotlin`

build.gradle

    
    
    def artifactType = Attribute.of('artifactType', String)
    def minified = Attribute.of('minified', Boolean)
    def keepPatterns = [
        "guava": [
            "com.google.common.base.Optional",
            "com.google.common.base.AbstractIterator"
        ] as Set
    ]
    
    
    dependencies {
        registerTransform(Minify) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
    
            parameters {
                keepClassesByArtifact = keepPatterns
            }
        }
    }

build.gradle.kts

    
    
    val artifactType = Attribute.of("artifactType", String::class.java)
    val minified = Attribute.of("minified", Boolean::class.javaObjectType)
    val keepPatterns = mapOf(
        "guava" to setOf(
            "com.google.common.base.Optional",
            "com.google.common.base.AbstractIterator"
        )
    )
    
    
    dependencies {
        registerTransform(Minify::class) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
    
            parameters {
                keepClassesByArtifact = keepPatterns
            }
        }
    }

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#implementing_incremental_artifact_transforms)[实现增量工件转换](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html#implementing_incremental_artifact_transforms)

与[增量任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#incremental_tasks)类似，工件转换可以通过仅处理上次执行后已更改的文件来避免工作。这是通过使用[InputChanges](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html)接口完成的。对于工件转换，只有输入工件是增量输入，因此转换只能查询那里的更改。为了在转换动作中使用[InputChanges](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html)，请将其注入到动作中。有关如何使用[InputChanges的](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.work.InputChanges.html)更多信息，请参见有关[增量任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#incremental_tasks)的相应文档。

这是一个增量转换的示例，它计算Java源文件中的代码行：

例子7.代码计数行的工件转换

`Groovy``Kotlin`

build.gradle

    
    
    abstract class CountLoc implements TransformAction<TransformParameters.None> {
    
        @Inject                                                             __**( 1)**
        abstract InputChanges getInputChanges()
    
        @PathSensitive(PathSensitivity.RELATIVE)
        @InputArtifact
        abstract Provider<FileSystemLocation> getInput()
    
        @Override
        void transform(TransformOutputs outputs) {
            def outputDir = outputs.dir("${input.get().asFile.name}.loc")
            println("Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.incremental}")
            inputChanges.getFileChanges(input).forEach { change ->          __**( 2)**
                def changedFile = change.file
                if (change.fileType != FileType.FILE) {
                    return
                }
                def outputLocation = new File(outputDir, "${change.normalizedPath}.loc")
                switch (change.changeType) {
                    case ADDED:
                    case MODIFIED:
                        println("Processing file ${changedFile.name}")
                        outputLocation.parentFile.mkdirs()
    
                        outputLocation.text = changedFile.readLines().size()
    
                    case REMOVED:
                        println("Removing leftover output file ${outputLocation.name}")
                        outputLocation.delete()
    
                }
            }
        }
    }

build.gradle.kts

    
    
    abstract class CountLoc : TransformAction<TransformParameters.None> {
    
        @get:Inject                                                         __**( 1)**
        abstract val inputChanges: InputChanges
    
        @get:PathSensitive(PathSensitivity.RELATIVE)
        @get:InputArtifact
        abstract val input: Provider<FileSystemLocation>
    
        override
        fun transform(outputs: TransformOutputs) {
            val outputDir = outputs.dir("${input.get().asFile.name}.loc")
            println("Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.isIncremental}")
            inputChanges.getFileChanges(input).forEach { change ->          __**( 2)**
                val changedFile = change.file
                if (change.fileType != FileType.FILE) {
                    return@forEach
                }
                val outputLocation = outputDir.resolve("${change.normalizedPath}.loc")
                when (change.changeType) {
                    ChangeType.ADDED, ChangeType.MODIFIED -> {
    
                        println("Processing file ${changedFile.name}")
                        outputLocation.parentFile.mkdirs()
    
                        outputLocation.writeText(changedFile.readLines().size.toString())
                    }
                    ChangeType.REMOVED -> {
                        println("Removing leftover output file ${outputLocation.name}")
                        outputLocation.delete()
                    }
                }
            }
        }
    }

__**1** | 注入 `InputChanges`  
---|---  
__**2** | 查询输入工件中的更改  
  
**文件**

  * [用户手册](file:///userguide/userguide.html)
  * [DSL参考](file:///dsl/)
  * [发行说明](file:///release-notes.html)
  * [Java文档](file:///javadoc/)

**新闻**

  * [博客](https://blog.gradle.org/)
  * [通讯](https://newsletter.gradle.com/)
  * [推特](https://twitter.com/gradle)
  * [状态页](https://status.gradle.com/)

**产品展示**

  * [构建扫描](https://gradle.com/build-scans/)
  * [构建缓存](https://gradle.com/build-cache/)
  * [企业文件](https://gradle.com/enterprise/resources/)

**得到帮助**

  * [论坛](https://discuss.gradle.org/c/help-discuss)
  * [的GitHub](https://github.com/gradle/)
  * [训练](https://gradle.com/training/)
  * [服务](https://gradle.org/services/)

##### 随时`UP-TO-DATE`关注新功能和新闻

输入您的电子邮件，即表示您同意我们的[条款](https://gradle.com/legal/terms-of-
service/)和[隐私政策](https://gradle.com/legal/privacy/)，包括接收电子邮件。您可以随时取消订阅。

订阅

© [Gradle Inc.](https://gradle.com/) 2020年 版权所有。

[ gradle ](file:///)

[招贤纳士](https://gradle.com/careers/)| [隐私](https://gradle.com/legal/privacy/)|
[服务条款](https://gradle.com/legal/terms-of-service/)|
[联系](https://gradle.org/contact/)

![Google 翻译](./转换解决方案上的依赖工件_files/translate_24dp.png)

# 原文

提供更好的翻译建议

* * *

