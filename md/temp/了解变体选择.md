

[ Gradle ](https://docs.gradle.org/ "Gradle Docs")

用户手册

  * 社区 Open Community Menu

[ 社区之家 ](https://gradle.org/)

[ 社区论坛 ](https://discuss.gradle.org/)

[ 社区插件 ](https://plugins.gradle.org/)

  * [训练](https://gradle.com/training/)
  * 新闻 Open Community Menu

[ 通讯 ](https://newsletter.gradle.com/)

[ 博客 ](https://blog.gradle.org/)

[ 推特 ](https://twitter.com/gradle)

  * [企业](https://gradle.com/)
  * [github](https://github.com/gradle/gradle "GitHub上的Gradle")

  * [文件首页](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.html)
  * [样品](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html)
  * [发行说明](file:///Users/dxs/temp/gradle-6.7.1/docs/release-notes.html)
  * [Gradle API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#gradle-api)
    * [Java文档](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/index.html?overview-summary.html)
    * [Groovy DSL参考](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/index.html)
    * [Groovy DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/kotlin_dsl.html)

### 用户手册

[ PDF格式 ](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.pdf)

  * [什么是Gradle？](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/what_is_gradle.html)
  * [入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/getting_started.html)
  * [安装Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/installation.html)
  * [升级Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#upgrading-gradle)
    * [版本6.X到最新](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_6.html)
    * [版本5.X到6.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_5.html)
    * [版本4.X到5.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_4.html)
    * [Gradle的功能生命周期](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_lifecycle.html)
  * [迁移至Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#migrating-to-gradle)
    * [从Maven](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_maven.html)
    * [来自蚂蚁](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_ant.html)
  * [相容性说明](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/compatibility.html)
  * [对构建进行故障排除](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/troubleshooting.html)

### 运行Gradle构建

  * [自定义执行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#customizing-execution)
    * [Configuring the Build Environment](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_environment.html)
    * [Configuring the Gradle Daemon](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_daemon.html)
    * [Using Initialization Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/init_scripts.html)
  * [执行多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/intro_multi_project_builds.html)
  * [检查Gradle构建](https://scans.gradle.com/)
  * [优化构建时间](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#optimizing-build-performance)
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_cache.html)
    * [Using the Configuration Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/configuration_cache.html)

### 编写Gradle构建

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#learning-the-basics)
    * [Introducing the Basics of Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/tutorial_using_tasks.html)
    * [Working with Tasks](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/writing_build_scripts.html)
    * [Working with Files](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/working_with_files.html)
    * [Using Gradle Plugins](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html)
    * [Understanding the Build Lifecycle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_lifecycle.html)
    * [Working with Logging](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/logging.html)
    * [Avoiding Traps](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/potential_traps.html)
  * [创作多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#authoring-multi-project-builds)
    * [Creating a Basic Multi-Project Build](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_configuration_and_execution.html)
  * [创作可持续建筑](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#authoring-sustainable-builds)
    * [Organizing Build Logic](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html)
    * [Following Best Practices](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/authoring_maintainable_build_scripts.html)
  * [先进技术](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#advanced-techniques)
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/test_kit.html)
    * [Using Ant from Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/ant.html)

### 编写JVM构建

  * [构建Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html)
  * [测试Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html)
  * [Java项目的工具链](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html)
  * [管理依赖关系](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_for_java_projects.html)
  * [JVM插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#jvm-plugins)
    * [Java Library Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)
    * [Java Application Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/application_plugin.html)
    * [Java Platform Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_platform_plugin.html)
    * [Groovy Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html)
    * [Scala Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/scala_plugin.html)

### 编写C ++ / Swift构建

  * [构建C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_cpp_projects.html)
  * [测试C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cpp_testing.html)
  * [建立Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_swift_projects.html)
  * [测试Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/swift_testing.html)

### 使用依赖项

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#learning-the-basics-dependency-management)
    * [What is Dependency Management?](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/core_dependency_management.html)
    * [Declaring Repositories](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html)
    * [Declaring Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_resolution.html)
    * [Verifying dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_verification.html)
  * [声明版本](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#declaring-dependency-versions)
    * [Declaring Versions and Ranges](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/single_versions.html)
    * [Declaring Rich Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/rich_versions.html)
    * [Handling Changing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dynamic_versions.html)
    * [Locking Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_locking.html)
  * [控制翻译](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#controlling-transitive-dependencies)
    * [Upgrading Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_constraints.html)
    * [Downgrading and Excluding](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/platforms.html)
    * [Aligning Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_metadata_rules.html)
    * [Customizing Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_rules.html)
    * [Preventing accidental upgrades](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_strategy_tuning.html)
  * [图书馆的生产和消费形式](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#modeling-features)
    * [声明图书馆的能力](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_capabilities.html)
    * [建模功能变体和可选依赖项](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_variants.html)
    * [了解变体选择](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html)
    * [声明变体属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_attributes.html)
    * [共享项目成果](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cross_project_publications.html)
    * [改造神器](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html)
  * [在多仓库环境中工作](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#multi-repo)
    * [Composing Builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/composite_builds.html)
  * [出版图书馆](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#publishing)
    * [Setting up Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_signing.html)
    * [Customizing Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_customization.html)
    * [Maven Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_maven.html)
    * [Ivy Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html)
  * [术语](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_terminology.html)

### 扩展摇篮

  * [插件开发教程](https://gradle.org/guides/?q=Plugin%20Development)
  * [编写Gradle任务类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html)
  * [编写Gradle插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html)
  * [编写自定义Gradle类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html)
  * [延迟配置任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html)
  * [使用避免任务配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/task_configuration_avoidance.html)

### 参考

  * [核心插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugin_reference.html)
  * [命令行界面](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/command_line_interface.html)
  * [Gradle和第三方工具](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/third_party_integration.html)
  * [摇篮包装](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_wrapper.html)
  * [Gradle管理的目录](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/directory_layout.html)

# 了解变体选择

version 6.7.1

内容

  * [配置和变量属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:abm_configuration_attributes)
  * [可视化变体信息](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-visual)
  * [变体匹配](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-aware-matching)
  * [变体选择错误](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-select-errors)
  * [Mapping from Maven/Ivy to variants](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:mapping-maven-ivy-to-variants)

Gradle’s dependency management engine is known as _variant aware_. In a
traditional dependency management engine like Apache Maven™, dependencies are
bound to components published at GAV coordinates. This means that the set of
transitive dependencies for a component is solely determined by the GAV
coordinates of this component. It doesn’t matter what _artifact_ is actually
resolved, the set of dependencies is _always the same_. In addition, selecting
a different artifact for a component (for example, using the `jdk7` artifact)
is cumbersome as it requires the use of _classifiers_. One issue with this
model is that it cannot guarantee global graph consistency because there are
no common semantics associated with _分类器_
。这意味着没有什么可以阻止在类路径上同时使用单个模块的`jdk7`和`jdk8`版本，因为引擎不知道分类器名称与什么语义相关联。

![组件模型专家](./了解变体选择_files/component-model-maven.png)

图1. Maven组件模型

除了在GAV坐标处发布的 _模块_ 的概念外，Gradle还介绍了此模块的 _变体_
的概念。变体对应于在相同GAV坐标处发布的组件的不同“视图”。在Gradle模型中，工件被附加到 _变量_ 而不是模块。实际上，这意味着不同的 _工件_
可以具有不同的依赖关系集：

![组件模型gradle](./了解变体选择_files/component-model-gradle.png)

图2. Gradle组件模型

这个中间级别将工件和依赖项与变量关联，而不是直接与组件相关联，使Gradle可以正确地建模每个工件的用途。

但是，这引发了有关如何选择变体的问题：当存在多个变体时，Gradle如何知道要选择哪个变体？实际上，由于使用了[属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_attributes.html)，因此选择了变体，这些[属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_attributes.html)为变体提供了语义，并有助于引擎获得
_一致的解析结果_ 。

由于历史原因，Gradle区分两种组件：

  * 从源构建的本地组件，其[变体映射到传出配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:abm_configuration_attributes)

  * 外部组件，在存储库上发布，在这种情况下，该模块要么通过Gradle Module Metadata发布，并且本机支持变体，要么该模块使用Ivy / Maven元数据，而[变体则从元数据派生](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:mapping-maven-ivy-to-variants)。

在这两种情况下，Gradle都会执行 _变体感知选择_ 。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:abm_configuration_attributes)[配置和变量属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:abm_configuration_attributes)

本地组件将变体作为 _传出配置_
公开，这是[消耗性配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html#sec:resolvable-
consumable-configs)。发生依赖关系解决方案时，引擎将通过选择其 _消耗品配置_ 之一来选择输出组件的一种变体。

__ |

此规则有2个明显的例外：

  * 只要制作者 _不_ 暴露任何消耗品配置

  * 每当使用者 _明确选择目标配置时_

在这种情况下， _绕过变体感知分辨率_ 。  
  
---|---  
  
在 _可解析配置_ （也称为 _使用者_ ）和 _消耗性配置_ （在 _生产者_
）上都使用属性。将属性添加到其他类型的配置中根本没有效果，因为属性不会在配置之间继承。

依赖解析引擎的作用是寻找合适的 _变种_ a的 _生产商_ 给定一个表示的约束 _消费者_ 。

这就是属性发挥作用的地方：它们的作用是执行组件的正确 _变体_ 的选择。

__ |

变体与配置

对于外部组件，术语是使用“ _变体_ ”一词，而不是“ _配置_ ”一词。配置是变体的超集。

这意味着外部组件提供了 _variants_ ，它们也具有属性。但是，有时由于历史原因或由于您使用也具有这种 _配置_ 概念的Ivy，术语“ _配置”_
可能会泄漏到DSL中。 __  
  
---|---  
  
##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
visual)[可视化变体信息](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
visual)

Gradle提供了一个名为Report的报告任务`outgoingVariants`，该任务显示项目的变体及其功能，属性和工件。从概念上讲，它类似于`dependencyInsight`
[报告任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/viewing_debugging_dependencies.html#sec:identifying_reason_dependency_selection)。

默认情况下，`outgoingVariants`打印有关所有变体的信息。它提供了可选参数`--variant
<variantName>`以选择要显示的单个变体。它还接受该`--all`标志以包含有关旧配置和不建议使用的配置的信息。

这是`outgoingVariants`新生成的`java-library`项目上的任务输出：

    
    
    >任务：待发变量
    --------------------------------------------------
    变体apiElements
    --------------------------------------------------
    描述= main的API元素。
    
    能力
        -[默认功能]
    属性
        -org.gradle.category =库
        -org.gradle.dependency.bundling =外部
        -org.gradle.jvm.version = 8
        -org.gradle.libraryelements = jar
        -org.gradle.usage = java-api
    
    伪像
        -build / libs / variant-report.jar（artifactType = jar）
    
    次要变体（*）
        -变体：类
           -属性
              -org.gradle.category =库
              -org.gradle.dependency.bundling =外部
              -org.gradle.jvm.version = 8
              -org.gradle.libraryelements =类
              -org.gradle.usage = java-api
           -文物
              -build / classes / java / main（artifactType = java-classes-directory）
    
    --------------------------------------------------
    变体runtime元素
    --------------------------------------------------
    描述= main的运行时元素。
    
    能力
        -[默认功能]
    属性
        -org.gradle.category =库
        -org.gradle.dependency.bundling =外部
        -org.gradle.jvm.version = 8
        -org.gradle.libraryelements = jar
        -org.gradle.usage = Java运行时
    
    伪像
        -build / libs / variant-report.jar（artifactType = jar）
    
    次要变体（*）
        -变体：类
           -属性
              -org.gradle.category =库
              -org.gradle.dependency.bundling =外部
              -org.gradle.jvm.version = 8
              -org.gradle.libraryelements =类
              -org.gradle.usage = Java运行时
           -文物
              -build / classes / java / main（artifactType = java-classes-directory）
        -变体：资源
           -属性
              -org.gradle.category =库
              -org.gradle.dependency.bundling =外部
              -org.gradle.jvm.version = 8
              -org.gradle.libraryelements =资源
              -org.gradle.usage = Java运行时
           -文物
              -构建/资源/主（artifactType = java-resources-directory）
    
    
    （*）次要变体是通过Configuration＃getOutgoing（）：ConfigurationPublications API创建的变体，除了配置本身之外，它们还参与选择。

从中可以看到java库`apiElements`和公开的两个主要变体`runtimeElements`。请注意，主要区别在于`org.gradle.usage`属性上的值`java-
api`和`java-runtime`。正如他们所指出的，这就是消费者的 _编译_ 类路径上需要的内容与 _运行时_ 类路径上需要的内容之间的区别。

它还显示了 _次级_
变体，这些变体是Gradle项目专有的，未发布。例如，`classes`from的第二个变体`apiElements`是让Gradle在针对[`java-
library`project进行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html#sec:java_library_classes_usage)编译时跳过JAR创建。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
aware-
matching)[变体匹配](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
aware-matching)

让我们以一个`lib`库的示例为例，该库公开了2个变体：其API（通过名为的变体`exposedApi`）和运行时（通过名为的变体`exposedRuntime`）。

__ |

关于生产者变体

此处存在变体 _名称_ ，主要用于调试目的并在错误消息中获得更好的显示。特别是，名称不参与变体的 _ID_ ：只有其属性参与。也就是说，要搜索特定的变体，
_必须_ 依靠其属性 _而不是_ 其名称。

组件可以公开的变体数量没有限制。传统上，一个组件会公开一个API和一个实现，但是例如，我们可能也想公开一个组件的测试装置。也可以为不同的使用者公开
_不同的API_ （考虑一下不同的环境，例如Linux与Windows）。  
  
---|---  
  
消费者需要解释它需要 _什么_ 变体，这是通过在 _消费者_ 上设置 _属性_ 来完成的。 __

属性由 _名称_ 和 _值_
对组成。例如，Gradle带有一个标准名称，该名称`org.gradle.usage`专门用于处理根据使用者的使用情况（编译，运行时...）选择组件的正确变体的概念。但是可以定义任意数量的属性。作为生产者，我们可以通过将`(org.gradle.usage,JAVA_API)`属性附加到变量来表示消耗性配置代表组件的API
。作为使用者，我们可以通过将`(org.gradle.usage,JAVA_API)`属性附加到可解析配置的依赖关系中来表达它。为此，Gradle可以通过查看配置属性来
_自动选择适当的变体_ ：

  * 消费者想要 `org.gradle.usage=JAVA_API`

  * 生产者，`lib`展示了2种不同的变体。一个带`org.gradle.usage=JAVA_API`，另一个带`org.gradle.usage=JAVA_RUNTIME`。

  * Gradle选择`org.gradle.usage=JAVA_API`生产者的变体，因为它 _与消费者属性匹配_

换句话说：属性用于根据属性的值执行选择。

一个更详细的示例涉及多个属性。通常，Gradle中的Java库项目将涉及4个不同的属性，在生产者和消费者方面都可以找到：

  * `org.gradle.usage`，说明变体是组件的API还是其实现

  * `org.gradle.dependency.bundling`，它声明如何捆绑组件的依赖项（例如，如果工件是一个胖子，那么捆绑是`EMBEDDED`）

  * `org.gradle.libraryelements`，用于说明变体包含库的哪些 _部分_ （类，资源或所有内容）

  * `org.gradle.jvm.version`，用于说明此变体针对的 _最低_ Java _版本_

现在，假设我们的库具有两种不同的风格：

  * 一个用于JDK 8

  * 一个用于JDK 9+

在Maven中，这通常是通过生成2种不同的工件（“主”工件和“分类”工件）来实现的。但是，在Maven中，使用者无法表达其需要基于运行时的 _最合适_
版本的库这一事实。

使用Gradle，可以通过让生产者声明两个变体来优雅地解决此问题：

  * 一个`org.gradle.jvm.version=8`， _至少在JDK 8上运行的用户_

  * 一个用`org.gradle.jvm.version=9`，为消费者从JDK 9开始

注意，这两个变体的工件会有所不同，但它们的依存关系 _也可能_ 会有所不同。通常，JDK 8变体可能需要JDK 9+的“反向端口”库才能起作用，只有在JDK
8上运行的使用者才能使用。

在使用者方面， _可解析配置_ 将在上面设置所有四个属性，并且根据运行时将其设置`org.gradle.jvm.version`为8或更多。

__ |

有关变体兼容性的说明

如果消费者设置`org.gradle.jvm.version`为7怎么办？

然后解析将 _失败，_ 并显示一条错误消息，说明生产者没有匹配的变体。这是因为Gradle认识到消费者希望使用Java
7兼容的库，但是生产者可用的Java的 _最低_ 版本是8。如果另一方面，消费者需要 _11_ ，则Gradle知道 _8_ 和 _9_
变体都可以。可以，但是它将选择 _9，_ 因为它是最高兼容版本。  
  
---|---  
  
##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
select-
errors)[变体选择错误](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
select-errors)

在标识组件的正确变体的过程中，两种情况将导致分辨率错误：

  * 生产者的多个变体与消费者属性相匹配，存在变体歧义

  * 生产者的任何变体都不符合消费者的属性

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:variant-
ambiguity)[处理模棱两可的变量选择错误](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:variant-
ambiguity)

模棱两可的变量选择看起来如下所示：

    
    
    >无法解析配置'：compileClasspath'的所有文件。
       >无法解析项目：lib。
         要求：
             项目：ui
          >无法在project的以下变体：lib之间进行选择：
              -feature1ApiElements
              -feature2ApiElements
            它们都符合使用者属性：
              -变体'feature1ApiElements'功能org.test：test-capability：1.0：
                  -不匹配的属性：
                      -找到org.gradle.category'library'，但不是必需的。
                  -兼容的属性：
                      -提供org.gradle.dependency.bundle的'external'
                      -提供org.gradle.jvm.version'11'
                      -必需的org.gradle.libraryelements“类”和发现值“ jar”。
                      -提供org.gradle.usage'java-api'
              -变体'feature2ApiElements'功能org.test：test-capability：1.0：
                  -不匹配的属性：
                      -找到org.gradle.category'library'，但不是必需的。
                  -兼容的属性：
                      -提供org.gradle.dependency.bundle的'external'
                      -提供org.gradle.jvm.version'11'
                      -必需的org.gradle.libraryelements“类”和发现值“ jar”。
                      -提供org.gradle.usage'java-api'

可以看到，显示了所有 _兼容的_ 候选变体及其属性。然后将它们分为两个部分：

  * 首先介绍不匹配的属性，因为它们可能是选择适当变体时缺少的部分。

  * 其次显示兼容的属性，因为它们指示消费者想要什么以及这些变体如何匹配该请求。

不能有任何不匹配的属性，因为那时变体将不是候选者。同样，显示的变体集也排除了已消除歧义的变体。

在上面的示例中，解决方法不在于属性匹配，而在于[功能匹配](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_capability_conflict.html#sub:selecting-
between-
candidates)，该功能显示在变量名称旁边。因为这两个变体有效地提供了相同的属性和功能，所以它们不会被歧义。因此，在这种情况下，此修复程序最有可能在生产者端（`project
:lib`）提供不同的功能，并在消费者端（`project :ui`）表达功能的选择。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:variant-
no-
match)[处理无匹配的变体错误](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:variant-
no-match)

没有匹配的变体错误看起来类似于以下内容：

    
    
    >项目：lib的任何变体均不符合使用者属性：
      -配置'：lib：compile'：
          -不兼容的属性：
              -必需的artifactType“ dll”，并且发现不兼容的值“ jar”。
          -其他兼容属性：
              -提供用法“ api”
      -配置'：lib：compile'变量调试：
          -不兼容的属性：
              -必需的artifactType“ dll”，并且发现不兼容的值“ jar”。
          -其他兼容属性：
              -找到buildType'调试'，但不是必需的。
              -提供用法“ api”
      -配置'：lib：compile'变体版本：
          -不兼容的属性：
              -必需的artifactType“ dll”，并且发现不兼容的值“ jar”。
          -其他兼容属性：
              -找到buildType'release'，但不是必需的。
              -提供用法“ api”

可以看到，显示了 _所有_ 候选变体及其属性。然后将它们分为两个部分：

  * 首先介绍不兼容的属性，因为它们通常是理解为什么无法选择变体的关键。

  * 其次显示其他属性，其中包括 _必需的_ 和 _兼容_ 的属性，以及消费者不要求的所有其他 _生产者_ 属性。

与模棱两可的变量错误类似，目标是了解要选择哪个变量，并查看可以针对使用者调整哪些属性或功能，以实现此目的。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:mapping-
maven-ivy-to-variants)[从Maven /
Ivy映射到变体](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:mapping-
maven-ivy-to-variants)

既不的Maven也不常春藤具有的概念 _的变体_ ，其仅由本机模块摇篮元数据的支持。但是，由于不同的策略，它不会阻止Gradle与他们合作。

__ |

与Gradle模块元数据的关系

Gradle模块元数据是在Maven，Ivy或其他类型的存储库上发布的模块的元数据格式。它类似于`pom.xml`或`ivy.xml`文件，但是这种格式可以
_识别变体_ 。这意味着，如果您的项目产生其他变体，则这些变体将作为模块元数据的一部分提供并发布，从而极大地改善用户体验。

有关更多信息，请参见[Gradle模块元数据规范](https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-
module-metadata-latest-specification.md)。  
  
---|---  
  
###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:maven-
mapping-to-
variants)[将POM文件映射到变体](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:maven-
mapping-to-variants)

在Maven存储库中发布的模块将转换为可识别变体的模块。Maven模块的特殊之处在于，无法知道发布了哪种组件。特别是，无法在代表 _平台_
的BOM和用作超级POM的BOM之间进行区分。有时，POM文件甚至有可能同时充当平台 _和_ 库。

因此，Maven模块分为6个不同的变体，使Gradle用户可以准确地解释它们所依赖的内容：

  * 2个“库”变体（属性`org.gradle.category`= `library`）

    * 该`compile`变种映射的`<scope>compile</scope>`依赖关系。此变体等效于[Java库插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)的`apiElements`变体。此范围的所有依赖项均被视为 _API依赖项_ 。[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html) __

    * 该`runtime`变种都映射在`<scope>compile</scope>`和`<scope>runtime</scope>`依赖性。此变体等效于[Java库插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)的`runtimeElements`变体。这些作用域的所有依赖关系都被视为 _运行时依赖关系_ 。[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html) __

      * 在两种情况下，`<dependencyManagement>`依赖关系都 _不会转换为约束_

  * 从该`<dependencyManagement>`块派生的4个“平台”变体（属性`org.gradle.category`= `platform`）：

    * 该`platform-compile`变量将`<scope>compile</scope>`依赖管理依赖映射 为 _依赖约束_ 。

    * 该`platform-runtime`变体将`<scope>compile</scope>`和`<scope>runtime</scope>`依赖管理依赖都映射为 _依赖约束_ 。

    * 在`enforced-platform-compile`类似于`platform-compile`但所有的约束 _强制_

    * 在`enforced-platform-runtime`类似于`platform-runtime`但所有的约束 _强制_

通过查看手册的“[导入BOM表”](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/platforms.html#sub:bom_import)部分，您可以了解有关平台和强制平台变体用法的更多信息。默认情况下，每当您声明对Maven模块的依赖关系时，Gradle都会查找`library`变体。但是，使用`platform`or`enforcedPlatform`关键字，Gradle现在正在寻找“平台”变体之一，它允许您从POM文件而不是从依赖关系中导入约束。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:ivy-
mapping-to-
variants)[将常春藤文件映射到变体](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:ivy-
mapping-to-variants)

与[Maven](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sub:maven-
mapping-to-
variants)相反，默认情况下没有为Ivy文件实现派生策略。这样做的原因是，与pom相反，Ivy是一种灵活的格式，允许您发布任意多个自定义 _配置_
。因此，通常在Ivy中没有编译/运行时范围或编译/运行时变体的概念。仅当您使用[Gravy发行版](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html#publishing_ivy)的[ivy-
publish插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html#publishing_ivy)发布ivy文件时，您才能获得与pom文件类似的结构。但是，由于不能保证构建使用的
**所有** 常春藤元数据文件都遵循此模式，因此Gradle无法基于该模式实施派生策略。

但是，如果要为Ivy的 _编译_ 和 _运行时_
变体实现派生策略，则可以使用[组件元数据rule来实现](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_metadata_rules.html#sec:component_metadata_rules)。组件元数据规则API允许您[访问ivy配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_metadata_rules.html#sec:component_metadata_rules_details)并基于它们创建变体。如果您知道您使用的所有ivy模块都已通过Gradle发布，而没有对该`ivy.xml`文件进行进一步的自定义，则可以在构建中添加以下规则：

例子1.派生Ivy元数据的编译和运行时变体

`Groovy``Kotlin`

build.gradle

    
    
    class IvyVariantDerivationRule implements ComponentMetadataRule {
        @Inject ObjectFactory getObjects() { }
    
        void execute(ComponentMetadataContext context) {
            // This filters out any non Ivy module
            if(context.getDescriptor(IvyModuleDescriptor) == null) {
                return
            }
    
            context.details.addVariant("runtimeElements", "default") {
                attributes {
                    attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements, LibraryElements.JAR))
                    attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category, Category.LIBRARY))
                    attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage, Usage.JAVA_RUNTIME))
                }
            }
            context.details.addVariant("apiElements", "compile") {
                attributes {
                    attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements, LibraryElements.JAR))
                    attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category, Category.LIBRARY))
                    attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage, Usage.JAVA_API))
                }
            }
        }
    }
    
    dependencies {
        components { all(IvyVariantDerivationRule) }
    }

build.gradle.kts

    
    
    open class IvyVariantDerivationRule : ComponentMetadataRule {
        @Inject open fun getObjects(): ObjectFactory = throw UnsupportedOperationException()
    
        override fun execute(context: ComponentMetadataContext) {
            // This filters out any non Ivy module
            if(context.getDescriptor(IvyModuleDescriptor::class) == null) {
                return
            }
    
            context.details.addVariant("runtimeElements", "default") {
                attributes {
                    attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements.JAR))
                    attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category.LIBRARY))
                    attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_RUNTIME))
                }
            }
            context.details.addVariant("apiElements", "compile") {
                attributes {
                    attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements.JAR))
                    attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category.LIBRARY))
                    attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_API))
                }
            }
        }
    }
    
    dependencies {
        components { all<IvyVariantDerivationRule>() }
    }

该规则`apiElements`基于每个ivy模块的配置创建一个变量，并基于`compile`配置创建一个变量。对于每个变体，它设置相应的[Java生态系统属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
aware-
matching)。变体的依赖关系和工件来自基础配置。如果不是所有消耗的常春藤模块都遵循此模式，则可以调整规则或仅将规则应用于选定的一组模块。`runtimeElements``default`[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html#sec:variant-
aware-matching)

对于没有体都常春藤模块，摇篮回落到原有配置选择（即摇篮并 _没有_
执行这些模块的变体意识到分辨率）。这意味着将选择`default`配置或在对相应模块的依赖性中显式定义的配置。（请注意，只能从构建脚本或常春藤元数据中进行显式配置选择，应避免选择变体。）

**文件**

  * [用户手册](file:///userguide/userguide.html)
  * [DSL参考](file:///dsl/)
  * [发行说明](file:///release-notes.html)
  * [Java文档](file:///javadoc/)

**新闻**

  * [博客](https://blog.gradle.org/)
  * [通讯](https://newsletter.gradle.com/)
  * [推特](https://twitter.com/gradle)
  * [状态页](https://status.gradle.com/)

**产品展示**

  * [构建扫描](https://gradle.com/build-scans/)
  * [构建缓存](https://gradle.com/build-cache/)
  * [企业文件](https://gradle.com/enterprise/resources/)

**得到帮助**

  * [论坛](https://discuss.gradle.org/c/help-discuss)
  * [的GitHub](https://github.com/gradle/)
  * [训练](https://gradle.com/training/)
  * [服务](https://gradle.org/services/)

##### 随时`UP-TO-DATE`关注新功能和新闻

输入您的电子邮件，即表示您同意我们的[条款](https://gradle.com/legal/terms-of-
service/)和[隐私政策](https://gradle.com/legal/privacy/)，包括接收电子邮件。您可以随时取消订阅。

订阅

© [Gradle Inc.](https://gradle.com/) 2020年 版权所有。

[ gradle ](file:///)

[招贤纳士](https://gradle.com/careers/)| [隐私](https://gradle.com/legal/privacy/)|
[服务条款](https://gradle.com/legal/terms-of-service/)|
[联系](https://gradle.org/contact/)

![Google 翻译](./了解变体选择_files/translate_24dp.png)

# 原文

提供更好的翻译建议

* * *

