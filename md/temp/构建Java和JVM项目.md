

[ Gradle ](https://docs.gradle.org/ "Gradle Docs")

用户手册

  * 社区 Open Community Menu

[ 社区之家 ](https://gradle.org/)

[ 社区论坛 ](https://discuss.gradle.org/)

[ 社区插件 ](https://plugins.gradle.org/)

  * [训练](https://gradle.com/training/)
  * 新闻 Open Community Menu

[ 通讯 ](https://newsletter.gradle.com/)

[ 博客 ](https://blog.gradle.org/)

[ 推特 ](https://twitter.com/gradle)

  * [企业](https://gradle.com/)
  * [github](https://github.com/gradle/gradle "GitHub上的Gradle")

  * [文件首页](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.html)
  * [样品](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html)
  * [发行说明](file:///Users/dxs/temp/gradle-6.7.1/docs/release-notes.html)
  * [Gradle API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#gradle-api)
    * [Java文档](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/index.html?overview-summary.html)
    * [Groovy DSL参考](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/index.html)
    * [Groovy DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/kotlin_dsl.html)

### 用户手册

[ PDF格式 ](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.pdf)

  * [什么是Gradle？](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/what_is_gradle.html)
  * [入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/getting_started.html)
  * [安装Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/installation.html)
  * [升级Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#upgrading-gradle)
    * [版本6.X到最新](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_lifecycle.html)
  * [迁移至Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#migrating-to-gradle)
    * [from Maven](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_maven.html)
    * [from Ant](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_ant.html)
  * [相容性说明](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/compatibility.html)
  * [对构建进行故障排除](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/troubleshooting.html)

### 运行Gradle构建

  * [自定义执行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#customizing-execution)
    * [Configuring the Build Environment](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_environment.html)
    * [Configuring the Gradle Daemon](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_daemon.html)
    * [Using Initialization Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/init_scripts.html)
  * [执行多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/intro_multi_project_builds.html)
  * [检查Gradle构建](https://scans.gradle.com/)
  * [优化构建时间](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#optimizing-build-performance)
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_cache.html)
    * [Using the Configuration Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/configuration_cache.html)

### 编写Gradle构建

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#learning-the-basics)
    * [Introducing the Basics of Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/tutorial_using_tasks.html)
    * [Working with Tasks](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/writing_build_scripts.html)
    * [Working with Files](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/working_with_files.html)
    * [Using Gradle Plugins](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html)
    * [Understanding the Build Lifecycle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_lifecycle.html)
    * [Working with Logging](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/logging.html)
    * [Avoiding Traps](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/potential_traps.html)
  * [创作多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#authoring-multi-project-builds)
    * [Creating a Basic Multi-Project Build](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_configuration_and_execution.html)
  * [创作可持续建筑](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#authoring-sustainable-builds)
    * [Organizing Build Logic](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html)
    * [Following Best Practices](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/authoring_maintainable_build_scripts.html)
  * [先进技术](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#advanced-techniques)
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/test_kit.html)
    * [Using Ant from Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/ant.html)

### 编写JVM构建

  * [构建Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html)
  * [测试Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html)
  * [Java项目的工具链](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html)
  * [管理依赖关系](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_for_java_projects.html)
  * [JVM插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#jvm-plugins)
    * [Java Library Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)
    * [Java Application Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/application_plugin.html)
    * [Java Platform Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_platform_plugin.html)
    * [Groovy Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html)
    * [Scala Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/scala_plugin.html)

### 编写C ++ / Swift构建

  * [构建C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_cpp_projects.html)
  * [测试C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cpp_testing.html)
  * [建立Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_swift_projects.html)
  * [测试Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/swift_testing.html)

### 使用依赖项

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#learning-the-basics-dependency-management)
    * [What is Dependency Management?](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/core_dependency_management.html)
    * [Declaring Repositories](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html)
    * [Declaring Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_resolution.html)
    * [Verifying dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_verification.html)
  * [声明版本](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#declaring-dependency-versions)
    * [Declaring Versions and Ranges](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/single_versions.html)
    * [Declaring Rich Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/rich_versions.html)
    * [Handling Changing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dynamic_versions.html)
    * [Locking Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_locking.html)
  * [控制翻译](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#controlling-transitive-dependencies)
    * [Upgrading Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_constraints.html)
    * [Downgrading and Excluding](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/platforms.html)
    * [Aligning Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_metadata_rules.html)
    * [Customizing Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_rules.html)
    * [Preventing accidental upgrades](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_strategy_tuning.html)
  * [图书馆的生产和消费形式](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#modeling-features)
    * [Declaring Capabilities of a Library](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_variants.html)
    * [Understanding Variant Selection](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html)
    * [Declaring Variant Attributes](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cross_project_publications.html)
    * [Transforming Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html)
  * [在多仓库环境中工作](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#multi-repo)
    * [Composing Builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/composite_builds.html)
  * [出版图书馆](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#publishing)
    * [Setting up Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_signing.html)
    * [Customizing Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_customization.html)
    * [Maven Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_maven.html)
    * [Ivy Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html)
  * [术语](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_terminology.html)

### 扩展摇篮

  * [插件开发教程](https://gradle.org/guides/?q=Plugin%20Development)
  * [编写Gradle任务类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html)
  * [编写Gradle插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html)
  * [编写自定义Gradle类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html)
  * [延迟配置任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html)
  * [使用避免任务配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/task_configuration_avoidance.html)

### 参考

  * [核心插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugin_reference.html)
  * [命令行界面](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/command_line_interface.html)
  * [Gradle和第三方工具](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/third_party_integration.html)
  * [摇篮包装](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_wrapper.html)
  * [Gradle管理的目录](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/directory_layout.html)

# 构建Java和JVM项目

version 6.7.1

内容

  * [介绍](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#introduction)
  * [通过源集声明源文件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_source_sets)
  * [管理你的依赖](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_dependency_management_overview)
  * [编译代码](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:compile)
  * [管理资源](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_resources)
  * [运行测试](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:running_java_tests)
  * [包装出版](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_packaging)
  * [生成API文档](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:generating_javadocs)
  * [清理构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:cleaning_java_build)
  * [构建JVM组件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_jvm_components)
  * [构建Java库](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_libraries)
  * [构建Java应用程序](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_applications)
  * [构建Java Web应用程序](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_webapps)
  * [构建Java EE应用程序](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_enterprise_apps)
  * [构建Java平台](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_platform)
  * [启用Java预览功能](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:feature_preview)
  * [构建其他JVM语言项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_jvm_lang)

Gradle使用基于配置的约定方法来构建基于JVM的项目，该方法借鉴了Apache
Maven的几种约定。特别是，它对源文件和资源使用相同的默认目录结构，并且可与Maven兼容的存储库一起使用。

我们将在本章中详细介绍Java项目，但是大多数主题也适用于其他受支持的JVM语言，例如[Kotlin](https://kotlinlang.org/docs/reference/using-
gradle.html#targeting-the-
jvm)，[Groovy](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html#groovy_plugin)和[Scala](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/scala_plugin.html#scala_plugin)。如果您没有使用Gradle构建基于JVM的项目的丰富经验，请查看[Java示例](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html#java)以获取有关如何构建各种类型的基本Java项目的逐步说明。

__ |

本节中的示例使用Java库插件。但是，所有JVM插件都共享所描述的功能。不同插件的详细信息可在其专用文档中找到。  
  
---|---  
  
__ |

您可以针对[Java](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html#java)，
[Groovy](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html#groovy)，
[Scala](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html#scala)和
[Kotlin](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html#kotlin)探索许多动手样本。
[](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html#kotlin)  
  
---|---  
  
##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#introduction)[介绍](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#introduction)

Java项目的最简单构建脚本将应用[Java库插件，](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)并可以选择设置项目版本并选择要使用的[Java工具链](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html)：

例子1.应用Java库插件

`Groovy``Kotlin`

build.gradle

    
    
    plugins {
        id 'java-library'
    }
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(11)
        }
    }
    
    version = '1.2.1'

build.gradle.kts

    
    
    plugins {
        `java-library`
    }
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(11))
        }
    }
    
    version = "1.2.1"

通过应用Java库插件，您可以获得许多功能：

  * 一`compileJava`，编译下的所有Java源文件任务 _的src / main / JAVA_

  * 一`compileTestJava`对在源文件任务 _的src / test / java下_

  * 一个`test`运行从测试任务 _的src / test / java下_

  * 将来自 _src / main / resources_`jar`的已`main`编译类和资源打包到名为 _< project>-<version> .jar_的单个JAR中的任务 __ __

  * `javadoc`为`main`类生成Javadoc的任务

这还不足以构建任何重要的Java项目-至少，您可能会有一些文件依赖性。但它意味着你的构建脚本只需要特定于信息 _的_ 项目。

__ |

尽管示例中的属性是可选的，但我们建议您在项目中指定它们。工具链选项可防止使用不同Java版本构建的项目出现问题。版本字符串对于跟踪项目的进度很重要。默认情况下，项目版本也用于归档名称中。  
  
---|---  
  
Java库插件还将上述任务集成到标准的[基础插件生命周期任务中](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/base_plugin.html#sec:base_tasks)：

  * `jar`附加到`assemble` [ [1](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#_footnotedef_1 "查看脚注。") ]

  * `test` 连接到 `check`

本章的其余部分介绍了根据需要自定义构建的不同方法。稍后，您还将看到如何调整库，应用程序，Web应用程序和企业应用程序的构建。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_source_sets)[通过源集声明源文件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_source_sets)

Gradle对Java的支持是第一个引入用于构建基于源代码的项目的新概念的方法： _源代码集_
。主要思想是源文件和资源通常按类型进行逻辑分组，例如应用程序代码，单元测试和集成测试。每个逻辑组通常都有其自己的文件依赖项集，类路径等。重要的是，构成源集的文件
_不必位于同一目录中_ ！

源集是一个强大的概念，将编译的几个方面联系在一起：

  * 源文件及其位置

  * 编译类路径，包括任何必需的依赖项（通过Gradle[配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_terminology.html#sub:terminology_configuration)）

  * 放置已编译的类文件的位置

您可以在此图中看到它们之间的相互关系：

![Java SourceSets编译](./构建Java和JVM项目_files/java-sourcesets-compilation.png)

Figure 1. Source sets and Java compilation

The shaded boxes represent properties of the source set itself. On top of
that, the Java Library Plugin automatically creates a compilation task for
every source set you or a plugin defines — named `compile _SourceSet_ Java` —
and several [dependency
configurations](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_plugin.html#java_source_set_configurations).

__ |

The `main` source set

Most language plugins, Java included, automatically create a source set called
`main`, which is used for the project’s production code. This source set is
special in that its name is not included in the names of the configurations
and tasks, hence why you have just a `compileJava` task and `compileOnly` and
`implementation` configurations rather than `compileMainJava`,
`mainCompileOnly` and `mainImplementation` respectively.  
  
---|---  
  
Java projects typically include resources other than source files, such as
properties files, that may need processing — for example by replacing tokens
within the files — and packaging within the final JAR. The Java Library Plugin
handles this by automatically creating a dedicated task for each defined
source set called `process _SourceSet_ Resources` (or `processResources` for
the `main` source set). The following diagram shows how the source set fits in
with this task:

![java资源集处理资源](./构建Java和JVM项目_files/java-sourcesets-process-resources.png)

Figure 2. Processing non-source files for a source set

As before, the shaded boxes represent properties of the source set, which in
this case comprises the locations of the resource files and where they are
copied to.

In addition to the `main` source set, the Java Library Plugin defines a `test`
source set that represents the project’s tests. This source set is used by the
`test` task, which runs the tests. You can learn more about this task and
related topics in the [Java
testing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html#java_testing)
chapter.

Projects typically use this source set for unit tests, but you can also use it
for integration, acceptance and other types of test if you wish. The
alternative approach is to [define a new source
set](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:custom_java_source_sets)
for each of your other test types, which is typically done for one or both of
the following reasons:

  * You want to keep the tests separate from one another for aesthetics and manageability

  * The different test types require different compilation or runtime classpaths or some other difference in setup

You can see an example of this approach in the Java testing chapter, which
shows you [how to set up integration
tests](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html#sec:configuring_java_integration_tests)
in a project.

You’ll learn more about source sets and the features they provide in:

  * [Customizing file and directory locations](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:custom_java_source_set_paths)

  * [Configuring Java integration tests](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html#sec:configuring_java_integration_tests)

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_dependency_management_overview)[Managing
your
dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_dependency_management_overview)

The vast majority of Java projects rely on libraries, so managing a project’s
dependencies is an important part of building a Java project. Dependency
management is a big topic, so we will focus on the basics for Java projects
here. If you’d like to dive into the detail, check out the [introduction to
dependency
management](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/core_dependency_management.html).

Specifying the dependencies for your Java project requires just three pieces
of information:

  * Which dependency you need, such as a name and version

  * What it’s needed for, e.g. compilation or running

  * Where to look for it

The first two are specified in a `dependencies {}` block and the third in a
`repositories {}` block. For example, to tell Gradle that your project
requires version 3.6.7 of [Hibernate](http://hibernate.org/) Core to compile
and run your production code, and that you want to download the library from
the Maven Central repository, you can use the following fragment:

Example 2. Declaring dependencies

`Groovy``Kotlin`

build.gradle

    
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation 'org.hibernate:hibernate-core:3.6.7.Final'
    }

build.gradle.kts

    
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation("org.hibernate:hibernate-core:3.6.7.Final")
    }

The Gradle terminology for the three elements is as follows:

  * _Repository_ (ex: `mavenCentral()`) — where to look for the modules you declare as dependencies

  * _Configuration_ (ex: `implementation`) — a named collection of dependencies, grouped together for a specific goal such as compiling or running a module — a more flexible form of Maven scopes

  * _Module coordinate_ (ex: `org.hibernate:hibernate-core-3.6.7.Final`) — the ID of the dependency, usually in the form ' _< group>_: _< module>_: _< version>_' (or ' _< groupId>_: _< artifactId>_: _< version>_' in Maven terminology)

You can find a more comprehensive glossary of dependency management terms
[here](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_terminology.html).

As far as configurations go, the main ones of interest are:

  * `compileOnly` — for dependencies that are necessary to compile your production code but shouldn’t be part of the runtime classpath

  * `implementation` (supersedes `compile`) — used for compilation and runtime

  * `runtimeOnly` (supersedes `runtime`) — only used at runtime, not for compilation

  * `testCompileOnly` — same as `compileOnly` except it’s for the tests

  * `testImplementation` — test equivalent of `implementation`

  * `testRuntimeOnly` — test equivalent of `runtimeOnly`

You can learn more about these and how they relate to one another in the
[plugin reference
chapter](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_plugin.html#sec:java_plugin_and_dependency_management).

Be aware that the [Java Library
Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html#java_library_plugin)
offers two additional configurations — `api` and `compileOnlyApi` — for
dependencies that are required for compiling both the module and any modules
that depend on it.

__ |

Why no `compile` configuration?

The Java Library Plugin has historically used the `compile` configuration for
dependencies that are required to both compile and run a project’s production
code. It is now deprecated, and will issue warnings when used, because it
doesn’t distinguish between dependencies that impact the public API of a Java
library project and those that don’t. You can learn more about the importance
of this distinction in [Building Java
libraries](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_libraries).  
  
---|---  
  
We have only scratched the surface here, so we recommend that you read the
dedicated dependency management chapters once you’re comfortable with the
basics of building Java projects with Gradle. Some common scenarios that
require further reading include:

  * Defining a custom [Maven-](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html#sec:maven_repo) or [Ivy-compatible](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html#sec:ivy_repositories) repository

  * Using dependencies from a [local filesystem directory](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html#sub:flat_dir_resolver)

  * Declaring dependencies with [changing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dynamic_versions.html#sub:declaring_dependency_with_changing_version) (e.g. SNAPSHOT) and [dynamic](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dynamic_versions.html#sub:declaring_dependency_with_dynamic_version) (range) versions

  * Declaring a sibling [project as a dependency](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html#sub:project_dependencies)

  * [Controlling transitive dependencies and their versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_constraints.html)

  * Testing your fixes to a 3rd-party dependency via [composite builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/composite_builds.html#composite_builds) (a better alternative to publishing to and consuming from [Maven Local](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html#sub:maven_local))

You’ll discover that Gradle has a rich API for working with dependencies — one
that takes time to master, but is straightforward to use for common scenarios.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:compile)[Compiling
your
code](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:compile)

Compiling both your production and test code can be trivially easy if you
follow the conventions:

  1. Put your production source code under the _src/main/java_ directory

  2. Put your test source code under _src/test/java_

  3. Declare your production compile dependencies in the `compileOnly` or `implementation` configurations (see previous section)

  4. Declare your test compile dependencies in the `testCompileOnly` or `testImplementation` configurations

  5. Run the `compileJava` task for the production code and `compileTestJava` for the tests

Other JVM language plugins, such as the one for
[Groovy](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html#groovy_plugin),
follow the same pattern of conventions. We recommend that you follow these
conventions wherever possible, but you don’t have to. There are several
options for customization, as you’ll see next.

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:custom_java_source_set_paths)[Customizing
file and directory
locations](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:custom_java_source_set_paths)

Imagine you have a legacy project that uses an _src_ directory for the
production code and _test_ for the test code. The conventional directory
structure won’t work, so you need to tell Gradle where to find the source
files. You do that via source set configuration.

Each source set defines where its source code resides, along with the
resources and the output directory for the class files. You can override the
convention values by using the following syntax:

Example 3. Declaring custom source directories

`Groovy``Kotlin`

build.gradle

    
    
    sourceSets {
        main {
             java {
                srcDirs = ['src']
             }
        }
    
        test {
            java {
                srcDirs = ['test']
            }
        }
    }

build.gradle.kts

    
    
    sourceSets {
        main {
            java {
                setSrcDirs(listOf("src"))
            }
        }
    
        test {
            java {
                setSrcDirs(listOf("test"))
            }
        }
    }

Now Gradle will only search directly in _src_ and _test_ for the respective
source code. What if you don’t want to override the convention, but simply
want to _add_ an extra source directory, perhaps one that contains some third-
party source code you want to keep separate? The syntax is similar:

Example 4. Declaring custom source directories additively

`Groovy``Kotlin`

build.gradle

    
    
    sourceSets {
        main {
            java {
                srcDir 'thirdParty/src/main/java'
            }
        }
    }

build.gradle.kts

    
    
    sourceSets {
        main {
            java {
                srcDir("thirdParty/src/main/java")
            }
        }
    }

Crucially, we’re using the _method_ `srcDir()` here to append a directory
path, whereas setting the `srcDirs` property replaces any existing values.
This is a common convention in Gradle: setting a property replaces values,
while the corresponding method appends values.

You can see all the properties and methods available on source sets in the DSL
reference for
[SourceSet](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.SourceSet.html)
and
[SourceDirectorySet](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.file.SourceDirectorySet.html).
Note that `srcDirs` and `srcDir()` are both on `SourceDirectorySet`.

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#changing_compiler_options)[Changing
compiler
options](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#changing_compiler_options)

Most of the compiler options are accessible through the corresponding task,
such as `compileJava` and `compileTestJava`. These tasks are of type
[JavaCompile](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.compile.JavaCompile.html),
so read the task reference for an up-to-date and comprehensive list of the
options.

For example, if you want to use a separate JVM process for the compiler and
prevent compilation failures from failing the build, you can use this
configuration:

Example 5. Setting Java compiler options

`Groovy``Kotlin`

build.gradle

    
    
    compileJava {
        options.incremental = true
        options.fork = true
        options.failOnError = false
    }

build.gradle.kts

    
    
    tasks.compileJava {
        options.isIncremental = true
        options.isFork = true
        options.isFailOnError = false
    }

That’s also how you can change the verbosity of the compiler, disable debug
output in the byte code and configure where the compiler can find annotation
processors.

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_cross_compilation)[Targeting
a specific Java
version](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_cross_compilation)

By default, Gradle will compile Java code to the language level of the JVM
running Gradle. With the usage of [Java
toolchains](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html),
you can break that link by making sure a given Java version, defined by the
build, is used for compilation, execution and documentation. It is however
possible to override some compiler and execution options at the task level.

Since version 9, the Java compiler can be configured to produce bytecode for
an older Java version while making sure the code does not use any APIs from a
more recent version. Gradle now supports this
[release](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:release)
flag on `CompileOptions` directly for Java compilation. This option takes
precedence over the properties described below.

Example 6. Setting Java release flag

`Groovy``Kotlin`

build.gradle

    
    
    compileJava {
        options.release = 7
    }

build.gradle.kts

    
    
    tasks.compileJava {
        options.release.set(7)
    }

Historical options for the Java compiler remain available:

`sourceCompatibility`

    

Defines which language version of Java your source files should be treated as.

`targetCompatibility`

    

Defines the minimum JVM version your code should run on, i.e. it determines
the version of byte code the compiler generates.

These options can be set per
[JavaCompile](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.compile.JavaCompile.html)
task, or on the `java { }` extension for all compile tasks, using properties
with the same names.

__ |

Using a toolchain makes it illegal to configure the `sourceCompatibility` or
`targetCompatibility` at the `java { }` extension level.  
  
---|---  
  
However, these options do not protect against the use of APIs introduced in
later Java versions.

####
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#compiling_and_testing_java_67)[Compiling
and testing Java
6/7](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#compiling_and_testing_java_67)

Gradle can only run on Java version 8 or higher. Gradle still supports
compiling, testing, generating Javadoc and executing applications for Java 6
and Java 7. Java 5 and below are not supported.

__ |

If using Java 9+, leveraging the `release` flag might be an easier solution,
see above.  
  
---|---  
  
To use Java 6 or Java 7, the following tasks need to be configured:

  * `JavaCompile` task to fork and use the correct Java home

  * `Javadoc` task to use the correct `javadoc` executable

  * `Test` and the `JavaExec` task to use the correct `java` executable.

With the usage of Java toolchains, this can be done as follows:

####
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#example_configure_java_7_build)[Example:
Configure Java 7
build](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#example_configure_java_7_build)

`Groovy``Kotlin`

build.gradle

    
    
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(7)
        }
    }

build.gradle.kts

    
    
    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(7))
        }
    }

The only requirement is that Java 7 is installed and has to be either in [a
location Gradle can detect
automatically](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html#sec:auto_detection)
or [explicitly
configured](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html#sec:custom_loc).

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:custom_java_source_sets)[Compiling
independent sources
separately](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:custom_java_source_sets)

Most projects have at least two independent sets of sources: the production
code and the test code. Gradle already makes this scenario part of its Java
convention, but what if you have other sets of sources? One of the most common
scenarios is when you have separate integration tests of some form or other.
In that case, a custom source set may be just what you need.

You can see a complete example for setting up integration tests in the [Java
testing
chapter](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html#sec:configuring_java_integration_tests).
You can set up other source sets that fulfil different roles in the same way.
The question then becomes: when should you define a custom source set?

To answer that question, consider whether the sources:

  1. Need to be compiled with a unique classpath

  2. Generate classes that are handled differently from the `main` and `test` ones

  3. Form a natural part of the project

If your answer to both 3 and either one of the others is yes, then a custom
source set is probably the right approach. For example, integration tests are
typically part of the project because they test the code in `main`. In
addition, they often have either their own dependencies independent of the
`test` source set or they need to be run with a custom `Test` task.

Other common scenarios are less clear cut and may have better solutions. For
example:

  * Separate API and implementation JARs — it may make sense to have these as separate projects, particularly if you already have a multi-project build

  * Generated sources — if the resulting sources should be compiled with the production code, add their path(s) to the `main` source set and make sure that the `compileJava` task depends on the task that generates the sources

If you’re unsure whether to create a custom source set or not, then go ahead
and do so. It should be straightforward and if it’s not, then it’s probably
not the right tool for the job.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_resources)[Managing
resources](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_resources)

Many Java projects make use of resources beyond source files, such as images,
configuration files and localization data. Sometimes these files simply need
to be packaged unchanged and sometimes they need to be processed as template
files or in some other way. Either way, the Java Library Plugin adds a
specific
[Copy](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.Copy.html)
task for each source set that handles the processing of its associated
resources.

The task’s name follows the convention of `process _SourceSet_ Resources` — or
`processResources` for the `main` source set — and it will automatically copy
any files in _src/[sourceSet]/resources_ to a directory that will be included
in the production JAR. This target directory will also be included in the
runtime classpath of the tests.

Since `processResources` is an instance of the `Copy` task, you can perform
any of the processing described in the [Working With
Files](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/working_with_files.html#sec:copying_files)
chapter.

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:properties_files)[Java
properties files and reproducible
builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:properties_files)

You can easily create Java properties files via the
[WriteProperties](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.WriteProperties.html)
task, which fixes a well-known problem with `Properties.store()` that can
reduce the usefulness of [incremental
builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html#sec:up_to_date_checks).

The standard Java API for writing properties files produces a unique file
every time, even when the same properties and values are used, because it
includes a timestamp in the comments. Gradle’s `WriteProperties` task
generates exactly the same output byte-for-byte if none of the properties have
changed. This is achieved by a few tweaks to how a properties file is
generated:

  * no timestamp comment is added to the output

  * the line separator is system independent, but can be configured explicitly (it defaults to `'\n'`)

  * the properties are sorted alphabetically

Sometimes it can be desirable to recreate archives in a byte for byte way on
different machines. You want to be sure that building an artifact from source
code produces the same result, byte for byte, no matter when and where it is
built. This is necessary for projects like reproducible-builds.org.

These tweaks not only lead to better incremental build integration, but they
also help with [reproducible builds](https://reproducible-builds.org/). In
essence, reproducible builds guarantee that you will see the same results from
a build execution — including test results and production binaries — no matter
when or on what system you run it.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:running_java_tests)[Running
tests](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:running_java_tests)

Alongside providing automatic compilation of unit tests in _src/test/java_ ,
the Java Library Plugin has native support for running tests that use JUnit 3,
4 & 5 (JUnit 5 support [came in Gradle
4.6](https://docs.gradle.org/4.6/release-notes.html#junit-5-support)) and
TestNG. You get:

  * An automatic `test` task of type [Test](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.testing.Test.html), using the `test` source set

  * An HTML test report that includes the results from _all_ `Test` tasks that run

  * Easy filtering of which tests to run

  * Fine-grained control over how the tests are run

  * The opportunity to create your own test execution and test reporting tasks

You do _not_ get a `Test` task for every source set you declare, since not
every source set represents tests! That’s why you typically need to [create
your own `Test`
tasks](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:custom_java_source_sets)
for things like integration and acceptance tests if they can’t be included
with the `test` source set.

As there is a lot to cover when it comes to testing, the topic has its [own
chapter](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html#java_testing)
in which we look at:

  * How tests are run

  * How to run a subset of tests via filtering

  * How Gradle discovers tests

  * How to configure test reporting and add your own reporting tasks

  * How to make use of specific JUnit and TestNG features

You can also learn more about configuring tests in the DSL reference for
[Test](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.testing.Test.html).

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_packaging)[Packaging
and
publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:java_packaging)

How you package and potentially publish your Java project depends on what type
of project it is. Libraries, applications, web applications and enterprise
applications all have differing requirements. In this section, we will focus
on the bare bones provided by the Java Library Plugin.

By default, the Java Library Plugin provides the `jar` task that packages all
the compiled production classes and resources into a single JAR. This JAR is
also automatically built by the `assemble` task. Furthermore, the plugin can
be configured to provide the `javadocJar` and `sourcesJar` tasks to package
Javadoc and source code if so desired. If a publishing plugin is used, these
tasks will automatically run during publishing or can be called directly.

Example 7. Configure a project to publish Javadoc and sources

`Groovy``Kotlin`

build.gradle

    
    
    java {
        withJavadocJar()
        withSourcesJar()
    }

build.gradle.kts

    
    
    java {
        withJavadocJar()
        withSourcesJar()
    }

如果要创建“超级”（又称“胖”）JAR，则可以使用如下任务定义：

例子8.创建一个Java uber或fat JAR

`Groovy``Kotlin`

build.gradle

    
    
    plugins {
        id 'java'
    }
    
    version = '1.0.0'
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation 'commons-io:commons-io:2.6'
    }
    
    task uberJar(type: Jar) {
        archiveClassifier = 'uber'
    
        from sourceSets.main.output
    
        dependsOn configurations.runtimeClasspath
        from {
            configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }.collect { zipTree(it) }
        }
    }

build.gradle.kts

    
    
    plugins {
        java
    }
    
    version = "1.0.0"
    
    repositories {
        mavenCentral()
    }
    
    dependencies {
        implementation("commons-io:commons-io:2.6")
    }
    
    tasks.register<Jar>("uberJar") {
        archiveClassifier.set("uber")
    
        from(sourceSets.main.get().output)
    
        dependsOn(configurations.runtimeClasspath)
        from({
            configurations.runtimeClasspath.get().filter { it.name.endsWith("jar") }.map { zipTree(it) }
        })
    }

有关可用配置选项的更多详细信息，请参见[Jar](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.bundling.Jar.html)。请注意，您需要使用`archiveClassifier`而不是`archiveAppendix`此处来正确发布JAR。

您可以使用发布插件之一来发布由Java项目创建的JAR：

  * [Maven发布插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_maven.html#publishing_maven)

  * [常春藤发布插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html#publishing_ivy)

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:jar_manifest)[修改JAR清单](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:jar_manifest)

`Jar`，`War`和`Ear`任务的每个实例都有一个`manifest`属性，可让您自定义进入相应归档文件的 _MANIFEST.MF_
文件。下面的示例演示如何在JAR清单中设置属性：

例子9.自定义MANIFEST.MF

`Groovy``Kotlin`

build.gradle

    
    
    jar {
        manifest {
            attributes("Implementation-Title": "Gradle",
                       "Implementation-Version": archiveVersion)
        }
    }

build.gradle.kts

    
    
    tasks.jar {
        manifest {
            attributes(
                "Implementation-Title" to "Gradle",
                "Implementation-Version" to archiveVersion
            )
        }
    }

请参阅[清单](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/java/archives/Manifest.html)以获取其提供的配置选项。

您还可以创建的独立实例`Manifest`。这样做的原因之一是在JAR之间共享清单信息。下面的示例演示如何在JAR之间共享通用属性：

示例10.创建清单对象。

`Groovy``Kotlin`

build.gradle

    
    
    ext.sharedManifest = manifest {
        attributes("Implementation-Title": "Gradle",
                   "Implementation-Version": version)
    }
    task fooJar(type: Jar) {
        manifest = project.manifest {
            from sharedManifest
        }
    }

build.gradle.kts

    
    
    val sharedManifest = the<JavaPluginConvention>().manifest {
        attributes (
            "Implementation-Title" to "Gradle",
            "Implementation-Version" to version
        )
    }
    
    tasks.register<Jar>("fooJar") {
        manifest = project.the<JavaPluginConvention>().manifest {
            from(sharedManifest)
        }
    }

您可以使用的另一种选择是将清单合并到单个`Manifest`对象中。这些源清单可以采用文本形式或其他`Manifest`对象形式。在以下示例中，源清单是除上一个示例中`sharedManifest`的`Manifest`对象之外的所有文本文件：

例子11.单独MANIFEST.MF存放一个特定的档案

`Groovy``Kotlin`

build.gradle

    
    
    task barJar(type: Jar) {
        manifest {
            attributes key1: 'value1'
            from sharedManifest, 'src/config/basemanifest.txt'
            from(['src/config/javabasemanifest.txt', 'src/config/libbasemanifest.txt']) {
                eachEntry { details ->
                    if (details.baseValue != details.mergeValue) {
                        details.value = baseValue
                    }
                    if (details.key == 'foo') {
                        details.exclude()
                    }
                }
            }
        }
    }

build.gradle.kts

    
    
    tasks.register<Jar>("barJar") {
        manifest {
            attributes("key1" to "value1")
            from(sharedManifest, "src/config/basemanifest.txt")
            from(listOf("src/config/javabasemanifest.txt", "src/config/libbasemanifest.txt")) {
                eachEntry(Action<ManifestMergeDetails> {
                    if (baseValue != mergeValue) {
                        value = baseValue
                    }
                    if (key == "foo") {
                        exclude()
                    }
                })
            }
        }
    }

Manifests are merged in the order they are declared in the `from` statement.
If the base manifest and the merged manifest both define values for the same
key, the merged manifest wins by default. You can fully customize the merge
behavior by adding `eachEntry` actions in which you have access to a
[ManifestMergeDetails](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/java/archives/ManifestMergeDetails.html)
instance for each entry of the resulting manifest. Note that the merge is done
lazily, either when generating the JAR or when `Manifest.writeTo()` or
`Manifest.getEffectiveManifest()` are called.

Speaking of `writeTo()`, you can use that to easily write a manifest to disk
at any time, like so:

Example 12. Saving a MANIFEST.MF to disk

`Groovy``Kotlin`

build.gradle

    
    
    jar.manifest.writeTo("$buildDir/mymanifest.mf")

build.gradle.kts

    
    
    tasks.named<Jar>("jar") { manifest.writeTo("$buildDir/mymanifest.mf") }

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:generating_javadocs)[Generating
API
documentation](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:generating_javadocs)

The Java Library Plugin provides a `javadoc` task of type
[Javadoc](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.javadoc.Javadoc.html),
that will generate standard Javadocs for all your production code, i.e.
whatever source is in the `main` source set. The task supports the core
Javadoc and standard doclet options described in the [Javadoc reference
documentation](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html#options).
See
[CoreJavadocOptions](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/external/javadoc/CoreJavadocOptions.html)
and
[StandardJavadocDocletOptions](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/external/javadoc/StandardJavadocDocletOptions.html)
for a complete list of those options.

As an example of what you can do, imagine you want to use Asciidoc syntax in
your Javadoc comments. To do this, you need to add Asciidoclet to Javadoc’s
doclet path. Here’s an example that does just that:

Example 13. Using a custom doclet with Javadoc

`Groovy``Kotlin`

build.gradle

    
    
    configurations {
        asciidoclet
    }
    
    dependencies {
        asciidoclet 'org.asciidoctor:asciidoclet:1.+'
    }
    
    task configureJavadoc {
        doLast {
            javadoc {
                options.doclet = 'org.asciidoctor.Asciidoclet'
                options.docletpath = configurations.asciidoclet.files.toList()
            }
        }
    }
    
    javadoc {
        dependsOn configureJavadoc
    }

build.gradle.kts

    
    
    val asciidoclet by configurations.creating
    
    dependencies {
        asciidoclet("org.asciidoctor:asciidoclet:1.+")
    }
    
    tasks.register("configureJavadoc") {
        doLast {
            tasks.javadoc {
                options.doclet = "org.asciidoctor.Asciidoclet"
                options.docletpath = asciidoclet.files.toList()
            }
        }
    }
    
    tasks.javadoc {
        dependsOn("configureJavadoc")
    }

You don’t have to create a configuration for this, but it’s an elegant way to
handle dependencies that are required for a unique purpose.

You might also want to create your own Javadoc tasks, for example to generate
API docs for the tests:

Example 14. Defining a custom Javadoc task

`Groovy``Kotlin`

build.gradle

    
    
    task testJavadoc(type: Javadoc) {
        source = sourceSets.test.allJava
    }

build.gradle.kts

    
    
    tasks.register<Javadoc>("testJavadoc") {
        source = sourceSets.test.get().allJava
    }

These are just two non-trivial but common customizations that you might come
across.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:cleaning_java_build)[Cleaning
the
build](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:cleaning_java_build)

The Java Library Plugin adds a `clean` task to your project by virtue of
applying the [Base
Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/base_plugin.html#base_plugin).
This task simply deletes everything in the `$buildDir` directory, hence why
you should always put files generated by the build in there. The task is an
instance of
[Delete](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.tasks.Delete.html)
and you can change what directory it deletes by setting its `dir` property.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_jvm_components)[Building
JVM
components](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_jvm_components)

All of the specific JVM plugins are built on top of the [Java
Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_plugin.html).
The examples above only illustrated concepts provided by this base plugin and
shared with all JVM plugins.

Read on to understand which plugins fits which project type, as it is
recommended to pick a specific plugin instead of applying the Java Plugin
directly.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_libraries)[Building
Java
libraries](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_libraries)

The unique aspect of library projects is that they are used (or "consumed") by
other Java projects. That means the dependency metadata published with the JAR
file — usually in the form of a Maven POM —  is crucial. In particular,
consumers of your library should be able to distinguish between two different
types of dependencies: those that are only required to compile your library
and those that are also required to compile the consumer.

Gradle manages this distinction via the [Java Library
Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html#java_library_plugin),
which introduces an _api_ configuration in addition to the _implementation_
one covered in this chapter. If the types from a dependency appear in public
fields or methods of your library’s public classes, then that dependency is
exposed via your library’s public API and should therefore be added to the
_api_ configuration. Otherwise, the dependency is an internal implementation
detail and should be added to _implementation_.

If you’re unsure of the difference between an API and implementation
dependency, the [Java Library Plugin
chapter](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html#sec:java_library_recognizing_dependencies)
has a detailed explanation. In addition, you can explore a basic, practical
[sample of building a Java
library](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/sample_building_java_libraries.html).

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_applications)[Building
Java
applications](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_applications)

Java applications packaged as a JAR aren’t set up for easy launching from the
command line or a desktop environment. The [Application
Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/application_plugin.html#application_plugin)
solves the command line aspect by creating a distribution that includes the
production JAR, its dependencies and launch scripts Unix-like and Windows
systems.

See the plugin’s chapter for more details, but here’s a quick summary of what
you get:

  * `assemble` creates ZIP and TAR distributions of the application containing everything needed to run it

  * A `run` task that starts the application from the build (for easy testing)

  * Shell and Windows Batch scripts to start the application

You can see a basic example of building a Java application in the
corresponding
[sample](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/building-java-
applications.html).

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_webapps)[Building
Java web
applications](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_webapps)

Java web applications can be packaged and deployed in a number of ways
depending on the technology you use. For example, you might use [Spring
Boot](https://projects.spring.io/spring-boot/) with a fat JAR or a
[Reactive](https://www.reactivemanifesto.org/)-based system running on
[Netty](https://netty.io/). Whatever technology you use, Gradle and its large
community of plugins will satisfy your needs. Core Gradle, though, only
directly supports traditional Servlet-based web applications deployed as WAR
files.

That support comes via the [War
Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/war_plugin.html#war_plugin),
which automatically applies the Java Plugin and adds an extra packaging step
that does the following:

  * Copies static resources from _src/main/webapp_ into the root of the WAR

  * Copies the compiled production classes into a _WEB-INF/classes_ subdirectory of the WAR

  * Copies the library dependencies into a _WEB-INF/lib_ subdirectory of the WAR

This is done by the `war` task, which effectively replaces the `jar` task —
although that task remains — and is attached to the `assemble` lifecycle task.
See the plugin’s chapter for more details and configuration options.

There is no core support for running your web application directly from the
build, but we do recommend that you try the
[Gretty](https://plugins.gradle.org/plugin/org.gretty) community plugin, which
provides an embedded Servlet container.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_enterprise_apps)[Building
Java EE
applications](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_enterprise_apps)

Java enterprise systems have changed a lot over the years, but if you’re still
deploying to JEE application servers, you can make use of the [Ear
Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/ear_plugin.html#ear_plugin).
This adds conventions and a task for building EAR files. The plugin’s chapter
has more details.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_platform)[Building
Java
Platforms](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_java_platform)

A Java platform represents a set of dependency declarations and constraints
that form a cohesive unit to be applied on consuming projects. The platform
has no source and no artifact of its own. It maps in the Maven world to a
[BOM](https://maven.apache.org/guides/introduction/introduction-to-dependency-
mechanism.html#Dependency_Management).

该支持来自[Java
Platform插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_platform_plugin.html)，该[插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_platform_plugin.html)设置了不同的配置和发布组件。

__ |

该插件是例外，因为它不应用Java插件。  
  
---|---  
  
##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:feature_preview)[启用Java预览功能](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:feature_preview)

__ |

使用Java预览功能很可能使您的代码与没有功能预览的编译代码不兼容。因此，我们强烈建议您不要发布使用预览功能编译的库，并将功能预览的使用限制在玩具项目中。  
  
---|---  
  
要启用Java[预览功能](https://openjdk.java.net/jeps/12)进行编译，测试执行和运行时，可以使用以下DSL代码段：

例子15.启用Java功能预览

`Groovy``Kotlin`

build.gradle

    
    
    tasks.withType(JavaCompile) {
        options.compilerArgs += "--enable-preview"
    }
    tasks.withType(Test) {
        jvmArgs += "--enable-preview"
    }
    tasks.withType(JavaExec) {
        jvmArgs += "--enable-preview"
    }

build.gradle.kts

    
    
    tasks.withType<JavaCompile> {
        options.compilerArgs.add("--enable-preview")
    }
    tasks.withType<Test> {
        jvmArgs("--enable-preview")
    }
    tasks.withType<JavaExec> {
        jvmArgs("--enable-preview")
    }

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_jvm_lang)[构建其他JVM语言项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sec:building_jvm_lang)

如果要利用JVM的多语言方面，此处描述的大多数内容仍然适用。

Gradle本身提供了[Groovy](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html)和[Scala](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/scala_plugin.html)插件。插件会自动提供对Java代码编译的支持，并且可以通过将其与`java-
library`插件结合来进一步增强。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sub:compile_deps_jvm_lang)[语言之间的编译依赖性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#sub:compile_deps_jvm_lang)

这些插件在Groovy /
Scala编译和Java编译（源代码`java`文件夹中的源代码）之间创建了依赖关系。您可以通过调整涉及的编译任务的类路径来更改此默认行为，如以下示例所示：

例子16.改变编译任务的类路径

`Groovy``Kotlin`

build.gradle

    
    
    tasks.named('compileGroovy') {
        // Groovy only needs the declared dependencies
        // (and not longer the output of compileJava)
        classpath = sourceSets.main.compileClasspath
    }
    tasks.named('compileJava') {
        // Java also depends on the result of Groovy compilation
        // (which automatically makes it depend of compileGroovy)
        classpath += files(sourceSets.main.groovy.classesDirectory)
    }

build.gradle.kts

    
    
    tasks.named<AbstractCompile>("compileGroovy") {
        // Groovy only needs the declared dependencies
        // (and not longer the output of compileJava)
        classpath = sourceSets.main.get().compileClasspath
    }
    tasks.named<AbstractCompile>("compileJava") {
        // Java also depends on the result of Groovy compilation
        // (which automatically makes it depend of compileGroovy)
        classpath += files(sourceSets.main.get().withConvention(GroovySourceSet::class) { groovy }.classesDirectory)
    }

  1. 通过将`compileGroovy`classpath设置为only `sourceSets.main.compileClasspath`，我们有效地消除了先前对`compileJava`classpath的依赖，方法是将classpath也考虑在内`sourceSets.main.java.classesDirectory`

  2. 通过添加`sourceSets.main.groovy.classesDirectory`到`compileJava` `classpath`，我们有效申报的依赖`compileGroovy`任务

所有这些都可以通过使用[目录属性来实现](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html)。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#extra_language_support)[额外的语言支持](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#extra_language_support)

除了核心Gradle之外，还有其他[很棒的插件可](https://plugins.gradle.org/search?term=jvm)用于更多JVM语言！

* * *

[1](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html#_footnoteref_1)。实际上，添加到`archives`配置中的任何工件都将由`assemble`

**文件**

  * [用户手册](file:///userguide/userguide.html)
  * [DSL参考](file:///dsl/)
  * [发行说明](file:///release-notes.html)
  * [Java文档](file:///javadoc/)

**新闻**

  * [博客](https://blog.gradle.org/)
  * [通讯](https://newsletter.gradle.com/)
  * [推特](https://twitter.com/gradle)
  * [状态页](https://status.gradle.com/)

**产品展示**

  * [构建扫描](https://gradle.com/build-scans/)
  * [构建缓存](https://gradle.com/build-cache/)
  * [企业文件](https://gradle.com/enterprise/resources/)

**得到帮助**

  * [论坛](https://discuss.gradle.org/c/help-discuss)
  * [的GitHub](https://github.com/gradle/)
  * [训练](https://gradle.com/training/)
  * [服务](https://gradle.org/services/)

##### 随时`UP-TO-DATE`关注新功能和新闻

输入您的电子邮件，即表示您同意我们的[条款](https://gradle.com/legal/terms-of-
service/)和[隐私政策](https://gradle.com/legal/privacy/)，包括接收电子邮件。您可以随时取消订阅。

订阅

© [Gradle Inc.](https://gradle.com/) 2020年 版权所有。

[ gradle ](file:///)

[招贤纳士](https://gradle.com/careers/)| [隐私](https://gradle.com/legal/privacy/)|
[服务条款](https://gradle.com/legal/terms-of-service/)|
[联系](https://gradle.org/contact/)

![Google 翻译](./构建Java和JVM项目_files/translate_24dp.png)

# 原文

提供更好的翻译建议

* * *

