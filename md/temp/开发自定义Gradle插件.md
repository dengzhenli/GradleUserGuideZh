

[ Gradle ](https://docs.gradle.org/ "Gradle Docs")

用户手册

  * 社区 Open Community Menu

[ 社区之家 ](https://gradle.org/)

[ 社区论坛 ](https://discuss.gradle.org/)

[ 社区插件 ](https://plugins.gradle.org/)

  * [训练](https://gradle.com/training/)
  * 新闻 Open Community Menu

[ 通讯 ](https://newsletter.gradle.com/)

[ 博客 ](https://blog.gradle.org/)

[ 推特 ](https://twitter.com/gradle)

  * [企业](https://gradle.com/)
  * [github](https://github.com/gradle/gradle "GitHub上的Gradle")

  * [文件首页](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.html)
  * [样品](file:///Users/dxs/temp/gradle-6.7.1/docs/samples/index.html)
  * [发行说明](file:///Users/dxs/temp/gradle-6.7.1/docs/release-notes.html)
  * [Gradle API](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#gradle-api)
    * [Java文档](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/index.html?overview-summary.html)
    * [Groovy DSL参考](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/index.html)
    * [Groovy DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/kotlin_dsl.html)

### 用户手册

[ PDF格式 ](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/userguide.pdf)

  * [什么是Gradle？](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/what_is_gradle.html)
  * [入门](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/getting_started.html)
  * [安装Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/installation.html)
  * [升级Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#upgrading-gradle)
    * [版本6.X到最新](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_6.html)
    * [版本5.X到6.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_5.html)
    * [版本4.X到5.0](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/upgrading_version_4.html)
    * [Gradle的功能生命周期](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_lifecycle.html)
  * [迁移至Gradle ...](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#migrating-to-gradle)
    * [从Maven](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_maven.html)
    * [来自蚂蚁](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/migrating_from_ant.html)
  * [相容性说明](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/compatibility.html)
  * [对构建进行故障排除](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/troubleshooting.html)

### 运行Gradle构建

  * [自定义执行](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#customizing-execution)
    * [配置构建环境](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_environment.html)
    * [Configuring the Gradle Daemon](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_daemon.html)
    * [Using Initialization Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/init_scripts.html)
  * [执行多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/intro_multi_project_builds.html)
  * [检查Gradle构建](https://scans.gradle.com/)
  * [优化构建时间](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#optimizing-build-performance)
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_cache.html)
    * [Using the Configuration Cache](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/configuration_cache.html)

### 编写Gradle构建

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#learning-the-basics)
    * [Introducing the Basics of Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/tutorial_using_tasks.html)
    * [Working with Tasks](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/writing_build_scripts.html)
    * [Working with Files](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/working_with_files.html)
    * [Using Gradle Plugins](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html)
    * [Understanding the Build Lifecycle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/build_lifecycle.html)
    * [Working with Logging](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/logging.html)
    * [Avoiding Traps](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/potential_traps.html)
  * [创作多项目构建](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#authoring-multi-project-builds)
    * [Creating a Basic Multi-Project Build](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/multi_project_configuration_and_execution.html)
  * [创作可持续建筑](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#authoring-sustainable-builds)
    * [Organizing Build Logic](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html)
    * [Following Best Practices](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/authoring_maintainable_build_scripts.html)
  * [先进技术](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#advanced-techniques)
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/test_kit.html)
    * [Using Ant from Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/ant.html)

### 编写JVM构建

  * [构建Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_java_projects.html)
  * [测试Java和JVM项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_testing.html)
  * [Java项目的工具链](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/toolchains.html)
  * [管理依赖关系](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_for_java_projects.html)
  * [JVM插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#jvm-plugins)
    * [Java Library Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_library_plugin.html)
    * [Java Application Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/application_plugin.html)
    * [Java Platform Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_platform_plugin.html)
    * [Groovy Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/groovy_plugin.html)
    * [Scala Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/scala_plugin.html)

### 编写C ++ / Swift构建

  * [构建C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_cpp_projects.html)
  * [测试C ++项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cpp_testing.html)
  * [建立Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/building_swift_projects.html)
  * [测试Swift项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/swift_testing.html)

### 使用依赖项

  * [学习基础](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#learning-the-basics-dependency-management)
    * [What is Dependency Management?](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/core_dependency_management.html)
    * [Declaring Repositories](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_repositories.html)
    * [Declaring Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_resolution.html)
    * [Verifying dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_verification.html)
  * [声明版本](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#declaring-dependency-versions)
    * [Declaring Versions and Ranges](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/single_versions.html)
    * [Declaring Rich Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/rich_versions.html)
    * [Handling Changing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dynamic_versions.html)
    * [Locking Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_locking.html)
  * [控制翻译](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#controlling-transitive-dependencies)
    * [Upgrading Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_constraints.html)
    * [Downgrading and Excluding](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/platforms.html)
    * [Aligning Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_metadata_rules.html)
    * [Customizing Resolution](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_rules.html)
    * [Preventing accidental upgrades](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/resolution_strategy_tuning.html)
  * [图书馆的生产和消费形式](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#modeling-features)
    * [Declaring Capabilities of a Library](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/feature_variants.html)
    * [Understanding Variant Selection](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_model.html)
    * [Declaring Variant Attributes](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/cross_project_publications.html)
    * [Transforming Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/artifact_transforms.html)
  * [在多仓库环境中工作](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#multi-repo)
    * [Composing Builds](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/composite_builds.html)
  * [出版图书馆](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#publishing)
    * [Setting up Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_signing.html)
    * [Customizing Publishing](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_customization.html)
    * [Maven Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_maven.html)
    * [Ivy Publish Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html)
  * [术语](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/dependency_management_terminology.html)

### 扩展摇篮

  * [插件开发教程](https://gradle.org/guides/?q=Plugin%20Development)
  * [编写Gradle任务类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html)
  * [编写Gradle插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html)
  * [编写自定义Gradle类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html)
  * [延迟配置任务](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html)
  * [使用避免任务配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/task_configuration_avoidance.html)

### 参考

  * [核心插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugin_reference.html)
  * [命令行界面](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/command_line_interface.html)
  * [Gradle和第三方工具](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/third_party_integration.html)
  * [摇篮包装](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/gradle_wrapper.html)
  * [Gradle管理的目录](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/directory_layout.html)

# 开发自定义Gradle插件

version 6.7.1

内容

  * [打包插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:packaging_a_plugin)
  * [编写一个简单的插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:writing_a_simple_plugin)
  * [使插件可配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:getting_input_from_the_build)
  * [在自定义任务和插件中处理文件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:working_with_files_in_custom_tasks_and_plugins)
  * [将扩展属性映射到任务属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:mapping_extension_properties_to_task_properties)
  * [一个独立的项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:custom_plugins_standalone_project)
  * [预编译脚本插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:precompiled_plugins)
  * [为您的插件编写测试](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:writing_tests_for_your_plugin)
  * [更多细节](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#more_details)
  * [幕后花絮](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#behind_the_scenes)

A Gradle plugin packages up reusable pieces of build logic, which can be used
across many different projects and builds. Gradle allows you to implement your
own plugins, so you can reuse your build logic, and share it with others.

You can implement a Gradle plugin in any language you like, provided the
implementation ends up compiled as JVM bytecode. In our examples, we are going
to use Java as the implementation language for standalone plugin project and
Groovy or Kotlin in the buildscript plugin examples. In general, a plugin
implemented using Java or Kotlin, which are statically typed, will perform
better than the same plugin implemented using Groovy.

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:packaging_a_plugin)[Packaging
a
plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:packaging_a_plugin)

There are several places where you can put the source for the plugin.

Build script

    

You can include the source for the plugin directly in the build script. This
has the benefit that the plugin is automatically compiled and included in the
classpath of the build script without you having to do anything. However, the
plugin is not visible outside the build script, and so you cannot reuse the
plugin outside the build script it is defined in.

`buildSrc` project

    

You can put the source for the plugin in the `_rootProjectDir_
/buildSrc/src/main/java` directory (or `_rootProjectDir_
/buildSrc/src/main/groovy` or `_rootProjectDir_ /buildSrc/src/main/kotlin`
depending on which language you prefer). Gradle will take care of compiling
and testing the plugin and making it available on the classpath of the build
script. The plugin is visible to every build script used by the build.
However, it is not visible outside the build, and so you cannot reuse the
plugin outside the build it is defined in.

有关[项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html#organizing_gradle_projects)的更多详细信息，请参见[组织Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/organizing_gradle_projects.html#organizing_gradle_projects)`buildSrc`项目。

独立项目

    

您可以为插件创建一个单独的项目。这个项目产生并发布了一个JAR，您可以在多个版本中使用它并与他人共享。通常，此JAR可能包含一些插件，或将几个相关的任务类捆绑到一个库中。或两者的某种组合。

在我们的示例中，我们将从构建脚本中的插件开始，以使事情变得简单。然后，我们将考虑创建一个独立的项目。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:writing_a_simple_plugin)[编写一个简单的插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:writing_a_simple_plugin)

要创建Gradle插件，您需要编写一个实现[Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/Plugin.html)接口的类。将插件应用于项目时，Gradle将创建插件类的实例，并调用该实例的[Plugin.apply（）](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/Plugin.html#apply-T-)方法。项目对象作为参数传递，插件可以使用该参数配置项目，但需要这样做。下面的示例包含一个Greeting插件，该插件将一个`hello`任务添加到项目中。

例子1.一个自定义插件

`Groovy``Kotlin`

build.gradle

    
    
    class GreetingPlugin implements Plugin<Project> {
        void apply(Project project) {
            project.task('hello') {
                doLast {
                    println 'Hello from the GreetingPlugin'
                }
            }
        }
    }
    
    // Apply the plugin
    apply plugin: GreetingPlugin

build.gradle.kts

    
    
    class GreetingPlugin : Plugin<Project> {
        override fun apply(project: Project) {
            project.task("hello") {
                doLast {
                    println("Hello from the GreetingPlugin")
                }
            }
        }
    }
    
    // Apply the plugin
    apply<GreetingPlugin>()

输出 **`gradle -q hello`**

    
    
    > gradle -q你好
    您好，GreetingPlugin

要注意的一件事是，将为每个应用插件的项目创建一个插件的新实例。另请注意，[Plugin](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/Plugin.html)类是泛型类型。此示例接收[项目](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.Project.html)类型作为类型参数。插件可以改为接收类型为[Settings](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.initialization.Settings.html)的参数，在这种情况下，可以将其应用在设置脚本中，或者可以将类型为[Gradle](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.invocation.Gradle.html)的参数应用在初始化脚本中。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:getting_input_from_the_build)[使插件可配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:getting_input_from_the_build)

大多数插件为构建脚本提供了一些配置选项，其他插件则用于自定义插件的工作方式。插件使用 _扩展对象_
执行此操作。Gradle[项目](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.Project.html)具有关联的[ExtensionContainer](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/plugins/ExtensionContainer.html)对象，该对象包含已应用于项目的插件的所有设置和属性。您可以通过向该容器添加扩展对象来为您的插件提供配置。扩展对象只是具有表示配置的Java
Bean属性的对象。

让我们向项目添加一个简单的扩展对象。在这里，我们`greeting`向项目添加一个扩展对象，使您可以配置问候语。

例子2.一个自定义插件扩展

`Groovy``Kotlin`

build.gradle

    
    
    class GreetingPluginExtension {
        String message = 'Hello from GreetingPlugin'
    }
    
    class GreetingPlugin implements Plugin<Project> {
        void apply(Project project) {
            // Add the 'greeting' extension object
            def extension = project.extensions.create('greeting', GreetingPluginExtension)
            // Add a task that uses configuration from the extension object
            project.task('hello') {
                doLast {
                    println extension.message
                }
            }
        }
    }
    
    apply plugin: GreetingPlugin
    
    // Configure the extension
    greeting.message = 'Hi from Gradle'

build.gradle.kts

    
    
    open class GreetingPluginExtension {
        var message = "Hello from GreetingPlugin"
    }
    
    class GreetingPlugin : Plugin<Project> {
        override fun apply(project: Project) {
            // Add the 'greeting' extension object
            val extension = project.extensions.create<GreetingPluginExtension>("greeting")
            // Add a task that uses configuration from the extension object
            project.task("hello") {
                doLast {
                    println(extension.message)
                }
            }
        }
    }
    
    apply<GreetingPlugin>()
    
    // Configure the extension
    the<GreetingPluginExtension>().message = "Hi from Gradle"

输出 **`gradle -q hello`**

    
    
    > gradle -q你好
    来自Gradle的大家好

在此示例中，`GreetingPluginExtension`是一个对象，其属性名为`message`。扩展对象将添加到名称为的项目中`greeting`。然后，该对象可用作与扩展对象同名的项目属性。

通常，您需要在单个插件上指定多个相关属性。Gradle为每个扩展对象添加一个配置块，因此您可以将设置分组在一起。以下示例向您展示了它是如何工作的。

例子3.一个带有配置块的自定义插件

`Groovy``Kotlin`

build.gradle

    
    
    class GreetingPluginExtension {
        String message
        String greeter
    }
    
    class GreetingPlugin implements Plugin<Project> {
        void apply(Project project) {
            def extension = project.extensions.create('greeting', GreetingPluginExtension)
            project.task('hello') {
                doLast {
                    println "${extension.message} from ${extension.greeter}"
                }
            }
        }
    }
    
    apply plugin: GreetingPlugin
    
    // Configure the extension using a DSL block
    greeting {
        message = 'Hi'
        greeter = 'Gradle'
    }

build.gradle.kts

    
    
    open class GreetingPluginExtension {
        var message: String? = null
        var greeter: String? = null
    }
    
    class GreetingPlugin : Plugin<Project> {
        override fun apply(project: Project) {
            val extension = project.extensions.create<GreetingPluginExtension>("greeting")
            project.task("hello") {
                doLast {
                    println("${extension.message} from ${extension.greeter}")
                }
            }
        }
    }
    
    apply<GreetingPlugin>()
    
    // Configure the extension using a DSL block
    configure<GreetingPluginExtension> {
        message = "Hi"
        greeter = "Gradle"
    }

输出 **`gradle -q hello`**

    
    
    > gradle -q你好
    来自Gradle的大家好

In this example, several settings can be grouped together within the
`greeting` closure. The name of the closure block in the build script
(`greeting`) needs to match the extension object name. Then, when the closure
is executed, the fields on the extension object will be mapped to the
variables within the closure based on the standard Groovy closure delegate
feature.

In this example, several settings can be grouped together within the
`configure<GreetingPluginExtension>` block. The type used on the `configure`
function in the build script (`GreetingPluginExtension`) needs to match the
extension type. Then, when the block is executed, the receiver of the block is
the extension.

In this way, using an extension object _extends_ the Gradle DSL to add a
project property and DSL block for the plugin. And because an extension object
is simply a regular object, you can provide your own DSL nested inside the
plugin block by adding properties and methods to the extension object.

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#developing_project_extensions)[Developing
project
extensions](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#developing_project_extensions)

您可以在[开发自定义Gradle类型中](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#custom_gradle_types)找到有关实现项目扩展的更多信息。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:working_with_files_in_custom_tasks_and_plugins)[在自定义任务和插件中处理文件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:working_with_files_in_custom_tasks_and_plugins)

在开发自定义任务和插件时，最好在接受文件位置的输入配置时非常灵活。为此，您可以利用[Project.file（java.lang.Object）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file\(java.lang.Object\))方法尽可能晚地将值解析为文件。

例子4.懒惰地评估文件属性

`Groovy``Kotlin`

build.gradle

    
    
    class GreetingToFileTask extends DefaultTask {
    
        def destination
    
        @OutputFile
        File getDestination() {
            project.file(destination)
        }
    
        @TaskAction
        def greet() {
            def file = getDestination()
            file.parentFile.mkdirs()
            file.write 'Hello!'
        }
    }
    
    task greet(type: GreetingToFileTask) {
        destination = { project.greetingFile }
    }
    
    task sayGreeting(dependsOn: greet) {
        doLast {
            println file(greetingFile).text
        }
    }
    
    ext.greetingFile = "$buildDir/hello.txt"

build.gradle.kts

    
    
    open class GreetingToFileTask : DefaultTask() {
    
        var destination: Any? = null
    
        @OutputFile
        fun getDestination(): File {
            return project.file(destination!!)
        }
    
        @TaskAction
        fun greet() {
            val file = getDestination()
            file.parentFile.mkdirs()
            file.writeText("Hello!")
        }
    }
    
    tasks.register<GreetingToFileTask>("greet") {
        destination = { project.extra["greetingFile"]!! }
    }
    
    tasks.register("sayGreeting") {
        dependsOn("greet")
        doLast {
            println(file(project.extra["greetingFile"]!!).readText())
        }
    }
    
    extra["greetingFile"] = "$buildDir/hello.txt"

输出 **`gradle -q sayGreeting`**

    
    
    > gradle -q说问候
    你好！

在此示例中，我们将`greet`task`destination`属性配置为闭包/提供者，使用[Project.file（java.lang.Object）](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file\(java.lang.Object\))方法对其进行评估，`File`以在最后一刻将闭包/提供者的返回值转换为对象。您会注意到，在上面的示例中，`greetingFile`在配置为任务使用属性值之后，我们指定了属性值。这种惰性评估的主要好处是在设置文件属性时接受任何值，然后在读取属性时解析该值。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:mapping_extension_properties_to_task_properties)[将扩展属性映射到任务属性](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:mapping_extension_properties_to_task_properties)

从构建脚本通过扩展捕获用户输入并将其映射到自定义任务的输入/输出属性是一种有用的模式。构建脚本作者仅与扩展定义的DSL交互。命令式逻辑隐藏在插件实现中。

Gradle提供了一些类型，您可以在任务实现和扩展中使用这些类型来帮助您。有关更多信息，请参考[惰性配置](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/lazy_configuration.html#lazy_configuration)。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:custom_plugins_standalone_project)[一个独立的项目](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:custom_plugins_standalone_project)

现在，我们将插件移至独立项目，以便我们可以发布它并与他人共享。这个项目只是一个Java项目，它产生包含插件类的JAR。打包和发布插件的最简单且推荐的方法是使用[Java
Gradle插件开发插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_gradle_plugin.html#java_gradle_plugin)。该插件将自动应用[Java插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_plugin.html#java_plugin)，将`gradleApi()`依赖项添加到api配置中，在生成的JAR文件中生成所需的插件描述符，并配置要在发布时使用的[插件标记工件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html#sec:plugin_markers)。这是该项目的简单构建脚本。

例子5.一个自定义插件的构建

`Groovy``Kotlin`

build.gradle

    
    
    plugins {
        id 'java-gradle-plugin'
    }
    
    gradlePlugin {
        plugins {
            simplePlugin {
                id = 'org.samples.greeting'
                implementationClass = 'org.gradle.GreetingPlugin'
            }
        }
    }

build.gradle.kts

    
    
    plugins {
        `java-gradle-plugin`
    }
    
    gradlePlugin {
        plugins {
            create("simplePlugin") {
                id = "org.samples.greeting"
                implementationClass = "org.gradle.GreetingPlugin"
            }
        }
    }

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:creating_a_plugin_id)[创建一个插件ID](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:creating_a_plugin_id)

插件ID以类似于Java包的方式（即反向域名）完全合格。这有助于避免冲突，并提供了一种将具有相似所有权的插件分组的方法。

您的插件ID应该是反映名称空间（指向您或您的组织的合理指针）的组件及其提供的插件名称的组合。例如，如果您有一个名为“
foo”的Github帐户，而您的插件名为“
bar”，则合适的插件ID可能为`com.github.foo.bar`。同样，如果插件是由baz组织开发的，则插件ID可能为`org.baz.bar`。

插件ID应符合以下条件：

  * 可以包含任何字母数字字符“。”和“-”。

  * 必须至少包含一个“。”。分隔命名空间和插件名称的字符。

  * 按照惯例，对名称空间使用小写的反向域名约定。

  * 通常，名称中仅使用小写字符。

  * `org.gradle`并且`com.gradleware`不能使用名称空间。

  * 不能以“。”开头或结尾。字符。

  * 不能包含连续的“。” 字符（即“ ..”）。

尽管插件ID与程序包名称之间存在常规的相似之处，但通常包名称比插件ID所需的更为详细。例如，在您的插件ID中添加“
gradle”作为组件似乎是合理的，但是由于插件ID仅用于Gradle插件，因此这是多余的。通常，一个良好的插件ID只需要一个用于标识所有权和名称的名称空间。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:publishing_your_plugin)[发布您的插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:publishing_your_plugin)

如果要在内部发布插件供组织内部使用，则可以像其他任何代码工件一样发布。请参阅有关发布工件的[Ivy](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_ivy.html#publishing_ivy)和[Maven](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/publishing_maven.html#publishing_maven)章节。

如果您有兴趣发布供更广泛的Gradle社区使用的插件，则可以将其发布到[Gradle插件门户](http://plugins.gradle.org/)。该站点提供了搜索和收集有关Gradle社区贡献的插件的信息的功能。请参阅相应的[指南，](https://guides.gradle.org/publishing-
plugins-to-gradle-plugin-portal/)以了解如何在此站点上使用您的插件。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:using_your_plugin_in_another_project)[在另一个项目中使用您的插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:using_your_plugin_in_another_project)

要在构建脚本中使用插件，您需要`pluginManagement {}`在项目的设置文件中配置存储库。以下示例显示了将插件发布到本地存储库后如何执行此操作：

例子6.在另一个项目中使用一个自定义插件

`Groovy``Kotlin`

settings.gradle

    
    
    pluginManagement {
        repositories {
            maven {
                url = uri(repoLocation)
            }
        }
    }

build.gradle

    
    
    plugins {
        id 'org.samples.greeting' version '1.0-SNAPSHOT'
    }

settings.gradle.kts

    
    
    pluginManagement {
        repositories {
            maven {
                url = uri(repoLocation)
            }
        }
    }

build.gradle.kts

    
    
    plugins {
        id("org.samples.greeting") version "1.0-SNAPSHOT"
    }

####
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#note_for_plugins_published_without_java_gradle_plugin)[不带插件发布的注释
`java-gradle-
plugin`](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#note_for_plugins_published_without_java_gradle_plugin)

如果您的插件是在未使用[Java
Gradle插件开发插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_gradle_plugin.html#java_gradle_plugin)的情况下发布的，则该出版物将缺少[Plugin
Marker
Artifact](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html#sec:plugin_markers)，这是[插件DSL](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/plugins.html#sec:plugins_block)查找插件所需的。在这种情况下，建议在另一个项目中解析该插件的方法是在该项目的设置文件`resolutionStrategy`的`pluginManagement
{}`块中添加一个部分，如下所示。

例子7.没有插件标记工件的插件的解析策略

`Groovy``Kotlin`

settings.gradle

    
    
        resolutionStrategy {
            eachPlugin {
                if (requested.id.namespace == 'org.samples') {
                    useModule("org.gradle:custom-plugin:${requested.version}")
                }
            }
        }

settings.gradle.kts

    
    
        resolutionStrategy {
            eachPlugin {
                if (requested.id.namespace == "org.samples") {
                    useModule("org.gradle:custom-plugin:${requested.version}")
                }
            }
        }

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:precompiled_plugins)[预编译脚本插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:precompiled_plugins)

除了作为独立项目编写的插件之外，Gradle还允许您提供以Groovy或Kotlin
DSL编写的构建逻辑作为预编译脚本插件。您可以将它们写为`*.gradle`目录中的`src/main/groovy`
文件或`*.gradle.kts`目录中的`src/main/kotlin`文件。

预编译的脚本插件被编译成类文件，然后打包到jar中。出于所有目的和目的，它们是二进制插件，可以通过插件ID进行应用，经过测试并作为二进制插件发布。实际上，它们的插件元数据是使用[Gradle插件开发插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_gradle_plugin.html#java_gradle_plugin)生成的。

__ |

Gradle 6.0内置的Kotlin DSL预编译脚本插件不能与Gradle的早期版本一起使用。在Gradle的未来版本中将取消此限制。

Groovy DSL预编译脚本插件从Gradle 6.4开始可用。  
  
---|---  
  
要应用预编译的脚本插件，您需要知道其ID，该ID由插件脚本的文件名（减去`.gradle`扩展名）派生而来。

To apply a precompiled script plugin, you need to know its ID which is derived
from the plugin script’s filename (minus the `.gradle.kts` extension) and its
(optional) package declaration.

例如，脚本`src/main/groovy/java-library-convention.gradle`的插件ID为`java-library-
convention`。同样，`src/main/groovy/my.java-library-convention.gradle`将产生的插件ID
`my.java-library-convention`。

For example, the script `src/main/kotlin/java-library-convention.gradle.kts`
would have a plugin ID of `java-library-convention` (assuming it has no
package declaration). Likewise, `src/main/kotlin/my/java-library-
convention.gradle.kts` would result in a plugin ID of `my.java-library-
convention` as long as it has a package declaration of `my`.

为了演示如何实现和使用预编译的脚本插件，我们来看一个基于`buildSrc`项目的示例。

首先，您需要一个`buildSrc/build.gradle`应用`groovy-gradle-plugin`插件的文件：

First, you need a `buildSrc/build.gradle.kts` file that applies the `kotlin-
dsl` plugin:

例子8.启用预编译脚本插件

`Groovy``Kotlin`

buildSrc / build.gradle

    
    
    plugins {
        id 'groovy-gradle-plugin'
    }

buildSrc/build.gradle.kts

    
    
    plugins {
        `kotlin-dsl`
    }
    
    repositories {
        jcenter()
    }

我们建议您还创建一个`buildSrc/settings.gradle`文件，您可以将其保留为空。

We recommend that you also create a `buildSrc/settings.gradle.kts` file, which
you may leave empty.

接下来，`java-library-
convention.gradle`在`buildSrc/src/main/groovy`目录中创建一个新文件，并将其内容设置为以下内容：

Next, create a new `java-library-convention.gradle.kts` file in the
`buildSrc/src/main/kotlin` directory and set its contents to the following:

例子9.创建一个简单的脚本插件

`Groovy``Kotlin`

buildSrc / src / main / groovy / java-library-convention.gradle

    
    
    plugins {
        id 'java-library'
        id 'checkstyle'
    }
    
    java {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    
    checkstyle {
        maxWarnings = 0
        // ...
    }
    
    tasks.withType(JavaCompile) {
        options.warnings = true
        // ...
    }
    
    dependencies {
        testImplementation("junit:junit:4.13")
        // ...
    }

buildSrc/src/main/kotlin/java-library-convention.gradle.kts

    
    
    plugins {
        `java-library`
        checkstyle
    }
    
    java {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    
    checkstyle {
        maxWarnings = 0
        // ...
    }
    
    tasks.withType<JavaCompile> {
        options.isWarnings = true
        // ...
    }
    
    dependencies {
        testImplementation("junit:junit:4.13")
        // ...
    }

该脚本插件仅应用Java库和Checkstyle插件并对其进行配置。请注意，这实际上会将插件应用到主项目，即应用预编译脚本插件的插件。

最后，将脚本插件应用于根项目，如下所示：

例子10.将预编译的脚本插件应用到主项目

`Groovy``Kotlin`

build.gradle

    
    
    plugins {
        id 'java-library-convention'
    }

build.gradle.kts

    
    
    plugins {
        `java-library-convention`
    }

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#applying_external_plugins_in_precompiled_script_plugins)[在预编译的脚本插件中应用外部插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#applying_external_plugins_in_precompiled_script_plugins)

为了将外部插件应用到预编译的脚本插件中，必须将其添加到插件的构建文件中的插件项目的实现类路径中。

`Groovy``Kotlin`

buildSrc / build.gradle

    
    
    plugins {
        id 'groovy-gradle-plugin'
    }
    
    repositories {
        jcenter()
    }
    
    dependencies {
        implementation 'com.bmuschko:gradle-docker-plugin:6.4.0'
    }

buildSrc/build.gradle.kts

    
    
    plugins {
        `kotlin-dsl`
    }
    
    repositories {
        jcenter()
    }
    
    dependencies {
        implementation("com.bmuschko:gradle-docker-plugin:6.4.0")
    }

然后可以将其应用在预编译的脚本插件中。

`Groovy``Kotlin`

buildSrc / src / main / groovy / my-plugin.gradle

    
    
    plugins {
        id 'com.bmuschko.docker-remote-api'
    }

buildSrc/src/main/kotlin/my-plugin.gradle.kts

    
    
    plugins {
        id("com.bmuschko.docker-remote-api")
    }

在这种情况下，插件版本在依赖项声明中定义。

在将来的Gradle版本中将删除此限制。

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:writing_tests_for_your_plugin)[为您的插件编写测试](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#sec:writing_tests_for_your_plugin)

您可以使用[ProjectBuilder](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/testfixtures/ProjectBuilder.html)类创建在测试插件实现时要使用的[Project](file:///Users/dxs/temp/gradle-6.7.1/docs/dsl/org.gradle.api.Project.html)实例。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#example_testing_a_custom_plugin)[示例：测试自定义插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#example_testing_a_custom_plugin)

src / test / java / org / gradle / GreetingPluginTest.java

    
    
    public class GreetingPluginTest {
        @Test
        public void greeterPluginAddsGreetingTaskToProject() {
            Project project = ProjectBuilder.builder().build();
            project.getPluginManager().apply("org.samples.greeting");
    
            assertTrue(project.getTasks().getByName("hello") instanceof GreetingTask);
        }
    }

##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#more_details)[更多细节](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#more_details)

插件通常还提供自定义任务类型。有关更多详细信息，请参见[开发自定义Gradle任务类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_tasks.html#custom_tasks)。

Gradle提供了许多在开发Gradle类型（包括插件）时有用的功能。有关更多详细信息，请参见[开发自定义Gradle类型](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_gradle_types.html#custom_gradle_types)。

__ |
在开发Gradle插件时，将信息记录到构建日志中时请务必小心。记录敏感信息（例如凭据，令牌，某些环境变量）被[视为安全漏洞](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/logging.html#sec:debug_security)。公共持续集成服务的构建日志在世界范围内可见，并且可以公开此敏感信息。  
---|---  
  
##
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#behind_the_scenes)[幕后花絮](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#behind_the_scenes)

那么Gradle如何找到[插件](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/Plugin.html)实现？答案是-
您需要在JAR的`META-INF/gradle-plugins`目录中提供一个与您的插件ID相匹配的属性文件，该文件由[Java
Gradle插件开发插件处理](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/java_gradle_plugin.html#java_gradle_plugin)。

###
[](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#example_wiring_for_a_custom_plugin)[示例：接线自定义插件](file:///Users/dxs/temp/gradle-6.7.1/docs/userguide/custom_plugins.html#example_wiring_for_a_custom_plugin)

src / main / resources / META-INF / gradle-plugins /
org.samples.greeting.properties

    
    
    implementation-class=org.gradle.GreetingPlugin

请注意，属性文件名与插件ID匹配，并放置在资源文件夹中，并且该`implementation-
class`属性标识[插件](file:///Users/dxs/temp/gradle-6.7.1/docs/javadoc/org/gradle/api/Plugin.html)实现类。

**文件**

  * [用户手册](file:///userguide/userguide.html)
  * [DSL参考](file:///dsl/)
  * [发行说明](file:///release-notes.html)
  * [Java文档](file:///javadoc/)

**新闻**

  * [博客](https://blog.gradle.org/)
  * [通讯](https://newsletter.gradle.com/)
  * [推特](https://twitter.com/gradle)
  * [状态页](https://status.gradle.com/)

**产品展示**

  * [构建扫描](https://gradle.com/build-scans/)
  * [构建缓存](https://gradle.com/build-cache/)
  * [企业文件](https://gradle.com/enterprise/resources/)

**得到帮助**

  * [论坛](https://discuss.gradle.org/c/help-discuss)
  * [的GitHub](https://github.com/gradle/)
  * [训练](https://gradle.com/training/)
  * [服务](https://gradle.org/services/)

##### 随时`UP-TO-DATE`关注新功能和新闻

输入您的电子邮件，即表示您同意我们的[条款](https://gradle.com/legal/terms-of-
service/)和[隐私政策](https://gradle.com/legal/privacy/)，包括接收电子邮件。您可以随时取消订阅。

订阅

© [Gradle Inc.](https://gradle.com/) 2020年 版权所有。

[ gradle ](file:///)

[招贤纳士](https://gradle.com/careers/)| [隐私](https://gradle.com/legal/privacy/)|
[服务条款](https://gradle.com/legal/terms-of-service/)|
[联系](https://gradle.org/contact/)

![Google 翻译](./开发自定义Gradle插件_files/translate_24dp.png)

# 原文

提供更好的翻译建议

* * *

