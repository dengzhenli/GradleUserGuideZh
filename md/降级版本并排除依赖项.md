

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Downgrading versions and excluding dependencies

version 6.7.1

Contents

  * Overriding transitive dependency versions
  * Excluding transitive dependencies

## Overriding transitive dependency versions

Gradle resolves any dependency version conflicts by selecting the latest
version found in the dependency graph. Some projects might need to divert from
the default behavior and enforce an earlier version of a dependency e.g. if
the source code of the project depends on an older API of a dependency than
some of the external libraries.

__ |

Forcing a version of a dependency requires a conscious decision. Changing the
version of a transitive dependency might lead to runtime errors if external
libraries do not properly function without them. Consider upgrading your
source code to use a newer version of the library as an alternative approach.  
  
---|---  
  
In general, forcing dependencies is done to downgrade a dependency. There
might be different use cases for downgrading:

  * a bug was discovered in the latest release

  * your code depends on a lower version which is not binary compatible

  * your code doesn't depend on the code paths which need a higher version of a dependency

In all situations, this is best expressed saying that your code _strictly
depends on_ a version of a transitive. Using [strict
versions](rich_versions.html#sec:strict-version), you will effectively depend
on the version you declare, even if a transitive dependency says otherwise.

__ |

Strict dependencies are to some extent similar to Maven's _nearest first_
strategy, but there are subtle differences:

  * _strict dependencies_ don't suffer an ordering problem: they are applied transitively to the subgraph, and it doesn't matter in which order dependencies are declared.

  * conflicting strict dependencies will trigger a build failure that you have to resolve

  * strict dependencies can be used with rich versions, meaning that it's better to express the requirement in terms of a _strict range_ combined with a single _preferred version_.

  
  
---|---  
  
Let's say a project uses the [HttpClient
library](https://hc.apache.org/httpcomponents-client-ga/) for performing HTTP
calls. HttpClient pulls in [Commons
Codec](https://commons.apache.org/proper/commons-codec/) as transitive
dependency with version 1.10. However, the production source code of the
project requires an API from Commons Codec 1.9 which is not available in 1.10
anymore. A dependency version can be enforced by declaring it as strict it in
the build script:

Example 1. Setting a strict version

build.gradle

    
    
    dependencies {
        implementation 'org.apache.httpcomponents:httpclient:4.5.4'
        implementation('commons-codec:commons-codec') {
            version {
                strictly '1.9'
            }
        }
    }

build.gradle.kts

    
    
    dependencies {
        implementation("org.apache.httpcomponents:httpclient:4.5.4")
        implementation("commons-codec:commons-codec") {
            version {
                strictly("1.9")
            }
        }
    }

### Consequences of using strict versions

Using a strict version must be carefully considered, in particular by library
authors. As the _producer_ , a strict version will effectively behave like a
_force_ : the version declaration takes precedence over whatever is found in
the transitive dependency graph. In particular, a _strict version_ will
override any other _strict version_ on the same module found transitively.

However, for consumers, strict versions are still considered globally during
graph resolution and _may trigger an error_ if the consumer disagrees.

For example, imagine that your project `B` _strictly_ depends on `C:1.0`. Now,
a consumer, `A`, depends on both `B` and `C:1.1`.

Then this would trigger a resolution error because `A` says it needs `C:1.1`
but `B`, _within its subgraph_ , strictly needs `1.0`. This means that if you
choose a _single version_ in a strict constraint, then the version can _no
longer be upgraded_ , unless the consumer also sets a strict version
constraint on the same module.

In the example above, `A` would have to say it _strictly depends on 1.1_.

For this reason, a good practice is that if you use _strict versions_ , you
should express them in terms of ranges and a preferred version within this
range. For example, `B` might say, instead of `strictly 1.0`, that it
_strictly depends_ on the `[1.0, 2.0[` range, but _prefers_ `1.0`. Then if a
consumer chooses 1.1 (or any other version in the range), the build will _no
longer fail_ (constraints are resolved).

### Forced dependencies vs strict dependencies

__ |

Forcing dependencies via
[ExternalDependency.setForce(boolean)](../javadoc/org/gradle/api/artifacts/ExternalDependency.html#setForce-
boolean-) is deprecated and no longer recommended: forced dependencies suffer
an ordering issue which can be hard to diagnose and will not work well
together with other rich version constraints. You should prefer strict
versions instead. If you are authoring and publishing a
[library](library_vs_application.html), you also need to be aware that `force`
is **not** published.  
  
---|---  
  
If, for some reason, you can't use strict versions, you can force a dependency
doing this:

Example 2. Enforcing a dependency version

build.gradle

    
    
    dependencies {
        implementation 'org.apache.httpcomponents:httpclient:4.5.4'
        implementation('commons-codec:commons-codec:1.9') {
            force = true
        }
    }

build.gradle.kts

    
    
    dependencies {
        implementation("org.apache.httpcomponents:httpclient:4.5.4")
        implementation("commons-codec:commons-codec:1.9") {
            isForce = true
        }
    }

If the project requires a specific version of a dependency on a configuration-
level then it can be achieved by calling the method
[ResolutionStrategy.force(java.lang.Object[])](../dsl/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:force\(java.lang.Object\[\]\)).

Example 3. Enforcing a dependency version on the configuration-level

build.gradle

    
    
    configurations {
        compileClasspath {
            resolutionStrategy.force 'commons-codec:commons-codec:1.9'
        }
    }
    
    dependencies {
        implementation 'org.apache.httpcomponents:httpclient:4.5.4'
    }

build.gradle.kts

    
    
    configurations {
        "compileClasspath" {
            resolutionStrategy.force("commons-codec:commons-codec:1.9")
        }
    }
    
    dependencies {
        implementation("org.apache.httpcomponents:httpclient:4.5.4")
    }

## Excluding transitive dependencies

While the previous section showed how you can enforce a certain version of a
transitive dependency, this section covers _excludes_ as a way to remove a
transitive dependency completely.

__ |

Similar as forcing a version of a dependency, excluding a dependency
completely requires a conscious decision. Excluding a transitive dependency
might lead to runtime errors if external libraries do not properly function
without them. If you use excludes, make sure that you do not utilise any code
path requiring the excluded dependency by sufficient test coverage.  
  
---|---  
  
Transitive dependencies can be excluded on the level of a declared dependency.
Exclusions are spelled out as a key/value pair via the attributes `group`
and/or `module` as shown in the example below. For more information, refer to
[ModuleDependency.exclude(java.util.Map)](../javadoc/org/gradle/api/artifacts/ModuleDependency.html#exclude-
java.util.Map-).

Example 4. Excluding a transitive dependency for a particular dependency
declaration

build.gradle

    
    
    dependencies {
        implementation('commons-beanutils:commons-beanutils:1.9.4') {
            exclude group: 'commons-collections', module: 'commons-collections'
        }
    }

build.gradle.kts

    
    
    dependencies {
        implementation("commons-beanutils:commons-beanutils:1.9.4") {
            exclude(group = "commons-collections", module = "commons-collections")
        }
    }

In this example, we add a dependency to `commons-beanutils` but exclude the
transitive dependency `commons-collections`. In our code, shown below, we only
use one method from the beanutils library,
`PropertyUtils.setSimpleProperty()`. Using this method for existing setters
does not require any functionality from `commons-collections` as we verified
through test coverage.

Example 5. Using a utility from the beanutils library

src/main/java/Main.java

    
    
    import org.apache.commons.beanutils.PropertyUtils;
    
    public class Main {
        public static void main(String[] args) throws Exception {
            Object person = new Person();
            PropertyUtils.setSimpleProperty(person, "name", "Bart Simpson");
            PropertyUtils.setSimpleProperty(person, "age", 38);
        }
    }

Effectively, we are expressing that we only use a _subset_ of the library,
which does not require the `commons-collection` library. This can be seen as
implicitly defining a [feature variant](feature_variants.html) that has not
been explicitly declared by `commons-beanutils` itself. However, the risk of
breaking an untested code path increased by doing this.

For example, here we use the `setSimpleProperty()` method to modify properties
defined by setters in the `Person` class, which works fine. If we would
attempt to set a property not existing on the class, we _should_ get an error
like `Unknown property on class Person`. However, because the error handling
path uses a class from `commons-collections`, the error we now get is
`NoClassDefFoundError: org/apache/commons/collections/FastHashMap`. So if our
code would be more dynamic, and we would forget to cover the error case
sufficiently, consumers of our library might be confronted with unexpected
errors.

This is only an example to illustrate potential pitfalls. In practice, larger
libraries or frameworks can bring in a huge set of dependencies. If those
libraries fail to declare features separately and can only be consumed in a
"all or nothing" fashion, excludes can be a valid method to reduce the library
to the feature set actually required.

On the upside, Gradle's exclude handling is, in contrast to Maven, taking the
whole dependency graph into account. So if there are multiple dependencies on
a library, excludes are only exercised if all dependencies agree on them. For
example, if we add `opencsv` as another dependency to our project above, which
also depends on `commons-beanutils`, `commons-collection` is no longer
excluded as `opencsv` itself does **not** exclude it.

Example 6. Excludes only apply if all dependency declarations agree on an
exclude

build.gradle

    
    
        dependencies {
            implementation('commons-beanutils:commons-beanutils:1.9.4') {
                exclude group: 'commons-collections', module: 'commons-collections'
            }
            implementation 'com.opencsv:opencsv:4.6' // depends on 'commons-beanutils' without exclude and brings back 'commons-collections'
        }

build.gradle.kts

    
    
    dependencies {
        implementation("commons-beanutils:commons-beanutils:1.9.4") {
            exclude(group = "commons-collections", module = "commons-collections")
        }
        implementation("com.opencsv:opencsv:4.6") // depends on 'commons-beanutils' without exclude and brings back 'commons-collections'
    }

If we still want to have `commons-collections` excluded, because our combined
usage of `commons-beanutils` and `opencsv` does not need it, we need to
exclude it from the transitive dependencies of `opencsv` as well.

Example 7. Excluding a transitive dependency for multiple dependency
declaration

build.gradle

    
    
        dependencies {
            implementation('commons-beanutils:commons-beanutils:1.9.4') {
                exclude group: 'commons-collections', module: 'commons-collections'
            }
            implementation('com.opencsv:opencsv:4.6') {
                exclude group: 'commons-collections', module: 'commons-collections'
            }
        }

build.gradle.kts

    
    
        dependencies {
            implementation("commons-beanutils:commons-beanutils:1.9.4") {
                exclude(group = "commons-collections", module = "commons-collections")
            }
            implementation("com.opencsv:opencsv:4.6") {
                exclude(group = "commons-collections", module = "commons-collections")
            }
        }

Historically, excludes were also used as a band aid to fix other issues not
supported by some dependency management systems. Gradle however, offers a
variety of features that might be better suited to solve a certain use case.
You may consider to look into the following features:

  * Update or downgrade dependency versions: If versions of dependencies clash, it is usually better to adjust the version through a dependency constraint, instead of attempting to exclude the dependency with the undesired version.

  * [Component Metadata Rules](component_metadata_rules.html): If a library's metadata is clearly wrong, for example if it includes a compile time dependency which is never needed at compile time, a possible solution is to remove the dependency in a component metadata rule. By this, you tell Gradle that a dependency between two modules is never needed — i.e. the metadata was wrong — and therefore should **never** be considered. If you are developing a library, you have to be aware that this information is not published, and so sometimes an _exclude_ can be the better alternative.

  * [Resolving mutually exclusive dependency conflicts](dependency_capability_conflict.html): Another situation that you often see solved by excludes is that two dependencies cannot be used together because they represent two implementations of the same thing (the same [capability](dependency_capability_conflict.html#sub:capabilities)). A popular example are clashing logging API implementations (like `log4j` and `log4j-over-slf4j`) or modules that have different coordinates in different versions (like `com.google.collections` and `guava`). In this case, if this information is not known to Gradle, it is recommended to add the missing capability information via component metadata rules as described in the [declaring component capabilities](dependency_capability_conflict.html#sub:declaring-component-capabilities) section. Even if you are developing a library, and your consumers will have to deal with resolving the conflict again, it is often the right solution to leave the decision to the final consumers of libraries. I.e. you as a library author should not have to decide which logging implementation your consumers use in the end.

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

