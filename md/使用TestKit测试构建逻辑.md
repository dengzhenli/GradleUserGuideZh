

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Testing Build Logic with TestKit

version 6.9-20201126230040+0000

Contents

  * Usage
  * Functional testing with the Gradle runner
  * Getting the plugin-under-test into the test build
  * Controlling the build environment
  * The Gradle version used to test
  * Debugging build logic
  * Testing with the Build Cache

The Gradle TestKit (a.k.a. just TestKit) is a library that aids in testing
Gradle plugins and build logic generally. At this time, it is focused on
_functional_ testing. That is, testing build logic by exercising it as part of
a programmatically executed build. Over time, the TestKit will likely expand
to facilitate other kinds of tests.

## Usage

To use the TestKit, include the following in your plugin's build:

Example 1. Declaring the TestKit dependency

build.gradle

    
    
    dependencies {
        testImplementation gradleTestKit()
    }

build.gradle.kts

    
    
    dependencies {
        testImplementation(gradleTestKit())
    }

The `gradleTestKit()` encompasses the classes of the TestKit, as well as the
[Gradle Tooling API client](third_party_integration.html#embedding). It does
not include a version of [JUnit](http://junit.org),
[TestNG](http://testng.org), or any other test execution framework. Such a
dependency must be explicitly declared.

Example 2. Declaring the JUnit dependency

build.gradle

    
    
    dependencies {
        testImplementation 'junit:junit:4.13'
    }

build.gradle.kts

    
    
    dependencies {
        testImplementation("junit:junit:4.13")
    }

## Functional testing with the Gradle runner

The [GradleRunner](../javadoc/org/gradle/testkit/runner/GradleRunner.html)
facilitates programmatically executing Gradle builds, and inspecting the
result.

A contrived build can be created (e.g. programmatically, or from a template)
that exercises the “logic under test”. The build can then be executed,
potentially in a variety of ways (e.g. different combinations of tasks and
arguments). The correctness of the logic can then be verified by asserting the
following, potentially in combination:

  * The build's output;

  * The build's logging (i.e. console output);

  * The set of tasks executed by the build and their results (e.g. FAILED, UP-TO-DATE etc.).

After creating and configuring a runner instance, the build can be executed
via the
[GradleRunner.build()](../javadoc/org/gradle/testkit/runner/GradleRunner.html#build--)
or
[GradleRunner.buildAndFail()](../javadoc/org/gradle/testkit/runner/GradleRunner.html#buildAndFail--)
methods depending on the anticipated outcome.

The following demonstrates the usage of the Gradle runner in a Java JUnit
test:

### Example: Using GradleRunner with Java and JUnit

BuildLogicFunctionalTest.java

    
    
    import org.gradle.testkit.runner.BuildResult;
    import org.gradle.testkit.runner.GradleRunner;
    import org.junit.Before;
    import org.junit.Rule;
    import org.junit.Test;
    import org.junit.rules.TemporaryFolder;
    
    import java.io.BufferedWriter;
    import java.io.File;
    import java.io.FileWriter;
    import java.io.IOException;
    import java.util.Collections;
    
    import static org.junit.Assert.assertEquals;
    import static org.junit.Assert.assertTrue;
    
    import static org.gradle.testkit.runner.TaskOutcome.*;
    
    public class BuildLogicFunctionalTest {
        @Rule public final TemporaryFolder testProjectDir = new TemporaryFolder();
        private File settingsFile;
        private File buildFile;
    
        @Before
        public void setup() throws IOException {
            settingsFile = testProjectDir.newFile("settings.gradle");
            buildFile = testProjectDir.newFile("build.gradle");
        }
    
        @Test
        public void testHelloWorldTask() throws IOException {
            writeFile(settingsFile, "rootProject.name = 'hello-world'");
            String buildFileContent = "task helloWorld {" +
                                      "    doLast {" +
                                      "        println 'Hello world!'" +
                                      "    }" +
                                      "}";
            writeFile(buildFile, buildFileContent);
    
            BuildResult result = GradleRunner.create()
                .withProjectDir(testProjectDir.getRoot())
                .withArguments("helloWorld")
                .build();
    
            assertTrue(result.getOutput().contains("Hello world!"));
            assertEquals(SUCCESS, result.task(":helloWorld").getOutcome());
        }
    
        private void writeFile(File destination, String content) throws IOException {
            BufferedWriter output = null;
            try {
                output = new BufferedWriter(new FileWriter(destination));
                output.write(content);
            } finally {
                if (output != null) {
                    output.close();
                }
            }
        }
    }

The following demonstrates the usage of the Gradle runner in a Kotlin JUnit
test:

### Example: Using GradleRunner with Kotlin and JUnit

BuildLogicFunctionalTest.kt

    
    
    import org.gradle.testkit.runner.BuildResult
    import org.gradle.testkit.runner.GradleRunner
    import org.gradle.testkit.runner.TaskOutcome
    import org.junit.Assert.assertEquals
    import org.junit.Assert.assertTrue
    import org.junit.Before
    import org.junit.Rule
    import org.junit.Test
    import org.junit.rules.TemporaryFolder
    import kotlin.jvm.JvmField
    import java.io.File
    
    class BuildLogicFunctionalTest {
    
        @Rule @JvmField
        val testProjectDir: TemporaryFolder = TemporaryFolder()
        private lateinit var settingsFile: File
        private lateinit var buildFile: File
    
        @Before
        fun setup() {
            settingsFile = testProjectDir.newFile("settings.gradle.kts")
            buildFile = testProjectDir.newFile("build.gradle.kts")
        }
    
        @Test
        fun `test helloWorld task`() {
    
            settingsFile.writeText("""
                rootProject.name = "hello-world"
            """.trimIndent())
            buildFile.writeText("""
                tasks.register("helloWorld") {
                    doLast {
                        println("Hello world!")
                    }
                }
            """.trimIndent())
    
            val result = GradleRunner.create()
                .withProjectDir(testProjectDir.root)
                .withArguments("helloWorld")
                .build()
    
            assertTrue(result.output.contains("Hello world!"))
            assertEquals(TaskOutcome.SUCCESS, result.task(":helloWorld")?.outcome)
        }
    }

Any test execution framework can be used.

As Gradle build scripts can also be written in the Groovy programming
language, it is often a productive choice to write Gradle functional tests in
Groovy. Furthermore, it is recommended to use the (Groovy based) [Spock test
execution framework](https://code.google.com/p/spock/) as it offers many
compelling features over the use of JUnit.

The following demonstrates the usage of the Gradle runner in a Groovy Spock
test:

### Example: Using GradleRunner with Groovy and Spock

BuildLogicFunctionalTest.groovy

    
    
    import org.gradle.testkit.runner.GradleRunner
    import static org.gradle.testkit.runner.TaskOutcome.*
    import org.junit.Rule
    import org.junit.rules.TemporaryFolder
    import spock.lang.Specification
    
    class BuildLogicFunctionalTest extends Specification {
        @Rule TemporaryFolder testProjectDir = new TemporaryFolder()
        File settingsFile
        File buildFile
    
        def setup() {
            settingsFile = testProjectDir.newFile('settings.gradle')
            buildFile = testProjectDir.newFile('build.gradle')
        }
    
        def "hello world task prints hello world"() {
            given:
            settingsFile << "rootProject.name = 'hello-world'"
            buildFile << """
                task helloWorld {
                    doLast {
                        println 'Hello world!'
                    }
                }
            """
    
            when:
            def result = GradleRunner.create()
                .withProjectDir(testProjectDir.root)
                .withArguments('helloWorld')
                .build()
    
            then:
            result.output.contains('Hello world!')
            result.task(":helloWorld").outcome == SUCCESS
        }
    }

It is a common practice to implement any custom build logic (like plugins and
task types) that is more complex in nature as external classes in a standalone
project. The main driver behind this approach is bundle the compiled code into
a JAR file, publish it to a binary repository and reuse it across various
projects.

## Getting the plugin-under-test into the test build

The GradleRunner uses the [Tooling
API](third_party_integration.html#embedding) to execute builds. An implication
of this is that the builds are executed in a separate process (i.e. not the
same process executing the tests). Therefore, the test build does not share
the same classpath or classloaders as the test process and the code under test
is not implicitly available to the test build.

Starting with version 2.13, Gradle provides a conventional mechanism to inject
the code under test into the test build.

### Automatic injection with the Java Gradle Plugin Development plugin

The [Java Gradle Plugin development
plugin](java_gradle_plugin.html#java_gradle_plugin) can be used to assist in
the development of Gradle plugins. Starting with Gradle version 2.13, the
plugin provides a direct integration with TestKit. When applied to a project,
the plugin automatically adds the `gradleTestKit()` dependency to the test
compile configuration. Furthermore, it automatically generates the classpath
for the code under test and injects it via
[GradleRunner.withPluginClasspath()](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath--)
for any `GradleRunner` instance created by the user. It's important to note
that the mechanism currently _only_ works if the plugin under test is applied
using the [plugins DSL](plugins.html#sec:plugins_block). If the target Gradle
version is prior to 2.8, automatic plugin classpath injection is not
performed.

The plugin uses the following conventions for applying the TestKit dependency
and injecting the classpath:

  * Source set containing code under test: `sourceSets.main`

  * Source set used for injecting the plugin classpath: `sourceSets.test`

Any of these conventions can be reconfigured with the help of the class
[GradlePluginDevelopmentExtension](../javadoc/org/gradle/plugin/devel/GradlePluginDevelopmentExtension.html).

The following Groovy-based sample demonstrates how to automatically inject the
plugin classpath by using the standard conventions applied by the Java Gradle
Plugin Development plugin.

Example 3. Using the Java Gradle Development plugin for generating the plugin
metadata

build.gradle

    
    
    plugins {
        id 'groovy'
        id 'java-gradle-plugin'
    }
    
    dependencies {
        testImplementation('org.spockframework:spock-core:1.3-groovy-2.4') {
            exclude module: 'groovy-all'
        }
    }

build.gradle.kts

    
    
    plugins {
        groovy
        `java-gradle-plugin`
    }
    
    dependencies {
        testImplementation("org.spockframework:spock-core:1.3-groovy-2.4") {
            exclude(module = "groovy-all")
        }
    }

### Example: Automatically injecting the code under test classes into test
builds

src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy

    
    
    def "hello world task prints hello world"() {
        given:
        settingsFile << "rootProject.name = 'hello-world'"
        buildFile << """
            plugins {
                id 'org.gradle.sample.helloworld'
            }
        """
    
        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.root)
            .withArguments('helloWorld')
            .withPluginClasspath()
            .build()
    
        then:
        result.output.contains('Hello world!')
        result.task(":helloWorld").outcome == SUCCESS
    }

The following build script demonstrates how to reconfigure the conventions
provided by the Java Gradle Plugin Development plugin for a project that uses
a custom `Test` source set.

Example 4. Reconfiguring the classpath generation conventions of the Java
Gradle Development plugin

build.gradle

    
    
    plugins {
        id 'groovy'
        id 'java-gradle-plugin'
    }
    
    sourceSets {
        functionalTest {
            groovy {
                srcDir file('src/functionalTest/groovy')
            }
            resources {
                srcDir file('src/functionalTest/resources')
            }
            compileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath
            runtimeClasspath += output + compileClasspath
        }
    }
    
    task functionalTest(type: Test) {
        testClassesDirs = sourceSets.functionalTest.output.classesDirs
        classpath = sourceSets.functionalTest.runtimeClasspath
    }
    
    check.dependsOn functionalTest
    
    gradlePlugin {
        testSourceSets sourceSets.functionalTest
    }
    
    dependencies {
        functionalTestImplementation('org.spockframework:spock-core:1.3-groovy-2.4') {
            exclude module: 'groovy-all'
        }
    }

build.gradle.kts

    
    
    plugins {
        groovy
        `java-gradle-plugin`
    }
    
    sourceSets {
        create("functionalTest") {
            withConvention(GroovySourceSet::class) {
                groovy {
                    srcDir(file("src/functionalTest/groovy"))
                }
            }
            resources {
                srcDir(file("src/functionalTest/resources"))
            }
            compileClasspath += sourceSets.main.get().output + configurations.testRuntimeClasspath
            runtimeClasspath += output + compileClasspath
        }
    }
    
    tasks.register<Test>("functionalTest") {
        testClassesDirs = sourceSets["functionalTest"].output.classesDirs
        classpath = sourceSets["functionalTest"].runtimeClasspath
    }
    
    tasks.check { dependsOn(tasks["functionalTest"]) }
    
    gradlePlugin {
        testSourceSets(sourceSets["functionalTest"])
    }
    
    dependencies {
        "functionalTestImplementation"("org.spockframework:spock-core:1.3-groovy-2.4") {
            exclude(module = "groovy-all")
        }
    }

### Working with Gradle versions prior to 2.13

For earlier versions of Gradle (before 2.13), it is possible to manually make
the code under test available via some extra configuration. The following
example demonstrates having the build generate a file containing the
implementation classpath of the code under test, and making it available at
test runtime.

Example 5. Making the code under test classpath available to the tests

build.gradle

    
    
    // Write the plugin's classpath to a file to share with the tests
    task createClasspathManifest {
        def outputDir = file("$buildDir/$name")
    
        inputs.files(sourceSets.main.runtimeClasspath)
            .withPropertyName("runtimeClasspath")
            .withNormalizer(ClasspathNormalizer)
        outputs.dir(outputDir)
            .withPropertyName("outputDir")
    
        doLast {
            outputDir.mkdirs()
            file("$outputDir/plugin-classpath.txt").text = sourceSets.main.runtimeClasspath.join("\n")
        }
    }
    
    // Add the classpath file to the test runtime classpath
    dependencies {
        testRuntimeOnly files(createClasspathManifest)
    }

build.gradle.kts

    
    
    // Write the plugin's classpath to a file to share with the tests
    tasks.register("createClasspathManifest") {
        val outputDir = file("$buildDir/$name")
    
        inputs.files(sourceSets.main.get().runtimeClasspath)
            .withPropertyName("runtimeClasspath")
            .withNormalizer(ClasspathNormalizer::class)
        outputs.dir(outputDir)
            .withPropertyName("outputDir")
    
        doLast {
            outputDir.mkdirs()
            file("$outputDir/plugin-classpath.txt").writeText(sourceSets.main.get().runtimeClasspath.joinToString("\n"))
        }
    }
    
    // Add the classpath file to the test runtime classpath
    dependencies {
        testRuntimeOnly(files(tasks["createClasspathManifest"]))
    }

The tests can then read this value, and inject the classpath into the test
build by using the method
[GradleRunner.withPluginClasspath(java.lang.Iterable)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-
java.lang.Iterable-). This classpath is then available to use to locate
plugins in a test build via the plugins DSL (see
[Plugins](plugins.html#plugins)). Applying plugins with the plugins DSL
requires the definition of a plugin identifier. The following is an example
(in Groovy) of doing this from within a Spock Framework `setup()` method,
which is analogous to a JUnit `@Before` method.

### Example: Injecting the code under test classes into test builds

src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy

    
    
        List<File> pluginClasspath
    
        def setup() {
            settingsFile = testProjectDir.newFile('settings.gradle')
            buildFile = testProjectDir.newFile('build.gradle')
    
            def pluginClasspathResource = getClass().classLoader.findResource("plugin-classpath.txt")
            if (pluginClasspathResource == null) {
                throw new IllegalStateException("Did not find plugin classpath resource, run `testClasses` build task.")
            }
    
            pluginClasspath = pluginClasspathResource.readLines().collect { new File(it) }
        }
    
        def "hello world task prints hello world"() {
            given:
            buildFile << """
                plugins {
                    id 'org.gradle.sample.helloworld'
                }
            """
    
            when:
            def result = GradleRunner.create()
                .withProjectDir(testProjectDir.root)
                .withArguments('helloWorld')
                .withPluginClasspath(pluginClasspath)
                .build()
    
            then:
            result.output.contains('Hello world!')
            result.task(":helloWorld").outcome == SUCCESS
        }

This approach works well when executing the functional tests as part of the
Gradle build. When executing the functional tests from an IDE, there are extra
considerations. Namely, the classpath manifest file points to the class files
etc. generated by Gradle and not the IDE. This means that after making a
change to the source of the code under test, the source must be recompiled by
Gradle. Similarly, if the effective classpath of the code under test changes,
the manifest must be regenerated. In either case, executing the `testClasses`
task of the build will ensure that things are up to date.

Some IDEs provide a convenience option to delegate the "test classpath
generation and execution" to the build. In IntelliJ you can find this option
under Preferences…​ > Build, Execution, Deployment > Build Tools > Gradle >
Runner > Delegate IDE build/run actions to gradle. Please consult the
documentation of your IDE for more information.

### Working with Gradle versions prior to 2.8

The
[GradleRunner.withPluginClasspath(java.lang.Iterable)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-
java.lang.Iterable-) method will not work when executing the build with a
Gradle version earlier than 2.8 (see The version used to test), as this
feature is not supported on such Gradle versions.

Instead, the code must be injected via the build script itself. The following
sample demonstrates how this can be done.

### Example: Injecting the code under test classes into test builds for Gradle
versions prior to 2.8

src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy

    
    
        List<File> pluginClasspath
    
        def setup() {
            settingsFile = testProjectDir.newFile('settings.gradle')
            buildFile = testProjectDir.newFile('build.gradle')
    
            def pluginClasspathResource = getClass().classLoader.findResource("plugin-classpath.txt")
            if (pluginClasspathResource == null) {
                throw new IllegalStateException("Did not find plugin classpath resource, run `testClasses` build task.")
            }
    
            pluginClasspath = pluginClasspathResource.readLines().collect { new File(it) }
        }
    
        def "hello world task prints hello world with pre Gradle 2.8"() {
            given:
            def classpathString = pluginClasspath
                .collect { it.absolutePath.replace('\\', '\\\\') } // escape backslashes in Windows paths
                .collect { "'$it'" }
                .join(", ")
    
            buildFile << """
                buildscript {
                    dependencies {
                        classpath files($classpathString)
                    }
                }
                apply plugin: "org.gradle.sample.helloworld"
            """
    
            when:
            def result = GradleRunner.create()
                .withProjectDir(testProjectDir.root)
                .withArguments('helloWorld')
                .withGradleVersion("2.7")
                .build()
    
            then:
            result.output.contains('Hello world!')
            result.task(":helloWorld").outcome == SUCCESS
        }

## Controlling the build environment

The runner executes the test builds in an isolated environment by specifying a
dedicated "working directory" in a directory inside the JVM's temp directory
(i.e. the location specified by the `java.io.tmpdir` system property,
typically `/tmp`). Any configuration in the default Gradle user home directory
(e.g. `~/.gradle/gradle.properties`) is not used for test execution. The
TestKit does not expose a mechanism for fine grained control of all aspects of
the environment (e.g., JDK). Future versions of the TestKit will provide
improved configuration options.

The TestKit uses dedicated daemon processes that are automatically shut down
after test execution.

## The Gradle version used to test

The Gradle runner requires a Gradle distribution in order to execute the
build. The TestKit does not depend on all of Gradle's implementation.

By default, the runner will attempt to find a Gradle distribution based on
where the `GradleRunner` class was loaded from. That is, it is expected that
the class was loaded from a Gradle distribution, as is the case when using the
`gradleTestKit()` dependency declaration.

When using the runner as part of tests _being executed by Gradle_ (e.g.
executing the `test` task of a plugin project), the same distribution used to
execute the tests will be used by the runner. When using the runner as part of
tests _being executed by an IDE_ , the same distribution of Gradle that was
used when importing the project will be used. This means that the plugin will
effectively be tested with the same version of Gradle that it is being built
with.

Alternatively, a different and specific version of Gradle to use can be
specified by the any of the following `GradleRunner` methods:

  * [GradleRunner.withGradleVersion(java.lang.String)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleVersion-java.lang.String-)

  * [GradleRunner.withGradleInstallation(java.io.File)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleInstallation-java.io.File-)

  * [GradleRunner.withGradleDistribution(java.net.URI)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleDistribution-java.net.URI-)

This can potentially be used to test build logic across Gradle versions. The
following demonstrates a cross-version compatibility test written as Groovy
Spock test:

### Example: Specifying a Gradle version for test execution

BuildLogicFunctionalTest.groovy

    
    
    import org.gradle.testkit.runner.GradleRunner
    import static org.gradle.testkit.runner.TaskOutcome.*
    import org.junit.Rule
    import org.junit.rules.TemporaryFolder
    import spock.lang.Specification
    import spock.lang.Unroll
    
    class BuildLogicFunctionalTest extends Specification {
        @Rule final TemporaryFolder testProjectDir = new TemporaryFolder()
        File settingsFile
        File buildFile
    
        def setup() {
            settingsFile = testProjectDir.newFile('settings.gradle')
            buildFile = testProjectDir.newFile('build.gradle')
        }
    
        @Unroll
        def "can execute hello world task with Gradle version #gradleVersion"() {
            given:
            buildFile << """
                task helloWorld {
                    doLast {
                        logger.quiet 'Hello world!'
                    }
                }
            """
    
            when:
            def result = GradleRunner.create()
                .withGradleVersion(gradleVersion)
                .withProjectDir(testProjectDir.root)
                .withArguments('helloWorld')
                .build()
    
            then:
            result.output.contains('Hello world!')
            result.task(":helloWorld").outcome == SUCCESS
    
            where:
            gradleVersion << ['2.6', '2.7']
        }
    }

### Feature support when testing with different Gradle versions

It is possible to use the GradleRunner to execute builds with Gradle 1.0 and
later. However, some runner features are not supported on earlier versions. In
such cases, the runner will throw an exception when attempting to use the
feature.

The following table lists the features that are sensitive to the Gradle
version being used.

Table 1. Gradle version compatibility Feature | Minimum Version | Description  
---|---|---  
  
Inspecting executed tasks

|

2.5

|

Inspecting the executed tasks, using
[BuildResult.getTasks()](../javadoc/org/gradle/testkit/runner/BuildResult.html#getTasks--)
and similar methods.  
  
Plugin classpath injection

|

2.8

|

Injecting the code under test
via[GradleRunner.withPluginClasspath(java.lang.Iterable)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-
java.lang.Iterable-).  
  
Inspecting build output in debug mode

|

2.9

|

Inspecting the build's text output when run in debug mode, using
[BuildResult.getOutput()](../javadoc/org/gradle/testkit/runner/BuildResult.html#getOutput--).  
  
Automatic plugin classpath injection

|

2.13

|

Injecting the code under test automatically via
[GradleRunner.withPluginClasspath()](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath--)
by applying the Java Gradle Plugin Development plugin.  
  
Setting environment variables to be used by the build.

|

3.5

|

The Gradle Tooling API only supports setting environment variables in later
versions.  
  
## Debugging build logic

The runner uses the [Tooling API](third_party_integration.html#embedding) to
execute builds. An implication of this is that the builds are executed in a
separate process (i.e. not the same process executing the tests). Therefore,
executing your _tests_ in debug mode does not allow you to debug your build
logic as you may expect. Any breakpoints set in your IDE will be not be
tripped by the code being exercised by the test build.

The TestKit provides two different ways to enable the debug mode:

  * Setting “`org.gradle.testkit.debug`” system property to `true` for the JVM _using_ the `GradleRunner` (i.e. not the build being executed with the runner);

  * Calling the [GradleRunner.withDebug(boolean)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withDebug-boolean-) method.

The system property approach can be used when it is desirable to enable
debugging support without making an adhoc change to the runner configuration.
Most IDEs offer the capability to set JVM system properties for test
execution, and such a feature can be used to set this system property.

## Testing with the Build Cache

To enable the [Build Cache](build_cache.html#build_cache) in your tests, you
can pass the `--build-cache` argument to
[GradleRunner](../javadoc/org/gradle/testkit/runner/GradleRunner.html) or use
one of the other methods described in [Enable the build
cache](build_cache.html#sec:build_cache_enable). You can then check for the
task outcome
[TaskOutcome.FROM_CACHE](../javadoc/org/gradle/testkit/runner/TaskOutcome.html#FROM_CACHE)
when your plugin's custom task is cached. This outcome is only valid for
Gradle 3.5 and newer.

### Example: Testing cacheable tasks

BuildLogicFunctionalTest.groovy

    
    
    def "cacheableTask is loaded from cache"() {
        given:
        buildFile << """
            plugins {
                id 'org.gradle.sample.helloworld'
            }
        """
    
        when:
        def result = runner()
            .withArguments( '--build-cache', 'cacheableTask')
            .build()
    
        then:
        result.task(":cacheableTask").outcome == SUCCESS
    
        when:
        new File(testProjectDir.root, 'build').deleteDir()
        result = runner()
            .withArguments( '--build-cache', 'cacheableTask')
            .build()
    
        then:
        result.task(":cacheableTask").outcome == FROM_CACHE
    }

Note that TestKit re-uses a Gradle user home between tests (see
[GradleRunner.withTestKitDir(java.io.File)](../javadoc/org/gradle/testkit/runner/GradleRunner.html#withTestKitDir-
java.io.File-)) which contains the default location for the local build cache.
For testing with the build cache, the build cache directory should be cleaned
between tests. The easiest way to accomplish this is to configure the local
build cache to use a temporary directory.

### Example: Clean build cache between tests

BuildLogicFunctionalTest.groovy

    
    
    @Rule final TemporaryFolder testProjectDir = new TemporaryFolder()
    File buildFile
    File localBuildCacheDirectory
    
    def setup() {
        localBuildCacheDirectory = testProjectDir.newFolder('local-cache')
        testProjectDir.newFile('settings.gradle') << """
            buildCache {
                local {
                    directory '${localBuildCacheDirectory.toURI()}'
                }
            }
        """
        buildFile = testProjectDir.newFile('build.gradle')
    }

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

