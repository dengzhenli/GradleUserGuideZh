# 了解库和应用程序之间的区别


内容

  * [生产者与消费者](#sub:producers-vs-consumers)
  * [生产者变体](#sub:producer-variants)
  * [强大的封装](#sub:strong-encapsulation)
  * [尊重消费者](#sub:being-respectful-consumers)

## [](#sub:producers-vs-consumers)[生产者与消费者](#sub:producers-vs-consumers)

Gradle依赖管理中的一个关键概念是在消费者和生产者之间产生差异。

当你 _建立_ 一个库，有效地都在 _制片_ 方：你是生产 _的工件_ ，其将要 _消耗_ 别人的 _消费_ 。

传统构建系统存在很多问题，即它们无法在生产者和消费者之间发挥作用。

一个 _消费者_ 需要在很大意义上被理解：

  * 一个依赖于另一个项目的项目是一个 _消费者_

  * 依赖人工制品的 _任务_ 是更细粒度的消费者

在依赖管理，有很多值得我们做出的决定取决于项目我们正在建设的，也就是说类型，[什么样的 _消费者_，我们是](#sub:being-respectful-consumers)。

## [](#sub:producer-variants)[生产者变体](#sub:producer-variants)

生产者可能想为不同种类的消费者生成不同的工件：对于相同的源代码，会产生不同的 _二进制文件_
。或者，一个项目可能会产生供其他项目（相同存储库）使用但不能供外部使用的工件。

Java世界中的一个典型示例是Guava库，它以不同的版本发布：一个用于Java项目，一个用于Android项目。

但是，消费者的责任是告知要使用的版本，而依赖管理引擎的责任是确保 _图形的一致性_ （例如，确保在类路径中不使用Guava的Java和Android版本）
。这就是Gradle[变体模型](https://docs.gradle.org/6.7.1/userguide/variant_model.html)发挥作用的地方。

在Gradle中， _生产者变体_
通过[耗材配置](https://docs.gradle.org/6.7.1/userguide/declaring_dependencies.html#sec:resolvable-consumable-configs)公开。

## [](#sub:strong-encapsulation)[强大的封装](#sub:strong-encapsulation)

为了使生产者能够编译库，它需要所有 _实现依赖_ 于编译类路径。存在仅 _作为_ 库 _的实现细节_ 所需的依赖关系，并且某些库实际上是API的一部分。

但是， _依赖_ 于此生成的库的库仅需要“查看”库的公共API，因此也可以“查看”该API的依赖项。它是生产方的编译类路径的子集：这是对依赖性的强封装。

结果是，分配给`implementation`库配置的依赖项 _不会最终出现在使用者的编译类路径上_ 。另一方面，分配给`api`库配置的依赖项
_将最终出现在使用者的编译类路径上_ 。但是，在 _运行时_
，需要所有依赖项。即使在单个项目中，Gradle也会在不同类型的使用者之间产生差异：例如，Java编译任务与Java exec任务是不同的使用者。

在Java世界[中可以找到](https://docs.gradle.org/6.7.1/userguide/java_library_plugin.html)有关API和运行时依赖项分离的更多详细信息。

## [](#sub:being-respectful-consumers)[尊重消费者](#sub:being-respectful-consumers)

每当作为开发人员，您决定包括依赖项时，您必须了解 _对消费者有影响_ 。例如，如果将依赖项添加到项目中，则它将成为使用者的可 _传递依赖_
项，因此，如果使用者需要其他版本，则可能会参与冲突解决。

Gradle处理的许多问题都与解决消费者和生产者的期望之间的不匹配有关。

但是，某些项目比其他项目容易：

  * 如果您处于消费链的末端，也就是说您正在构建一个 _应用程序_ ，那么实际上 _没有_ 项目的 _使用者_ （最终用户[除外](https://docs.gradle.org/6.7.1/userguide/dependency_downgrade_and_exclude.html#sec:excluding-transitive-deps)）：添加[排除项](https://docs.gradle.org/6.7.1/userguide/dependency_downgrade_and_exclude.html#sec:excluding-transitive-deps)只会解决您的问题。

  * 但是，如果您是Library，则添加[排除项](https://docs.gradle.org/6.7.1/userguide/dependency_downgrade_and_exclude.html#sec:excluding-transitive-deps)可能会阻止使用者正常工作，因为他们会使用您不喜欢的代码路径

始终牢记，您选择解决问题的解决方案可能会“泄漏”给您的消费者。本文档旨在指导您找到正确问题的正确解决方案，更重要的是，制定有助于决策引擎在发生冲突时做出正确决策的决策。

