# 了解库和应用程序之间的区别


内容

  * [生产者与消费者](#生产者与消费者)
  * [生产者变体](#生产者变体)
  * [强大的封装](#强大的封装)
  * [尊重消费者](#尊重消费者)

## [生产者与消费者](#生产者与消费者)



在Gradle的依赖性管理中，一个关键的概念是区分消费者和生产者。  

当你构建一个库时，你实际上是在生产者一方：你生产的工件将被其他人，即消费者消费。  

传统的构建系统有很多问题，就是没有把生产者和消费者区分开来。  

消费者需要从大的意义上理解。  

   * 依赖于另一个项目的项目是一个消费者。

   * 工欲善其事，必先利其器

在依赖性管理中，我们做的很多决策都取决于我们建设的项目类型（或者说，我们是什么样的消费者）。  


## [生产者变体](#生产者变体)


生产者可能希望为不同的消费者生产不同的产品：对于相同的源代码，生产不同的二进制文件。
或者，一个项目可能会生成供其他项目（同一仓库）使用的工件，但不供外部使用。  

Java世界的一个典型例子是Guava库，它以不同的版本发布：一个供Java项目使用，一个供Android项目使用。  

然而，告诉消费者使用什么版本是消费者的责任，而确保图的一致性是依赖管理引擎的责任
（例如确保你的classpath上不会同时有Java和Android版本的Guava）。
这就是Gradle的[变体模型](/md/使用变体属性.md) 发挥作用的地方。  
 
在Gradle中，生产者变体是通过[可消耗配置](/md/声明依赖.md#可解析和消耗性配置) 来暴露的。  



## [强大的封装](#强大的封装)


为了让生产者编译一个库，它需要编译classpath上的所有实现依赖。
有的依赖项只是作为库的实现细节而需要，有的库实际上是API的一部分。  

然而，依赖于这个产生的库的库只需要 "看到 "你的库的公共API，因此需要看到这个API的依赖。
它是生产者的编译classpath的子集：这是对依赖关系的强封装。  

其结果是，一个被分配给库的实现配置的依赖关系不会最终出现在消费者的编译classpath上。
另一方面，分配给库的api配置的依赖关系会最终出现在消费者的编译classpath上。
然而，在运行时，所有的依赖关系都是必需的。
Gradle甚至在一个项目中对不同类型的消费者进行了区分：例如，Java编译任务与Java exec任务是不同的消费者。  

更多关于Java世界中API和运行时依赖的隔离的细节可以在[这里](/md/Java库插件.md) 找到。  


## [尊重消费者](#尊重消费者)

每当作为开发人员，您决定包括依赖项时，您必须了解 _对消费者有影响_ 。
例如，如果将依赖项添加到项目中，则它将成为使用者的可 _传递依赖_
项，因此，如果使用者需要其他版本，则可能会参与冲突解决。

Gradle处理的许多问题都与解决消费者和生产者的期望之间的不匹配有关。

但是，某些项目比其他项目容易：

  * 如果您处于消费链的末端，也就是说您正在构建一个 _应用程序_ ，那么实际上 _没有_ 项目的 _使用者_ （最终用户[除外](/md/降级版本并排除依赖项.md#排除传递依赖)）：
  添加[排除项](/md/降级版本并排除依赖项.md#排除传递依赖)只会解决您的问题。

  * 但是，如果您是Library，则添加[排除项](/md/降级版本并排除依赖项.md#排除传递依赖)可能会阻止使用者正常工作，因为他们会使用您不喜欢的代码路径

始终牢记，您选择解决问题的解决方案可能会“泄漏”给您的消费者。本文档旨在指导您找到正确问题的正确解决方案，更重要的是，制定有助于决策引擎在发生冲突时做出正确决策的决策。

