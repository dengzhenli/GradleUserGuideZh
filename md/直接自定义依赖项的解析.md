

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Customizing resolution of a dependency directly

version 6.7.1

Contents

  * Using dependency resolve rules
  * Using module replacement rules
  * Using dependency substitution rules
  * Disabling transitive resolution
  * Changing configuration dependencies prior to resolution
  * Setting default configuration dependencies
  * Excluding a dependency from a configuration completely
  * Matching dependencies to repositories
  * Enabling Ivy dynamic resolve mode

__ |

This section covers mechanisms Gradle offers to directly influence the
behavior of the dependency resolution engine. In contrast to the other
concepts covered in this chapter, like [dependency
constraints](dependency_constraints.html) or [component metadata
rules](component_metadata_rules.html), which are all **inputs** to resolution,
the following mechanisms allow you to write rules which are directly injected
into the resolution engine. Because of this, they can be seen as _brute force_
solutions, that may hide future problems (e.g. if new dependencies are added).
Therefore, the general advice is to only use the following mechanisms if other
means are not sufficient. If you are authoring a
[library](library_vs_application.html), you should always prefer [dependency
constraints](dependency_constraints.html) as they are published for your
consumers.  
  
---|---  
  
## Using dependency resolve rules

A dependency resolve rule is executed for each resolved dependency, and offers
a powerful api for manipulating a requested dependency prior to that
dependency being resolved. The feature currently offers the ability to change
the group, name and/or version of a requested dependency, allowing a
dependency to be substituted with a completely different module during
resolution.

Dependency resolve rules provide a very powerful way to control the dependency
resolution process, and can be used to implement all sorts of advanced
patterns in dependency management. Some of these patterns are outlined below.
For more information and code samples see the
[ResolutionStrategy](../dsl/org.gradle.api.artifacts.ResolutionStrategy.html)
class in the API documentation.

### Implementing a custom versioning scheme

In some corporate environments, the list of module versions that can be
declared in Gradle builds is maintained and audited externally. Dependency
resolve rules provide a neat implementation of this pattern:

  * In the build script, the developer declares dependencies with the module group and name, but uses a placeholder version, for example: `default`.

  * The `default` version is resolved to a specific version via a dependency resolve rule, which looks up the version in a corporate catalog of approved modules.

This rule implementation can be neatly encapsulated in a corporate plugin, and
shared across all builds within the organisation.

Example 1. Using a custom versioning scheme

build.gradle

    
    
    configurations.all {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.version == 'default') {
                def version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)
                details.useVersion version.version
                details.because version.because
            }
        }
    }
    
    def findDefaultVersionInCatalog(String group, String name) {
        //some custom logic that resolves the default version into a specific version
        [version: "1.0", because: 'tested by QA']
    }

build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.eachDependency {
            if (requested.version == "default") {
                val version = findDefaultVersionInCatalog(requested.group, requested.name)
                useVersion(version.version)
                because(version.because)
            }
        }
    }
    
    data class DefaultVersion(val version: String, val because: String)
    
    fun findDefaultVersionInCatalog(group: String, name: String): DefaultVersion {
        //some custom logic that resolves the default version into a specific version
        return DefaultVersion(version = "1.0", because = "tested by QA")
    }

### Denying a particular version with a replacement

Dependency resolve rules provide a mechanism for denying a particular version
of a dependency and providing a replacement version. This can be useful if a
certain dependency version is broken and should not be used, where a
dependency resolve rule causes this version to be replaced with a known good
version. One example of a broken module is one that declares a dependency on a
library that cannot be found in any of the public repositories, but there are
many other reasons why a particular module version is unwanted and a different
version is preferred.

In example below, imagine that version `1.2.1` contains important fixes and
should always be used in preference to `1.2`. The rule provided will enforce
just this: any time version `1.2` is encountered it will be replaced with
`1.2.1`. Note that this is different from a forced version as described above,
in that any other versions of this module would not be affected. This means
that the 'newest' conflict resolution strategy would still select version
`1.3` if this version was also pulled transitively.

Example 2. Example: Blacklisting a version with a replacement

build.gradle

    
    
    configurations.all {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.group == 'org.software' && details.requested.name == 'some-library' && details.requested.version == '1.2') {
                details.useVersion '1.2.1'
                details.because 'fixes critical bug in 1.2'
            }
        }
    }

build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.eachDependency {
            if (requested.group == "org.software" && requested.name == "some-library" && requested.version == "1.2") {
                useVersion("1.2.1")
                because("fixes critical bug in 1.2")
            }
        }
    }

__ |

There's a difference with using the _reject_ directive of [rich version
constraints](rich_versions.html#rich-version-constraints): rich versions will
cause the build to fail if a rejected version is found in the graph, or select
a non rejected version when using dynamic dependencies. Here, we _manipulate
the requested versions_ in order to select a different version when we find a
rejected one. In other words, this is a _solution_ to rejected versions, while
rich version constraints allow declaring the _intent_ (you should not use this
version).  
  
---|---  
  
## Using module replacement rules

It is preferable to express module conflicts in terms of [capabilities
conflicts](dependency_capability_conflict.html#sub:capabilities). However, if
there's no such rule declared or that you are working on versions of Gradle
which do not support capabilities, Gradle provides tooling to work around
those issues.

Module replacement rules allow a build to declare that a legacy library has
been replaced by a new one. A good example when a new library replaced a
legacy one is the `google-collections` -> `guava` migration. The team that
created google-collections decided to change the module name from
`com.google.collections:google-collections` into `com.google.guava:guava`.
This is a legal scenario in the industry: teams need to be able to change the
names of products they maintain, including the module coordinates. Renaming of
the module coordinates has impact on conflict resolution.

To explain the impact on conflict resolution, let's consider the `google-
collections` -> `guava` scenario. It may happen that both libraries are pulled
into the same dependency graph. For example, _our project_ depends on `guava`
but some of _our dependencies_ pull in a legacy version of `google-
collections`. This can cause runtime errors, for example during test or
application execution. Gradle does not automatically resolve the `google-
collections` -> `guava` conflict because it is not considered as a _version
conflict_. It's because the module coordinates for both libraries are
completely different and conflict resolution is activated when `group` and
`module` coordinates are the same but there are different versions available
in the dependency graph (for more info, refer to the section on conflict
resolution). Traditional remedies to this problem are:

  * Declare exclusion rule to avoid pulling in `google-collections` to graph. It is probably the most popular approach.

  * Avoid dependencies that pull in legacy libraries.

  * Upgrade the dependency version if the new version no longer pulls in a legacy library.

  * Downgrade to `google-collections`. It's not recommended, just mentioned for completeness.

Traditional approaches work but they are not general enough. For example, an
organisation wants to resolve the `google-collections` -> `guava` conflict
resolution problem in all projects. It is possible to declare that certain
module was replaced by other. This enables organisations to include the
information about module replacement in the corporate plugin suite and resolve
the problem holistically for all Gradle-powered projects in the enterprise.

Example 3. Declaring a module replacement

build.gradle

    
    
    dependencies {
        modules {
            module("com.google.collections:google-collections") {
                replacedBy("com.google.guava:guava", "google-collections is now part of Guava")
            }
        }
    }

build.gradle.kts

    
    
    dependencies {
        modules {
            module("com.google.collections:google-collections") {
                replacedBy("com.google.guava:guava", "google-collections is now part of Guava")
            }
        }
    }

For more examples and detailed API, refer to the DSL reference for
[ComponentMetadataHandler](../javadoc/org/gradle/api/artifacts/dsl/ComponentMetadataHandler.html).

What happens when we declare that `google-collections` is replaced by `guava`?
Gradle can use this information for conflict resolution. Gradle will consider
every version of `guava` newer/better than any version of `google-
collections`. Also, Gradle will ensure that only guava jar is present in the
classpath / resolved file list. Note that if only `google-collections` appears
in the dependency graph (e.g. no `guava`) Gradle will not eagerly replace it
with `guava`. Module replacement is an information that Gradle uses for
resolving conflicts. If there is no conflict (e.g. only `google-collections`
or only `guava` in the graph) the replacement information is not used.

Currently it is not possible to declare that a given module is replaced by a
set of modules. However, it is possible to declare that multiple modules are
replaced by a single module.

## Using dependency substitution rules

Dependency substitution rules work similarly to dependency resolve rules. In
fact, many capabilities of dependency resolve rules can be implemented with
dependency substitution rules. They allow project and module dependencies to
be transparently substituted with specified replacements. Unlike dependency
resolve rules, dependency substitution rules allow project and module
dependencies to be substituted interchangeably.

_Adding a dependency substitution rule to a configuration changes the timing
of when that configuration is resolved._ Instead of being resolved on first
use, the configuration is instead resolved when the task graph is being
constructed. This can have unexpected consequences if the configuration is
being further modified during task execution, or if the configuration relies
on modules that are published during execution of another task.

To explain:

  * A `Configuration` can be declared as an input to any Task, and that configuration can include project dependencies when it is resolved.

  * If a project dependency is an input to a Task (via a configuration), then tasks to build the project artifacts must be added to the task dependencies.

  * In order to determine the project dependencies that are inputs to a task, Gradle needs to resolve the `Configuration` inputs.

  * Because the Gradle task graph is fixed once task execution has commenced, Gradle needs to perform this resolution prior to executing any tasks.

In the absence of dependency substitution rules, Gradle knows that an external
module dependency will never transitively reference a project dependency. This
makes it easy to determine the full set of project dependencies for a
configuration through simple graph traversal. With this functionality, Gradle
can no longer make this assumption, and must perform a full resolve in order
to determine the project dependencies.

### Substituting an external module dependency with a project dependency

One use case for dependency substitution is to use a locally developed version
of a module in place of one that is downloaded from an external repository.
This could be useful for testing a local, patched version of a dependency.

The module to be replaced can be declared with or without a version specified.

Example 4. Substituting a module with a project

build.gradle

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute module("org.utils:api") using project(":api") because "we work with the unreleased development version"
            substitute module("org.utils:util:2.5") using project(":util")
        }
    }

build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute(module("org.utils:api"))
                .using(project(":api")).because("we work with the unreleased development version")
            substitute(module("org.utils:util:2.5")).using(project(":util"))
        }
    }

Note that a project that is substituted must be included in the multi-project
build (via `settings.gradle`). Dependency substitution rules take care of
replacing the module dependency with the project dependency and wiring up any
task dependencies, but do not implicitly include the project in the build.

### Substituting a project dependency with a module replacement

Another way to use substitution rules is to replace a project dependency with
a module in a multi-project build. This can be useful to speed up development
with a large multi-project build, by allowing a subset of the project
dependencies to be downloaded from a repository rather than being built.

The module to be used as a replacement must be declared with a version
specified.

Example 5. Substituting a project with a module

build.gradle

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute project(":api") using module("org.utils:api:1.3") because "we use a stable version of org.utils:api"
        }
    }

build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute(project(":api"))
                .using(module("org.utils:api:1.3")).because("we use a stable version of org.utils:api")
        }
    }

When a project dependency has been replaced with a module dependency, that
project is still included in the overall multi-project build. However, tasks
to build the replaced dependency will not be executed in order to resolve the
depending `Configuration`.

### Conditionally substituting a dependency

A common use case for dependency substitution is to allow more flexible
assembly of sub-projects within a multi-project build. This can be useful for
developing a local, patched version of an external dependency or for building
a subset of the modules within a large multi-project build.

The following example uses a dependency substitution rule to replace any
module dependency with the group `org.example`, but only if a local project
matching the dependency name can be located.

Example 6. Conditionally substituting a dependency

build.gradle

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution.all { DependencySubstitution dependency ->
            if (dependency.requested instanceof ModuleComponentSelector && dependency.requested.group == "org.example") {
                def targetProject = findProject(":${dependency.requested.module}")
                if (targetProject != null) {
                    dependency.useTarget targetProject
                }
            }
        }
    }

build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution.all {
            requested.let {
                if (it is ModuleComponentSelector && it.group == "org.example") {
                    val targetProject = findProject(":${it.module}")
                    if (targetProject != null) {
                        useTarget(targetProject)
                    }
                }
            }
        }
    }

Note that a project that is substituted must be included in the multi-project
build (via `settings.gradle`). Dependency substitution rules take care of
replacing the module dependency with the project dependency, but do not
implicitly include the project in the build.

### Substituting a dependency with another variant

Gradle's dependency management engine is [variant-
aware](variant_model.html#understanding-variant-selection) meaning that for a
single component, the engine may select different artifacts and transitive
dependencies.

What to select is determined by the attributes of the consumer configuration
and the attributes of the variants found on the producer side. It is, however,
possible that some specific dependencies override attributes from the
configuration itself. This is typically the case when using the [Java Platform
plugin](java_platform_plugin.html#java_platform_plugin): this plugin builds a
special kind of component which is called a "platform" and can be addressed by
setting the component category attribute to `platform`, in opposition to
typical dependencies which are targetting libraries.

Therefore, you may face situations where you want to substitute a platform
dependency with a regular dependency, or the other way around.

#### Substituting a dependency with attributes

Let's imagine that you want to substitute a platform dependency with a regular
dependency. This means that the library you are consuming declared something
like this:

Example 7. An incorrect dependency on a platform

lib/build.gradle

    
    
    dependencies {
        // This is a platform dependency but you want the library
        implementation platform('com.google.guava:guava:28.2-jre')
    }

lib/build.gradle.kts

    
    
    dependencies {
        // This is a platform dependency but you want the library
        implementation(platform("com.google.guava:guava:28.2-jre"))
    }

The `platform` keyword is actually a short-hand notation for a _dependency
with attributes_. If we want to substitute this dependency with a regular
dependency, then we need to select precisely the dependencies which have the
`platform` attribute.

This can be done by using a substitution rule:

Example 8. Substitute a platform dependency with a regular dependency

consumer/build.gradle

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute(platform(module('com.google.guava:guava:28.2-jre'))).
                using module('com.google.guava:guava:28.2-jre')
        }
    }

consumer/build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute(platform(module("com.google.guava:guava:28.2-jre")))
                .using(module("com.google.guava:guava:28.2-jre"))
        }
    }

The same rule _without_ the `platform` keyword would try to substitute
_regular dependencies_ with a regular dependency, which is not what you want,
so it's important to understand that the substitution rules apply on a
_dependency specification_ : it matches the requested dependency (`substitute
XXX`) with a substitute (`using YYY`).

You can have attributes on both the requested dependency _or_ the substitute
and the substitution is not limited to `platform`: you can actually specify
the whole set of dependency attributes using the `variant` notation. The
following rule is _strictly equivalent_ to the rule above:

Example 9. Substitute a platform dependency with a regular dependency using
the variant notation

consumer/build.gradle

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute variant(module('com.google.guava:guava:28.2-jre')) {
                attributes {
                    attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.REGULAR_PLATFORM))
                }
            } using module('com.google.guava:guava:28.2-jre')
        }
    }

consumer/build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute(variant(module("com.google.guava:guava:28.2-jre")) {
                attributes {
                    attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.REGULAR_PLATFORM))
                }
            }).using(module("com.google.guava:guava:28.2-jre"))
        }
    }

Please refer to the [Substitution DSL API
docs](../javadoc/org/gradle/api/artifacts/DependencySubstitutions.html#variant-
org.gradle.api.artifacts.component.ComponentSelector-org.gradle.api.Action-)
for a complete reference of the variant substitution API.

__ |

In [composite builds](composite_builds.html#composite_build_intro), the rule
that you have to match the exact requested dependency attributes is not
applied: when using composites, Gradle will automatically match the requested
attributes. In other words, it is implicit that if you include another build,
you are substituting _all variants_ of the substituted module with an
equivalent variant in the included build.  
  
---|---  
  
#### Substituting a dependency with a dependency with capabilities

Similarly to attributes substitution, Gradle lets you substitute a dependency
with or without capabilities with another dependency with or without
capabilities.

For example, let's imagine that you need to substitute a regular dependency
with its [test fixtures](java_testing.html#sec:java_test_fixtures) instead.
You can achieve this by using the following dependency substitution rule:

Example 10. Substitute a dependency with its test fixtures

build.gradle

    
    
    configurations.testCompileClasspath {
        resolutionStrategy.dependencySubstitution {
            substitute(module('com.acme:lib:1.0'))
                .using variant(module('com.acme:lib:1.0')) {
                capabilities {
                    requireCapability('com.acme:lib-test-fixtures')
                }
            }
        }
    }

build.gradle.kts

    
    
    configurations.testCompileClasspath {
        resolutionStrategy.dependencySubstitution {
            substitute(module("com.acme:lib:1.0")).using(variant(module("com.acme:lib:1.0")) {
                capabilities {
                    requireCapability("com.acme:lib-test-fixtures")
                }
            })
        }
    }

Capabilities which are declared in a substitution rule on the requested
dependency constitute part of the dependency match specification, and
therefore dependencies which do _not_ require the capabilities will not be
matched.

Please refer to the [Substitution DSL API
docs](../javadoc/org/gradle/api/artifacts/DependencySubstitutions.html#variant-
org.gradle.api.artifacts.component.ComponentSelector-org.gradle.api.Action-)
for a complete reference of the variant substitution API.

__ |

In [composite builds](composite_builds.html#composite_build_intro), the rule
that you have to match the exact requested dependency capabilities is not
applied: when using composites, Gradle will automatically match the requested
capabilities. In other words, it is implicit that if you include another
build, you are substituting _all variants__ of the substituted module with an
equivalent variant in the included build.]  
  
---|---  
  
### Substituting a dependency with a classifier or artifact

While external modules are in general addressed via their
group/artifact/version coordinates, it is common that such modules are
published with additional artifacts that you may want to use in place of the
main artifact. This is typically the case for _classified_ artifacts, but you
may also need to select an artifact with a different file type or extension.
Gradle discourages use of classifiers in dependencies and prefers to model
such artifacts as [variants additional variants of a
module](variant_model.html#understanding-variant-selection). There are lots of
advantages of using variants instead of classified artifacts, including, but
not only, a different set of dependencies for those artifacts.

However, in order to help bridging the two models, Gradle provides means to
change or remove a classifier in a substitution rule.

Example 11. Dependencies which will lead to a resolution error

consumer/build.gradle

    
    
    dependencies {
        implementation 'com.google.guava:guava:28.2-jre'
        implementation 'co.paralleluniverse:quasar-core:0.8.0'
        implementation project(':lib')
    }

consumer/build.gradle.kts

    
    
    dependencies {
        implementation("com.google.guava:guava:28.2-jre")
        implementation("co.paralleluniverse:quasar-core:0.8.0")
        implementation(project(":lib"))
    }

In the example above, the first level dependency on `quasar` makes us think
that Gradle would resolve `quasar-core-0.8.0.jar` but it's not the case: the
build would fail with this message:

    
    
    Execution failed for task ':resolve'.
    > Could not resolve all files for configuration ':runtimeClasspath'.
       > Could not find quasar-core-0.8.0-jdk8.jar (co.paralleluniverse:quasar-core:0.8.0).
         Searched in the following locations:
             https://jcenter.bintray.com/co/paralleluniverse/quasar-core/0.8.0/quasar-core-0.8.0-jdk8.jar

That's because there's a dependency on another project, `lib`, which itself
depends on a different version of `quasar-core`:

Example 12. A "classified" dependency

lib/build.gradle

    
    
    dependencies {
        implementation "co.paralleluniverse:quasar-core:0.7.12_r3:jdk8"
    }

lib/build.gradle.kts

    
    
    dependencies {
        implementation("co.paralleluniverse:quasar-core:0.7.12_r3:jdk8")
    }

What happens is that Gradle would perform conflict resolution between `quasar-
core` 0.8.0 and `quasar-core` 0.7.12_r3. Because 0.8.0 is higher, we select
this version, but the dependency in `lib` has a classifier, `jdk8` and this
classifier _doesn 't exist anymore_ in release 0.8.0.

To fix this problem, you can ask Gradle to resolve both dependencies _without
classifier_ :

Example 13. A resolution rule to disable selection of a classifier

consumer/build.gradle

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute module('co.paralleluniverse:quasar-core') using module('co.paralleluniverse:quasar-core:0.8.0') withoutClassifier()
        }
    }

consumer/build.gradle.kts

    
    
    configurations.all {
        resolutionStrategy.dependencySubstitution {
            substitute(module("co.paralleluniverse:quasar-core"))
                .using(module("co.paralleluniverse:quasar-core:0.8.0"))
                .withoutClassifier()
        }
    }

This rule effectively replaces any dependency on `quasar-core` found in the
graph with a dependency without classifier.

Alternatively, it's possible to select a dependency _with_ a specific
classifier or, for more specific use cases, substitute with a very specific
artifact (type, extension and classifier).

For more information, please refer to the following API documentation:

  * artifact selection via the [Substitution DSL](../javadoc/org/gradle/api/artifacts/DependencySubstitutions.Substitution.html)

  * artifact selection via the [DependencySubstitution API](../javadoc/org/gradle/api/artifacts/DependencySubstitution.html#artifactSelection-org.gradle.api.Action-)

  * artifact selection via the [ResolutionStrategy API](../javadoc/org/gradle/api/artifacts/ResolutionStrategy.html#dependencySubstitution-org.gradle.api.Action-)

## Disabling transitive resolution

By default Gradle resolves all transitive dependencies specified by the
dependency metadata. Sometimes this behavior may not be desirable e.g. if the
metadata is incorrect or defines a large graph of transitive dependencies. You
can tell Gradle to disable transitive dependency management for a dependency
by setting
[ModuleDependency.setTransitive(boolean)](../javadoc/org/gradle/api/artifacts/ModuleDependency.html#setTransitive-
boolean-) to `false`. As a result only the main artifact will be resolved for
the declared dependency.

Example 14. Disabling transitive dependency resolution for a declared
dependency

build.gradle

    
    
    dependencies {
        implementation('com.google.guava:guava:23.0') {
            transitive = false
        }
    }

build.gradle.kts

    
    
    dependencies {
        implementation("com.google.guava:guava:23.0") {
            isTransitive = false
        }
    }

__ |

Disabling transitive dependency resolution will likely require you to declare
the necessary runtime dependencies in your build script which otherwise would
have been resolved automatically. Not doing so might lead to runtime classpath
issues.  
  
---|---  
  
A project can decide to disable transitive dependency resolution completely.
You either don't want to rely on the metadata published to the consumed
repositories or you want to gain full control over the dependencies in your
graph. For more information, see
[Configuration.setTransitive(boolean)](../javadoc/org/gradle/api/artifacts/Configuration.html#setTransitive-
boolean-).

Example 15. Disabling transitive dependency resolution on the configuration-
level

build.gradle

    
    
    configurations.all {
        transitive = false
    }
    
    dependencies {
        implementation 'com.google.guava:guava:23.0'
    }

build.gradle.kts

    
    
    configurations.all {
        isTransitive = false
    }
    
    dependencies {
        implementation("com.google.guava:guava:23.0")
    }

## Changing configuration dependencies prior to resolution

At times, a plugin may want to modify the dependencies of a configuration
before it is resolved. The `withDependencies` method permits dependencies to
be added, removed or modified programmatically.

Example 16. Modifying dependencies on a configuration

build.gradle

    
    
    configurations {
        implementation {
            withDependencies { DependencySet dependencies ->
                ExternalModuleDependency dep = dependencies.find { it.name == 'to-modify' } as ExternalModuleDependency
                dep.version {
                    strictly "1.2"
                }
            }
        }
    }

build.gradle.kts

    
    
    configurations {
        create("implementation") {
            withDependencies {
                val dep = this.find { it.name == "to-modify" } as ExternalModuleDependency
                dep.version {
                    strictly("1.2")
                }
            }
        }
    }

## Setting default configuration dependencies

A configuration can be configured with default dependencies to be used if no
dependencies are explicitly set for the configuration. A primary use case of
this functionality is for developing plugins that make use of versioned tools
that the user might override. By specifying default dependencies, the plugin
can use a default version of the tool only if the user has not specified a
particular version to use.

Example 17. Specifying default dependencies on a configuration

build.gradle

    
    
    configurations {
        pluginTool {
            defaultDependencies { dependencies ->
                dependencies.add(project.dependencies.create("org.gradle:my-util:1.0"))
            }
        }
    }

build.gradle.kts

    
    
    configurations {
        create("pluginTool") {
            defaultDependencies {
                add(project.dependencies.create("org.gradle:my-util:1.0"))
            }
        }
    }

## Excluding a dependency from a configuration completely

Similar to [excluding a dependency in a dependency
declaration](dependency_downgrade_and_exclude.html#sec:excluding-transitive-
deps), you can exclude a transitive dependency for a particular configuration
completely by using
[Configuration.exclude(java.util.Map)](../dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:exclude\(java.util.Map\)).
This will automatically exclude the transitive dependency for all dependencies
declared on the configuration.

Example 18. Excluding transitive dependency for a particular configuration

build.gradle

    
    
    configurations {
        implementation {
            exclude group: 'commons-collections', module: 'commons-collections'
        }
    }
    
    dependencies {
        implementation 'commons-beanutils:commons-beanutils:1.9.4'
        implementation 'com.opencsv:opencsv:4.6'
    }

build.gradle.kts

    
    
    configurations {
        "implementation" {
            exclude(group = "commons-collections", module = "commons-collections")
        }
    }
    
    dependencies {
        implementation("commons-beanutils:commons-beanutils:1.9.4")
        implementation("com.opencsv:opencsv:4.6")
    }

## Matching dependencies to repositories

Gradle exposes an API to declare what a repository may or may not contain.
This feature offers a fine grained control on which repository serve which
artifacts, which can be one way of controlling the source of dependencies.

Head over to [the section on repository content
filtering](declaring_repositories.html#sec:repository-content-filtering) to
know more about this feature.

## Enabling Ivy dynamic resolve mode

Gradle's Ivy repository implementations support the equivalent to Ivy's
dynamic resolve mode. Normally, Gradle will use the `rev` attribute for each
dependency definition included in an `ivy.xml` file. In dynamic resolve mode,
Gradle will instead prefer the `revConstraint` attribute over the `rev`
attribute for a given dependency definition. If the `revConstraint` attribute
is not present, the `rev` attribute is used instead.

To enable dynamic resolve mode, you need to set the appropriate option on the
repository definition. A couple of examples are shown below. Note that dynamic
resolve mode is only available for Gradle's Ivy repositories. It is not
available for Maven repositories, or custom Ivy `DependencyResolver`
implementations.

Example 19. Enabling dynamic resolve mode

build.gradle

    
    
    // Can enable dynamic resolve mode when you define the repository
    repositories {
        ivy {
            url "http://repo.mycompany.com/repo"
            resolve.dynamicMode = true
        }
    }
    
    // Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories
    repositories.withType(IvyArtifactRepository) {
        resolve.dynamicMode = true
    }

build.gradle.kts

    
    
    // Can enable dynamic resolve mode when you define the repository
    repositories {
        ivy {
            url = uri("http://repo.mycompany.com/repo")
            resolve.isDynamicMode = true
        }
    }
    
    // Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories
    repositories.withType<IvyArtifactRepository> {
        resolve.isDynamicMode = true
    }

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

