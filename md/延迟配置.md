

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Lazy Configuration

version 6.7.1

Contents

  * Lazy properties
  * Creating a Property or Provider instance
  * Connecting properties together
  * Working with files
  * Working with task inputs and outputs
  * Working with collections
  * Working with maps
  * Applying a convention to a property
  * Making a property unmodifiable
  * Guidelines
  * Future development
  * Provider Files API Reference
  * Property Files API Reference
  * Lazy Collections API Reference
  * Lazy Objects API Reference

As a build grows in complexity, knowing when and where a particular value is
configured can become difficult to reason about. Gradle provides several ways
to manage this complexity using _lazy configuration_.

## Lazy properties

Gradle provides lazy properties, which delay the calculation of a property’s
value until it’s actually required. These provide three main benefits to build
script and plugin authors:

  1. Build authors can wire together Gradle models without worrying when a particular property’s value will be known. For example, you may want to set the input source files of a task based on the source directories property of an extension but the extension property value isn't known until the build script or some other plugin configures them.

  2. Build authors can wire an output property of a task into an input property of some other task and Gradle automatically determines the task dependencies based on this connection. Property instances carry information about which task, if any, produces their value. Build authors do not need to worry about keeping task dependencies in sync with configuration changes.

  3. Build authors can avoid resource intensive work during the configuration phase, which can have a large impact on build performance. For example, when a configuration value comes from parsing a file but is only used when functional tests are run, using a property instance to capture this means that the file is parsed only when the functional tests are run, but not when, for example, `clean` is run.

Gradle represents lazy properties with two interfaces:

  * [Provider](../javadoc/org/gradle/api/provider/Provider.html) represents a value that can only be queried and cannot be changed.

    * Properties with these types are read-only.

    * The method [Provider.get()](../javadoc/org/gradle/api/provider/Provider.html#get--) returns the current value of the property.

    * A `Provider` can be created from another `Provider` using [Provider.map(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-).

    * Many other types extend `Provider` and can be used where-ever a `Provider` is required.

  * [Property](../javadoc/org/gradle/api/provider/Property.html) represents a value that can be queried and also changed.

    * Properties with these types are configurable.

    * `Property` extends the `Provider` interface.

    * The method [Property.set(T)](../javadoc/org/gradle/api/provider/Property.html#set-T-) specifies a value for the property, overwriting whatever value may have been present.

    * The method [Property.set(Provider)](../javadoc/org/gradle/api/provider/Property.html#set-org.gradle.api.provider.Provider-) specifies a `Provider` for the value for the property, overwriting whatever value may have been present. This allows you to wire together `Provider` and `Property` instances before the values are configured.

    * A `Property` can be created by the factory method [ObjectFactory.property(Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-).

Lazy properties are intended to be passed around and only queried when
required. Usually, this will happen during the execution phase. For more
information about the Gradle build phases, please see [Build
Lifecycle](build_lifecycle.html#sec:build_phases).

The following demonstrates a task with a configurable `greeting` property and
a read-only `message` property that is derived from this:

Example 1. Using a read-only and configurable property

build.gradle

    
    
    // A task that displays a greeting
    class Greeting extends DefaultTask {
        // A configurable greeting
        @Input
        final Property<String> greeting = project.objects.property(String)
    
        // Read-only property calculated from the greeting
        @Internal
        final Provider<String> message = greeting.map { it + ' from Gradle' }
    
        @TaskAction
        void printMessage() {
            logger.quiet(message.get())
        }
    }
    
    task greeting(type: Greeting) {
        // Configure the greeting
        greeting.set('Hi')
    
        // Note that an assignment statement can be used instead of calling Property.set()
        greeting = 'Hi'
    }

build.gradle.kts

    
    
    // A task that displays a greeting
    open class Greeting : DefaultTask() {
        // Configurable by the user
        @Input
        val greeting: Property<String> = project.objects.property()
    
        // Read-only property calculated from the greeting
        @Internal
        val message: Provider<String> = greeting.map { it + " from Gradle" }
    
        @TaskAction
        fun printMessage() {
            logger.quiet(message.get())
        }
    }
    
    tasks.register<Greeting>("greeting") {
        // Configure the greeting
        greeting.set("Hi")
    }

Output of **`gradle greeting`**

    
    
    $ gradle greeting
    
    > Task :greeting
    Hi from Gradle
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

The `Greeting` task has a property of type `Property<String>` to represent the
configurable greeting and a property of type `Provider<String>` to represent
the calculated, read-only, message. The message `Provider` is created from the
greeting `Property` using the `map()` method, and so its value is kept up-to-
date as the value of the greeting property changes.

__ |

Note that Gradle Groovy DSL generates setter methods for each `Property`-typed
property in a task implementation. These setter methods allow you to configure
the property using the assignment (`=`) operator as a convenience.

Kotlin DSL conveniences will be added in a future release.  
  
---|---  
  
## Creating a Property or Provider instance

Neither `Provider` nor its subtypes such as `Property` are intended to be
implemented by a build script or plugin author. Gradle provides factory
methods to create instances of these types instead. See the Quick Reference
for all of the types and factories available. In the previous example, we have
seen 2 factory methods:

  * [ObjectFactory.property(Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-) create a new `Property` instance. An instance of the [ObjectFactory](../javadoc/org/gradle/api/model/ObjectFactory.html) can be referenced from [Project.getObjects()](../javadoc/org/gradle/api/Project.html#getObjects--) or by injecting `ObjectFactory` through a constructor or method.

  * [Provider.map(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-) creates a new `Provider` from an existing `Provider` or `Property` instance.

A `Provider` can also be created by the factory method
[ProviderFactory.provider(Callable)](../javadoc/org/gradle/api/provider/ProviderFactory.html#provider-
java.util.concurrent.Callable-). You should prefer using `map()` instead, as
this has some useful benefits, which we will see later.

__ |

There are no specific methods create a provider using a `groovy.lang.Closure`.
When writing a plugin or build script with Groovy, you can use the
`map(Transformer)` method with a closure and Groovy will take care of
converting the closure to a `Transformer`. You can see this in action in the
previous example.

Similarly, when writing a plugin or build script with Kotlin, the Kotlin
compiler will take care of converting a Kotlin function into a `Transformer`.  
  
---|---  
  
## Connecting properties together

An important feature of lazy properties is that they can be connected together
so that changes to one property are automatically reflected in other
properties. Here's an example where the property of a task is connected to a
property of a project extension:

Example 2. Connecting properties together

build.gradle

    
    
    // A project extension
    class MessageExtension {
        // A configurable greeting
        final Property<String> greeting
    
        @javax.inject.Inject
        MessageExtension(ObjectFactory objects) {
            greeting = objects.property(String)
        }
    }
    
    // A task that displays a greeting
    class Greeting extends DefaultTask {
        // A configurable greeting
        @Input
        final Property<String> greeting = project.objects.property(String)
    
        // Read-only property calculated from the greeting
        @Internal
        final Provider<String> message = greeting.map { it + ' from Gradle' }
    
        @TaskAction
        void printMessage() {
            logger.quiet(message.get())
        }
    }
    
    // Create the project extension
    project.extensions.create('messages', MessageExtension)
    
    // Create the greeting task
    task greeting(type: Greeting) {
        // Attach the greeting from the project extension
        // Note that the values of the project extension have not been configured yet
        greeting.set(project.messages.greeting)
    
        // Note that an assignment statement can be used instead of calling Property.set()
        greeting = project.messages.greeting
    }
    
    messages {
        // Configure the greeting on the extension
        // Note that there is no need to reconfigure the task's `greeting` property. This is automatically updated as the extension property changes
        greeting = 'Hi'
    }

build.gradle.kts

    
    
    // A project extension
    open class MessageExtension(objects: ObjectFactory) {
        // A configurable greeting
        val greeting: Property<String> = objects.property()
    }
    
    // A task that displays a greeting
    open class Greeting : DefaultTask() {
        // Configurable by the user
        @Input
        val greeting: Property<String> = project.objects.property()
    
        // Read-only property calculated from the greeting
        @Internal
        val message: Provider<String> = greeting.map { it + " from Gradle" }
    
        @TaskAction
        fun printMessage() {
            logger.quiet(message.get())
        }
    }
    
    // Create the project extension
    val messages = project.extensions.create("messages", MessageExtension::class)
    
    // Create the greeting task
    tasks.register<Greeting>("greeting") {
        // Attach the greeting from the project extension
        // Note that the values of the project extension have not been configured yet
        greeting.set(messages.greeting)
    }
    
    configure<MessageExtension> {
        // Configure the greeting on the extension
        // Note that there is no need to reconfigure the task's `greeting` property. This is automatically updated as the extension property changes
        greeting.set("Hi")
    }

Output of **`gradle greeting`**

    
    
    $ gradle greeting
    
    > Task :greeting
    Hi from Gradle
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

This example calls the
[Property.set(Provider)](../javadoc/org/gradle/api/provider/Property.html#set-
org.gradle.api.provider.Provider-) method to attach a `Provider` to a
`Property` to supply the value of the property. In this case, the `Provider`
happens to be a `Property` as well, but you can connect any `Provider`
implementation, for example one created using `Provider.map()`

## Working with files

In [Working with Files](working_with_files.html#working_with_files), we
introduced four collection types for `File`-like objects:

Table 1. Collection of files recap Read-only Type | Configurable Type  
---|---  
  
[FileCollection](../javadoc/org/gradle/api/file/FileCollection.html)

|

[ConfigurableFileCollection](../javadoc/org/gradle/api/file/ConfigurableFileCollection.html)  
  
[FileTree](../javadoc/org/gradle/api/file/FileTree.html)

|

[ConfigurableFileTree](../javadoc/org/gradle/api/file/ConfigurableFileTree.html)  
  
All of these types are also considered lazy types.

In this section, we are going to introduce more strongly typed models types to
represent elements of the file system:
[Directory](../javadoc/org/gradle/api/file/Directory.html) and
[RegularFile](../javadoc/org/gradle/api/file/RegularFile.html). These types
shouldn't be confused with the standard Java
[File](https://docs.oracle.com/javase/8/docs/api/java/io/File.html) type as
they are used to tell Gradle, and other people, that you expect more specific
values such as a directory or a non-directory, regular file.

Gradle provides two specialized `Property` subtypes for dealing with values of
these types:
[RegularFileProperty](../javadoc/org/gradle/api/file/RegularFileProperty.html)
and
[DirectoryProperty](../javadoc/org/gradle/api/file/DirectoryProperty.html).
[ObjectFactory](../javadoc/org/gradle/api/model/ObjectFactory.html) has
methods to create these:
[ObjectFactory.fileProperty()](../javadoc/org/gradle/api/model/ObjectFactory.html#fileProperty--)
and
[ObjectFactory.directoryProperty()](../javadoc/org/gradle/api/model/ObjectFactory.html#directoryProperty--).

A `DirectoryProperty` can also be used to create a lazily evaluated `Provider`
for a `Directory` and `RegularFile` via
[DirectoryProperty.dir(String)](../javadoc/org/gradle/api/file/DirectoryProperty.html#dir-
java.lang.String-) and
[DirectoryProperty.file(String)](../javadoc/org/gradle/api/file/DirectoryProperty.html#file-
java.lang.String-) respectively. These methods create providers whose values
are calculated relative to the location for the `DirectoryProperty` they were
created from. The values returned from these providers will reflect changes to
the `DirectoryProperty`.

Example 3. Using file and directory property

build.gradle

    
    
    // A task that generates a source file and writes the result to an output directory
    class GenerateSource extends DefaultTask {
        // The configuration file to use to generate the source file
        @InputFile
        final RegularFileProperty configFile = project.objects.fileProperty()
    
        // The directory to write source files to
        @OutputDirectory
        final DirectoryProperty outputDir = project.objects.directoryProperty()
    
        @TaskAction
        def compile() {
            def inFile = configFile.get().asFile
            logger.quiet("configuration file = $inFile")
            def dir = outputDir.get().asFile
            logger.quiet("output dir = $dir")
            def className = inFile.text.trim()
            def srcFile = new File(dir, "${className}.java")
            srcFile.text = "public class ${className} { ... }"
        }
    }
    
    // Create the source generation task
    task generate(type: GenerateSource) {
        // Configure the locations, relative to the project and build directories
        configFile = project.layout.projectDirectory.file('src/main/config.txt')
        outputDir = project.layout.buildDirectory.dir('generated-source')
    
        // Note that a `File` instance can be used as a convenience to set a location
        configFile = file('src/config.txt')
    }
    
    // Change the build directory
    // Don't need to reconfigure the task properties. These are automatically updated as the build directory changes
    buildDir = 'output'

build.gradle.kts

    
    
    // A task that generates a source file and writes the result to an output directory
    open class GenerateSource @javax.inject.Inject constructor(objects: ObjectFactory): DefaultTask() {
        @InputFile
        val configFile: RegularFileProperty = objects.fileProperty()
    
        @OutputDirectory
        val outputDir: DirectoryProperty = objects.directoryProperty()
    
        @TaskAction
        fun compile() {
            val inFile = configFile.get().asFile
            logger.quiet("configuration file = $inFile")
            val dir = outputDir.get().asFile
            logger.quiet("output dir = $dir")
            val className = inFile.readText().trim()
            val srcFile = File(dir, "${className}.java")
            srcFile.writeText("public class ${className} { }")
        }
    }
    
    // Create the source generation task
    tasks.register<GenerateSource>("generate") {
        // Configure the locations, relative to the project and build directories
        configFile.set(project.layout.projectDirectory.file("src/config.txt"))
        outputDir.set(project.layout.buildDirectory.dir("generated-source"))
    }
    
    // Change the build directory
    // Don't need to reconfigure the task properties. These are automatically updated as the build directory changes
    buildDir = file("output")

Output of **`gradle print`**

    
    
    $ gradle print
    
    > Task :generate
    configuration file = /home/user/gradle/samples/src/config.txt
    output dir = /home/user/gradle/samples/output/generated-source
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

Output of **`gradle print`**

    
    
    $ gradle print
    
    > Task :generate
    configuration file = /home/user/gradle/samples/kotlin/src/config.txt
    output dir = /home/user/gradle/samples/kotlin/output/generated-source
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

This example creates providers that represent locations in the project and
build directories through
[Project.getLayout()](../javadoc/org/gradle/api/Project.html#getLayout--) with
[ProjectLayout.getBuildDirectory()](../javadoc/org/gradle/api/file/ProjectLayout.html#getBuildDirectory--)
and
[ProjectLayout.getProjectDirectory()](../javadoc/org/gradle/api/file/ProjectLayout.html#getProjectDirectory--).

To close the loop, note that a `DirectoryProperty`, or a simple `Directory`,
can be turned into a `FileTree` that allows the files and directories
contained in the directory to be queried with
[DirectoryProperty.getAsFileTree()](../javadoc/org/gradle/api/file/DirectoryProperty.html#getAsFileTree--)
or
[Directory.getAsFileTree()](../javadoc/org/gradle/api/file/Directory.html#getAsFileTree--).
Moreover, from a `DirectoryProperty`, or a `Directory`, you can also create
`FileCollection` instances containing a set of the files contained in the
directory with
[DirectoryProperty.files(Object...)](../javadoc/org/gradle/api/file/DirectoryProperty.html#files-
java.lang.Object...-) or
[Directory.files(Object...)](../javadoc/org/gradle/api/file/Directory.html#files-
java.lang.Object...-).

## Working with task inputs and outputs

Many builds have several tasks connected together, where one task consumes the
outputs of another task as an input. To make this work, we would need to
configure each task to know where to look for its inputs and place its
outputs, make sure that the producing and consuming tasks are configured with
the same location, and attach task dependencies between the tasks. This can be
cumbersome and brittle if any of these values are configurable by a user or
configured by multiple plugins, as task properties need to be configured in
the correct order and locations and task dependencies kept in sync as values
change.

The `Property` API makes this easier by keeping track of not just the value
for a property, which we have seen already, but also the task that produces
the value, so that you don't have to specify it as well. As an example
consider the following plugin with a producer and consumer task which are
wired together:

Example 4. Implicit task input file dependency

build.gradle

    
    
    class Producer extends DefaultTask {
        @OutputFile
        final RegularFileProperty outputFile = project.objects.fileProperty()
    
        @TaskAction
        void produce() {
            String message = 'Hello, World!'
            def output = outputFile.get().asFile
            output.text = message
            logger.quiet("Wrote '${message}' to ${output}")
        }
    }
    
    class Consumer extends DefaultTask {
        @InputFile
        final RegularFileProperty inputFile = project.objects.fileProperty()
    
        @TaskAction
        void consume() {
            def input = inputFile.get().asFile
            def message = input.text
            logger.quiet("Read '${message}' from ${input}")
        }
    }
    
    def producer = tasks.register("producer", Producer)
    def consumer = tasks.register("consumer", Consumer)
    
    // Connect the producer task output to the consumer task input
    // Don't need to add a task dependency to the consumer task. This is automatically added
    consumer.configure {
        inputFile = producer.flatMap { it.outputFile }
    }
    
    // Set values for the producer lazily
    // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes
    producer.configure {
        outputFile = layout.buildDirectory.file('file.txt')
    }
    
    // Change the build directory.
    // Don't need to update producer.outputFile and consumer.inputFile. These are automatically updated as the build directory changes
    buildDir = 'output'

build.gradle.kts

    
    
    open class Producer : DefaultTask() {
        @OutputFile
        val outputFile: RegularFileProperty = project.objects.fileProperty()
    
        @TaskAction
        fun produce() {
            val message = "Hello, World!"
            val output = outputFile.get().asFile
            output.writeText( message)
            logger.quiet("Wrote '${message}' to ${output}")
        }
    }
    
    open class Consumer : DefaultTask() {
        @InputFile
        val inputFile: RegularFileProperty = project.objects.fileProperty()
    
        @TaskAction
        fun consume() {
            val input = inputFile.get().asFile
            val message = input.readText()
            logger.quiet("Read '${message}' from ${input}")
        }
    }
    
    val producer by tasks.registering(Producer::class)
    val consumer by tasks.registering(Consumer::class)
    
    consumer.configure {
        // Connect the producer task output to the consumer task input
        // Don't need to add a task dependency to the consumer task. This is automatically added
        inputFile.set(producer.flatMap { it.outputFile })
    }
    
    producer.configure {
        // Set values for the producer lazily
        // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes
        outputFile.set(layout.buildDirectory.file("file.txt"))
    }
    
    // Change the build directory.
    // Don't need to update producer.outputFile and consumer.inputFile. These are automatically updated as the build directory changes
    buildDir = file("output")

Output of **`gradle consumer`**

    
    
    $ gradle consumer
    
    > Task :producer
    Wrote 'Hello, World!' to /home/user/gradle/samples/output/file.txt
    
    > Task :consumer
    Read 'Hello, World!' from /home/user/gradle/samples/output/file.txt
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

Output of **`gradle consumer`**

    
    
    $ gradle consumer
    
    > Task :producer
    Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/output/file.txt
    
    > Task :consumer
    Read 'Hello, World!' from /home/user/gradle/samples/kotlin/output/file.txt
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

In the example above, the task outputs and inputs are connected before any
location is defined. The setters can be called at any time before the task is
executed and the change will automatically affect all related input and output
properties.

Another important thing to note in this example is the absence of any explicit
task dependency. Task outputs represented using `Providers` keep track of
which task produces their value, and using them as task inputs will implicitly
add the correct task dependencies.

Implicit task dependencies also works for input properties that are not files.

Example 5. Implicit task input dependency

build.gradle

    
    
    class Producer extends DefaultTask {
        @OutputFile
        final RegularFileProperty outputFile = project.objects.fileProperty()
    
        @TaskAction
        void produce() {
            String message = 'Hello, World!'
            def output = outputFile.get().asFile
            output.text = message
            logger.quiet("Wrote '${message}' to ${output}")
        }
    }
    
    class Consumer extends DefaultTask {
        @Input
        final Property<String> message = project.objects.property(String)
    
        @TaskAction
        void consume() {
            logger.quiet(message.get())
        }
    }
    
    task producer(type: Producer)
    task consumer(type: Consumer)
    
    // Connect the producer task output to the consumer task input
    // Don't need to add a task dependency to the consumer task. This is automatically added
    consumer.message = producer.outputFile.map { it.asFile.text }
    
    // Set values for the producer lazily
    producer.outputFile = layout.buildDirectory.file('file.txt')

build.gradle.kts

    
    
    open class Producer : DefaultTask() {
        @OutputFile
        val outputFile: RegularFileProperty = project.objects.fileProperty()
    
        @TaskAction
        fun produce() {
            val message = "Hello, World!"
            val output = outputFile.get().asFile
            output.writeText( message)
            logger.quiet("Wrote '${message}' to ${output}")
        }
    }
    
    open class Consumer : DefaultTask() {
        @Input
        val message: Property<String> = project.objects.property(String::class)
    
        @TaskAction
        fun consume() {
            logger.quiet(message.get())
        }
    }
    
    val producer by tasks.registering(Producer::class) {
        // Set values for the producer lazily
        // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes
        outputFile.set(layout.buildDirectory.file("file.txt"))
    }
    val consumer by tasks.registering(Consumer::class) {
        // Connect the producer task output to the consumer task input
        // Don't need to add a task dependency to the consumer task. This is automatically added
        message.set(producer.map { it.outputFile.get().asFile.readText() })
    }

Output of **`gradle consumer`**

    
    
    $ gradle consumer
    
    > Task :producer
    Wrote 'Hello, World!' to /home/user/gradle/samples/build/file.txt
    
    > Task :consumer
    Hello, World!
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

Output of **`gradle consumer`**

    
    
    $ gradle consumer
    
    > Task :producer
    Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/build/file.txt
    
    > Task :consumer
    Hello, World!
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

## Working with collections

Gradle provides two lazy property types to help configure `Collection`
properties. These work exactly like any other `Provider` and, just like file
providers, they have additional modeling around them:

  * For `List` values the interface is called [ListProperty](../javadoc/org/gradle/api/provider/ListProperty.html). You can create a new `ListProperty` using [ObjectFactory.listProperty(Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-) and specifying the element type.

  * For `Set` values the interface is called [SetProperty](../javadoc/org/gradle/api/provider/SetProperty.html). You can create a new `SetProperty` using [ObjectFactory.setProperty(Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-) and specifying the element type.

This type of property allows you to overwrite the entire collection value with
[HasMultipleValues.set(Iterable)](../javadoc/org/gradle/api/provider/HasMultipleValues.html#set-
java.lang.Iterable-) and
[HasMultipleValues.set(Provider)](../javadoc/org/gradle/api/provider/HasMultipleValues.html#set-
org.gradle.api.provider.Provider-) or add new elements through the various
`add` methods:

  * [HasMultipleValues.add(T)](../javadoc/org/gradle/api/provider/HasMultipleValues.html#add-T-): Add a single element to the collection

  * [HasMultipleValues.add(Provider)](../javadoc/org/gradle/api/provider/HasMultipleValues.html#add-org.gradle.api.provider.Provider-): Add a lazily calculated element to the collection

  * [HasMultipleValues.addAll(Provider)](../javadoc/org/gradle/api/provider/HasMultipleValues.html#addAll-org.gradle.api.provider.Provider-): Add a lazily calculated collection of elements to the list

Just like every `Provider`, the collection is calculated when
[Provider.get()](../javadoc/org/gradle/api/provider/Provider.html#get--) is
called. The following example shows the
[ListProperty](../javadoc/org/gradle/api/provider/ListProperty.html) in
action:

Example 6. List property

build.gradle

    
    
    class Producer extends DefaultTask {
        @OutputFile
        final RegularFileProperty outputFile = project.objects.fileProperty()
    
        @TaskAction
        void produce() {
            String message = 'Hello, World!'
            def output = outputFile.get().asFile
            output.text = message
            logger.quiet("Wrote '${message}' to ${output}")
        }
    }
    
    class Consumer extends DefaultTask {
        @InputFiles
        final ListProperty<RegularFile> inputFiles = project.objects.listProperty(RegularFile)
    
        @TaskAction
        void consume() {
            inputFiles.get().each { inputFile ->
                def input = inputFile.asFile
                def message = input.text
                logger.quiet("Read '${message}' from ${input}")
            }
        }
    }
    
    task producerOne(type: Producer)
    task producerTwo(type: Producer)
    task consumer(type: Consumer)
    
    // Connect the producer task outputs to the consumer task input
    // Don't need to add task dependencies to the consumer task. These are automatically added
    consumer.inputFiles.add(producerOne.outputFile)
    consumer.inputFiles.add(producerTwo.outputFile)
    
    // Set values for the producer tasks lazily
    // Don't need to update the consumer.inputFiles property. This is automatically updated as producer.outputFile changes
    producerOne.outputFile = layout.buildDirectory.file('one.txt')
    producerTwo.outputFile = layout.buildDirectory.file('two.txt')
    
    // Change the build directory.
    // Don't need to update the task properties. These are automatically updated as the build directory changes
    buildDir = 'output'

build.gradle.kts

    
    
    open class Producer : DefaultTask() {
        @OutputFile
        val outputFile: RegularFileProperty = project.objects.fileProperty()
    
        @TaskAction
        fun produce() {
            val message = "Hello, World!"
            val output = outputFile.get().asFile
            output.writeText( message)
            logger.quiet("Wrote '${message}' to ${output}")
        }
    }
    
    open class Consumer : DefaultTask() {
        @InputFiles
        val inputFiles: ListProperty<RegularFile> = project.objects.listProperty(RegularFile::class)
    
        @TaskAction
        fun consume() {
            inputFiles.get().forEach { inputFile ->
                val input = inputFile.asFile
                val message = input.readText()
                logger.quiet("Read '${message}' from ${input}")
            }
        }
    }
    
    val producerOne by tasks.registering(Producer::class)
    val producerTwo by tasks.registering(Producer::class)
    val consumer by tasks.registering(Consumer::class) {
        // Connect the producer task outputs to the consumer task input
        // Don't need to add task dependencies to the consumer task. These are automatically added
        inputFiles.add(producerOne.get().outputFile)
        inputFiles.add(producerTwo.get().outputFile)
    }
    
    // Set values for the producer tasks lazily
    // Don't need to update the consumer.inputFiles property. This is automatically updated as producer.outputFile changes
    producerOne { outputFile.set(layout.buildDirectory.file("one.txt")) }
    producerTwo { outputFile.set(layout.buildDirectory.file("two.txt")) }
    
    // Change the build directory.
    // Don't need to update the task properties. These are automatically updated as the build directory changes
    buildDir = file("output")

Output of **`gradle consumer`**

    
    
    $ gradle consumer
    
    > Task :producerOne
    Wrote 'Hello, World!' to /home/user/gradle/samples/output/one.txt
    
    > Task :producerTwo
    Wrote 'Hello, World!' to /home/user/gradle/samples/output/two.txt
    
    > Task :consumer
    Read 'Hello, World!' from /home/user/gradle/samples/output/one.txt
    Read 'Hello, World!' from /home/user/gradle/samples/output/two.txt
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 3 executed

Output of **`gradle consumer`**

    
    
    $ gradle consumer
    
    > Task :producerOne
    Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/output/one.txt
    
    > Task :producerTwo
    Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/output/two.txt
    
    > Task :consumer
    Read 'Hello, World!' from /home/user/gradle/samples/kotlin/output/one.txt
    Read 'Hello, World!' from /home/user/gradle/samples/kotlin/output/two.txt
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 3 executed

## Working with maps

Gradle provides a lazy
[MapProperty](../javadoc/org/gradle/api/provider/MapProperty.html) type to
allow `Map` values to be configured. You can create a `MapProperty` instance
using [ObjectFactory.mapProperty(Class,
Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#mapProperty-
java.lang.Class-java.lang.Class-).

Similar to other property types, a `MapProperty` has a
[set()](../javadoc/org/gradle/api/provider/MapProperty.html#set-
java.util.Map-) method that you can use to specify the value for the property.
There are some additional methods to allow entries with lazy values to be
added to the map.

Example 7. Map property

build.gradle

    
    
    class Generator extends DefaultTask {
        @Input
        final MapProperty<String, Integer> properties = project.objects.mapProperty(String, Integer)
    
        @TaskAction
        void generate() {
            properties.get().each { key, value ->
                logger.quiet("${key} = ${value}")
            }
        }
    }
    
    // Some values to be configured later
    def b = 0
    def c = 0
    
    task generate(type: Generator) {
        properties.put("a", 1)
        // Values have not been configured yet
        properties.put("b", providers.provider { b })
        properties.putAll(providers.provider { [c: c, d: c + 1] })
    }
    
    // Configure the values. There is no need to reconfigure the task
    b = 2
    c = 3

build.gradle.kts

    
    
    open class Generator: DefaultTask() {
        @Input
        val properties: MapProperty<String, Int> = project.objects.mapProperty(String::class, Int::class)
    
        @TaskAction
        fun generate() {
            properties.get().forEach { entry ->
                logger.quiet("${entry.key} = ${entry.value}")
            }
        }
    }
    
    // Some values to be configured later
    var b = 0
    var c = 0
    
    tasks.register<Generator>("generate") {
        properties.put("a", 1)
        // Values have not been configured yet
        properties.put("b", providers.provider { b })
        properties.putAll(providers.provider { mapOf("c" to c, "d" to c + 1) })
    }
    
    // Configure the values. There is no need to reconfigure the task
    b = 2
    c = 3

Output of **`gradle consumer`**

    
    
    $ gradle generate
    
    > Task :generate
    a = 1
    b = 2
    c = 3
    d = 4
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

## Applying a convention to a property

Often you want to apply some _convention_ , or default value, to a property to
be used if no value has been configured for the property. You can use the
`convention()` method for this. This method accepts either a value or a
`Provider` and this will be used as the value until some other value is
configured.

Example 8. Property conventions

build.gradle

    
    
    task show {
        doLast {
            def property = objects.property(String)
    
            // Set a convention
            property.convention("convention 1")
            println("value = " + property.get())
    
            // Can replace the convention
            property.convention("convention 2")
            println("value = " + property.get())
    
            property.set("value")
    
            // Once a value is set, the convention is ignored
            property.convention("ignored convention")
            println("value = " + property.get())
        }
    }

build.gradle.kts

    
    
    tasks.register("show") {
        doLast {
            val property = objects.property(String::class)
    
            property.convention("convention 1")
            println("value = " + property.get())
    
            // Can replace the convention
            property.convention("convention 2")
            println("value = " + property.get())
    
            property.set("value")
            // Once a value is set, the convention is ignored
    
            property.convention("ignored convention")
            println("value = " + property.get())
        }
    }

Output of **`gradle show`**

    
    
    $ gradle show
    
    > Task :show
    value = convention 1
    value = convention 2
    value = value
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

## Making a property unmodifiable

Most properties of a task or project are intended to be configured by plugins
or build scripts and then the resulting value used to do something useful. For
example, a property that specifies the output directory for a compilation task
may start off with a value specified by a plugin, then a build script might
change the value to some custom location, then this value is used by the task
when it runs. However, once the task starts to run, we want to prevent any
further change to the property. This way we avoid errors that result from
different consumers, such as the task action or Gradle's up-to-date checks or
build caching or other tasks, using different values for the property.

Lazy properties provide several methods that you can use to disallow changes
to their value once the value has been configured. The
[finalizeValue()](../javadoc/org/gradle/api/provider/Property.html#finalizeValue--)
method calculates the _final_ value for the property and prevents further
changes to the property. When the value of the property comes from a
`Provider`, the provider is queried for its current value and the result
becomes the final value for the property. This final value replaces the
provider and the property no longer tracks the value of the provider. Calling
this method also makes a property instance unmodifiable and any further
attempts to change the value of the property will fail. Gradle automatically
makes the properties of a task final when the task starts execution.

The
[finalizeValueOnRead()](../javadoc/org/gradle/api/provider/HasConfigurableValue.html#finalizeValueOnRead--)
method is similar, except that the property's final value is not calculated
until the value of the property is queried. In other words, this method
calculates the final value lazily as required, whereas `finalizeValue()`
calculates the final value eagerly. This method can be used when the value may
be expensive to calculate or may not have been configured yet, but you also
want to ensure that all consumers of the property see the same value when they
query the value.

## Guidelines

This section will introduce guidelines to be successful with the Provider API.
To see those guidelines in action, have a look at [gradle-site-
plugin](https://github.com/gradle/gradle-site-plugin), a Gradle plugin
demonstrating established techniques and practices for plugin development.

  * The [Property](../javadoc/org/gradle/api/provider/Property.html) and [Provider](../javadoc/org/gradle/api/provider/Provider.html) types have all of the overloads you need to query or configure a value. For this reason, you should follow the following guidelines:

    * For configurable properties, expose the [Property](../javadoc/org/gradle/api/provider/Property.html) directly through a single getter.

    * For non-configurable properties, expose an [Provider](../javadoc/org/gradle/api/provider/Provider.html) directly through a single getter.

  * Avoid simplifying calls like `obj.getProperty().get()` and `obj.getProperty().set(T)` in your code by introducing additional getters and setters.

  * When migrating your plugin to use providers, follow these guidelines:

    * If it's a new property, expose it as a [Property](../javadoc/org/gradle/api/provider/Property.html) or [Provider](../javadoc/org/gradle/api/provider/Provider.html) using a single getter.

    * If it's incubating, change it to use a [Property](../javadoc/org/gradle/api/provider/Property.html) or [Provider](../javadoc/org/gradle/api/provider/Provider.html) using a single getter.

    * If it's a stable property, add a new [Property](../javadoc/org/gradle/api/provider/Property.html) or [Provider](../javadoc/org/gradle/api/provider/Provider.html) and deprecate the old one. You should wire the old getter/setters into the new property as appropriate.

## Future development

Going forward, new properties will use the Provider API. The Groovy Gradle DSL
adds convenience methods to make the use of Providers mostly transparent in
build scripts. Existing tasks will have their existing "raw" properties
replaced by Providers as needed and in a backwards compatible way. New tasks
will be designed with the Provider API.

## Provider Files API Reference

Use these types for _read-only_ values:

[Provider](../javadoc/org/gradle/api/provider/Provider.html)<[RegularFile](../javadoc/org/gradle/api/file/RegularFile.html)>

    

File on disk

Factories

    

  * [Provider.map(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-).

  * [Provider.flatMap(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-).

  * [DirectoryProperty.file(String)](../javadoc/org/gradle/api/file/DirectoryProperty.html#file-java.lang.String-)

[Provider](../javadoc/org/gradle/api/provider/Provider.html)<[Directory](../javadoc/org/gradle/api/file/Directory.html)>

    

Directory on disk

Factories

    

  * [Provider.map(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-).

  * [Provider.flatMap(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-).

  * [DirectoryProperty.dir(String)](../javadoc/org/gradle/api/file/DirectoryProperty.html#dir-java.lang.String-)

[FileCollection](../javadoc/org/gradle/api/file/FileCollection.html)

    

Unstructured collection of files

Factories

    

  * [Project.files(Object[])](../dsl/org.gradle.api.Project.html#org.gradle.api.Project:files\(java.lang.Object\[\]\))

  * [ProjectLayout.files(Object...)](../javadoc/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object...-)

  * [DirectoryProperty.files(Object...)](../javadoc/org/gradle/api/file/DirectoryProperty.html#files-java.lang.Object...-)

[FileTree](../javadoc/org/gradle/api/file/FileTree.html)

    

Hierarchy of files

Factories

    

  * [Project.fileTree(Object)](../dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree\(java.lang.Object\)) will produce a [ConfigurableFileTree](../javadoc/org/gradle/api/file/ConfigurableFileTree.html), or you can use [Project.zipTree(Object)](../javadoc/org/gradle/api/Project.html#zipTree-java.lang.Object-) and [Project.tarTree(Object)](../javadoc/org/gradle/api/Project.html#tarTree-java.lang.Object-)

  * [DirectoryProperty.getAsFileTree()](../javadoc/org/gradle/api/file/DirectoryProperty.html#getAsFileTree--)

## Property Files API Reference

Use these types for _mutable_ values:

[RegularFileProperty](../javadoc/org/gradle/api/file/RegularFileProperty.html)

    

File on disk

Factories

    

  * [ObjectFactory.fileProperty()](../javadoc/org/gradle/api/model/ObjectFactory.html#fileProperty--)

[DirectoryProperty](../javadoc/org/gradle/api/file/DirectoryProperty.html)

    

Directory on disk

Factories

    

  * [ObjectFactory.directoryProperty()](../javadoc/org/gradle/api/model/ObjectFactory.html#directoryProperty--)

[ConfigurableFileCollection](../javadoc/org/gradle/api/file/ConfigurableFileCollection.html)

    

Unstructured collection of files

Factories

    

  * [ObjectFactory.fileCollection()](../javadoc/org/gradle/api/model/ObjectFactory.html#fileCollection--)

[ConfigurableFileTree](../javadoc/org/gradle/api/file/ConfigurableFileTree.html)

    

Hierarchy of files

Factories

    

  * [ObjectFactory.fileTree()](../javadoc/org/gradle/api/model/ObjectFactory.html#fileTree--)

[SourceDirectorySet](../javadoc/org/gradle/api/file/SourceDirectorySet.html)

    

Hierarchy of source directories

Factories

    

  * [ObjectFactory.sourceDirectorySet(String, String)](../javadoc/org/gradle/api/model/ObjectFactory.html#sourceDirectorySet-java.lang.String-java.lang.String-)

## Lazy Collections API Reference

Use these types for _mutable_ values:

[ListProperty<T>](../javadoc/org/gradle/api/provider/ListProperty.html)

    

a property whose value is `List<T>`

Factories

    

  * [ObjectFactory.listProperty(Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-)

[SetProperty<T>](../javadoc/org/gradle/api/provider/SetProperty.html)

    

a property whose value is `Set<T>`

Factories

    

  * [ObjectFactory.setProperty(Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-)

## Lazy Objects API Reference

Use these types for _read only_ values:

[Provider<T>](../javadoc/org/gradle/api/provider/Provider.html)

    

a property whose value is an instance of `T`

Factories

    

  * [Provider.map(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-).

  * [Provider.flatMap(Transformer)](../javadoc/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-).

  * [ProviderFactory.provider(Callable)](../javadoc/org/gradle/api/provider/ProviderFactory.html#provider-java.util.concurrent.Callable-). Always prefer one of the other factory methods over this method.

Use these types for _mutable_ values:

[Property<T>](../javadoc/org/gradle/api/provider/Property.html)

    

a property whose value is an instance of `T`

Factories

    

  * [ObjectFactory.property(Class)](../javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-)

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

