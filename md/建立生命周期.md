

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Build Lifecycle

version 6.9-20201126230040+0000

Contents

  * Build phases
  * Settings file
  * Initialization
  * Configuration and execution of a single project build
  * Responding to the lifecycle in the build script

We said earlier that the core of Gradle is a language for dependency based
programming. In Gradle terms this means that you can define tasks and
dependencies between tasks. Gradle guarantees that these tasks are executed in
the order of their dependencies, and that each task is executed only once.
These tasks form a [Directed Acyclic
Graph](http://en.wikipedia.org/wiki/Directed_acyclic_graph). There are build
tools that build up such a dependency graph as they execute their tasks.
Gradle builds the complete dependency graph _before_ any task is executed.
This lies at the heart of Gradle and makes many things possible which would
not be possible otherwise.

Your build scripts configure this dependency graph. Therefore they are
strictly speaking _build configuration scripts_.

## Build phases

A Gradle build has three distinct phases.

Initialization

    

Gradle supports single and multi-project builds. During the initialization
phase, Gradle determines which projects are going to take part in the build,
and creates a [Project](../dsl/org.gradle.api.Project.html) instance for each
of these projects.

Configuration

    

During this phase the project objects are configured. The build scripts of
_all_ projects which are part of the build are executed.

Execution

    

Gradle determines the subset of the tasks, created and configured during the
configuration phase, to be executed. The subset is determined by the task name
arguments passed to the `gradle` command and the current directory. Gradle
then executes each of the selected tasks.

## Settings file

Beside the build script files, Gradle defines a settings file. The settings
file is determined by Gradle via a naming convention. The default name for
this file is `settings.gradle`. Later in this chapter we explain how Gradle
looks for a settings file.

The settings file is executed during the initialization phase. A multi-project
build must have a `settings.gradle` file in the root project of the multi-
project hierarchy. It is required because the settings file defines which
projects are taking part in the multi-project build (see [Authoring Multi-
Project Builds](multi_project_builds.html#multi_project_builds)). For a
single-project build, a settings file is optional. Besides defining the
included projects, you might need it to add libraries to your build script
classpath (see [Organizing Gradle
Projects](organizing_gradle_projects.html#organizing_gradle_projects)). Let's
first do some introspection with a single project build:

Example 1. Single project build

settings.gradle

    
    
    rootProject.name = 'basic'
    println 'This is executed during the initialization phase.'

build.gradle

    
    
    println 'This is executed during the configuration phase.'
    
    task configured {
        println 'This is also executed during the configuration phase.'
    }
    
    task test {
        doLast {
            println 'This is executed during the execution phase.'
        }
    }
    
    task testBoth {
    	doFirst {
    	  println 'This is executed first during the execution phase.'
    	}
    	doLast {
    	  println 'This is executed last during the execution phase.'
    	}
    	println 'This is executed during the configuration phase as well.'
    }

settings.gradle.kts

    
    
    rootProject.name = "basic"
    println("This is executed during the initialization phase.")

build.gradle.kts

    
    
    println("This is executed during the configuration phase.")
    
    tasks.register("configured") {
        println("This is also executed during the configuration phase.")
    }
    
    tasks.register("test") {
        doLast {
            println("This is executed during the execution phase.")
        }
    }
    
    tasks.register("testBoth") {
        doFirst {
            println("This is executed first during the execution phase.")
        }
        doLast {
            println("This is executed last during the execution phase.")
        }
        println("This is executed during the configuration phase as well.")
    }

### Output of **`gradle test testBoth`**

    
    
    > gradle test testBoth
    This is executed during the initialization phase.
    
    > Configure project :
    This is executed during the configuration phase.
    This is also executed during the configuration phase.
    This is executed during the configuration phase as well.
    
    > Task :test
    This is executed during the execution phase.
    
    > Task :testBoth
    This is executed first during the execution phase.
    This is executed last during the execution phase.
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed
    
    
    > gradle test testBoth
    This is executed during the initialization phase.
    
    > Configure project :
    This is executed during the configuration phase.
    This is executed during the configuration phase as well.
    
    > Task :test
    This is executed during the execution phase.
    
    > Task :testBoth
    This is executed first during the execution phase.
    This is executed last during the execution phase.
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed

For a build script, the property access and method calls are delegated to a
project object. Similarly property access and method calls within the settings
file is delegated to a settings object. Look at the
[Settings](../dsl/org.gradle.api.initialization.Settings.html) class in the
API documentation for more information.

## Initialization

How does Gradle know whether to do a single or multi-project build? If you
trigger a multi-project build from a directory with a `settings.gradle` file,
Gradle uses it to configure the build. Gradle also allows you to execute the
build from within any subproject taking part in the build.[1] If you execute
Gradle from within a project with no `settings.gradle` file, Gradle looks for
a `settings.gradle` file in the following way:

  * It looks for `settings.gradle` in parent directories.

  * If not found, the build is executed as a single project build.

  * If a `settings.gradle` file is found, Gradle checks if the current project is part of the multi-project hierarchy defined in the found `settings.gradle` file. If not, the build is executed as a single project build. Otherwise a multi-project build is executed.

What is the purpose of this behavior? Gradle needs to determine whether the
project you are in is a subproject of a multi-project build or not. Of course,
if it is a subproject, only the subproject and its dependent projects are
built, but Gradle needs to create the build configuration for the whole multi-
project build (see [Configuration and
Execution](multi_project_configuration_and_execution.html#configuration_and_execution)).
If the current project contains a `settings.gradle` file, the build is always
executed as:

  * a single project build, if the `settings.gradle` file does not define a multi-project hierarchy

  * a multi-project build, if the `settings.gradle` file does define a multi-project hierarchy.

The automatic search for a `settings.gradle` file only works for multi-project
builds with a default project layout where project paths match the physical
subproject layout on disk. Gradle supports arbitrary physical layouts for a
multi-project build, but for such arbitrary layouts you need to execute the
build from the directory where the settings file is located. For information
on how to run partial builds from the root, see [Executing tasks by their
fully qualified
name](intro_multi_project_builds.html#sec:executing_tasks_by_fully_qualified_name).

Gradle creates a Project object for every project taking part in the build.
For a multi-project build these are the projects specified in the Settings
object (plus the root project). Each project object has by default a name
equal to the name of its top level directory, and every project except the
root project has a parent project. Any project may have child projects.

## Configuration and execution of a single project build

For a single project build, the workflow of the _after initialization_ phases
are pretty simple. The build script is executed against the project object
that was created during the initialization phase. Then Gradle looks for tasks
with names equal to those passed as command line arguments. If these task
names exist, they are executed as a separate build in the order you have
passed them. The configuration and execution for multi-project builds is
discussed in [Configuration and
Execution](multi_project_configuration_and_execution.html#configuration_and_execution).

## Responding to the lifecycle in the build script

Your build script can receive notifications as the build progresses through
its lifecycle. These notifications generally take two forms: You can either
implement a particular listener interface, or you can provide a closure to
execute when the notification is fired. The examples below use closures. For
details on how to use the listener interfaces, refer to the API documentation.

### Project evaluation

You can receive a notification immediately before and after a project is
evaluated. This can be used to do things like performing additional
configuration once all the definitions in a build script have been applied, or
for some custom logging or profiling.

Below is an example which adds a `test` task to each project which has a
`hasTests` property value of true.

Example 2. Adding of test task to each project which has certain property set

build.gradle

    
    
    allprojects {
        afterEvaluate { project ->
            if (project.hasTests) {
                println "Adding test task to $project"
                project.task('test') {
                    doLast {
                        println "Running tests for $project"
                    }
                }
            }
        }
    }

project-a.gradle

    
    
    hasTests = true

build.gradle.kts

    
    
    allprojects {
        afterEvaluate {
            if (extra["hasTests"] as Boolean) {
                println("Adding test task to $project")
                tasks.register("test") {
                    doLast {
                        println("Running tests for $project")
                    }
                }
            }
        }
    }

project-a.gradle.kts

    
    
    extra["hasTests"] = true

Output of `gradle -q test`

    
    
    > gradle -q test
    Adding test task to project ':project-a'
    Running tests for project ':project-a'

This example uses method `Project.afterEvaluate()` to add a closure which is
executed after the project is evaluated.

It is also possible to receive notifications when any project is evaluated.
This example performs some custom logging of project evaluation. Notice that
the `afterProject` notification is received regardless of whether the project
evaluates successfully or fails with an exception.

Example 3. Notifications

build.gradle

    
    
    gradle.afterProject { project ->
        if (project.state.failure) {
            println "Evaluation of $project FAILED"
        } else {
            println "Evaluation of $project succeeded"
        }
    }

build.gradle.kts

    
    
    gradle.afterProject {
        if (state.failure != null) {
            println("Evaluation of $project FAILED")
        } else {
            println("Evaluation of $project succeeded")
        }
    }

#### Output of **`gradle -q test`**

    
    
    > gradle -q test
    Evaluation of root project 'build-project-evaluate-events' succeeded
    Evaluation of project ':project-a' succeeded
    Evaluation of project ':project-b' FAILED
    
    FAILURE: Build failed with an exception.
    
    * Where:
    Build file '/home/user/gradle/samples/project-b.gradle' line: 1
    
    * What went wrong:
    A problem occurred evaluating project ':project-b'.
    > broken
    
    * Try:
    Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
    
    * Get more help at https://help.gradle.org
    
    BUILD FAILED in 0s
    
    
    > gradle -q test
    Evaluation of root project 'build-project-evaluate-events' succeeded
    Evaluation of project ':project-a' succeeded
    Evaluation of project ':project-b' FAILED
    
    FAILURE: Build failed with an exception.
    
    * Where:
    Build file '/home/user/gradle/samples/project-b.gradle.kts' line: 1
    
    * What went wrong:
    broken
    
    * Try:
    Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
    
    * Get more help at https://help.gradle.org
    
    BUILD FAILED in 0s

You can also add a
[ProjectEvaluationListener](../javadoc/org/gradle/api/ProjectEvaluationListener.html)
to the [Gradle](../dsl/org.gradle.api.invocation.Gradle.html) to receive these
events.

### Task creation

You can receive a notification immediately after a task is added to a project.
This can be used to set some default values or add behaviour before the task
is made available in the build file.

The following example sets the `srcDir` property of each task as it is
created.

Example 4. Setting of certain property to all tasks

build.gradle

    
    
    tasks.whenTaskAdded { task ->
        task.ext.srcDir = 'src/main/java'
    }
    
    task a
    
    println "source dir is $a.srcDir"

build.gradle.kts

    
    
    tasks.whenTaskAdded {
        extra["srcDir"] = "src/main/java"
    }
    
    val a by tasks.registering
    
    println("source dir is ${a.get().extra["srcDir"]}")

Output of **`gradle -q a`**

    
    
    > gradle -q a
    source dir is src/main/java

You can also add an [Action](../javadoc/org/gradle/api/Action.html) to a
[TaskContainer](../javadoc/org/gradle/api/tasks/TaskContainer.html) to receive
these events.

### Task execution graph ready

You can receive a notification immediately after the task execution graph has
been populated.

You can also add a
[TaskExecutionGraphListener](../javadoc/org/gradle/api/execution/TaskExecutionGraphListener.html)
to the
[TaskExecutionGraph](../javadoc/org/gradle/api/execution/TaskExecutionGraph.html)
to receive these events.

### Task execution

You can receive a notification immediately before and after any task is
executed.

The following example logs the start and end of each task execution. Notice
that the `afterTask` notification is received regardless of whether the task
completes successfully or fails with an exception.

Example 5. Logging of start and end of each task execution

build.gradle

    
    
    task ok
    
    task broken(dependsOn: ok) {
        doLast {
            throw new RuntimeException('broken')
        }
    }
    
    gradle.taskGraph.beforeTask { Task task ->
        println "executing $task ..."
    }
    
    gradle.taskGraph.afterTask { Task task, TaskState state ->
        if (state.failure) {
            println "FAILED"
        }
        else {
            println "done"
        }
    }

build.gradle.kts

    
    
    tasks.register("ok")
    
    tasks.register("broken") {
        dependsOn("ok")
        doLast {
            throw RuntimeException("broken")
        }
    }
    
    gradle.taskGraph.beforeTask {
        println("executing $this ...")
    }
    
    gradle.taskGraph.afterTask {
        if (state.failure != null) {
            println("FAILED")
        } else {
            println("done")
        }
    }

#### Output of **`gradle -q broken`**

    
    
    > gradle -q broken
    executing task ':ok' ...
    done
    executing task ':broken' ...
    FAILED
    
    FAILURE: Build failed with an exception.
    
    * Where:
    Build file '/home/user/gradle/samples/build.gradle' line: 5
    
    * What went wrong:
    Execution failed for task ':broken'.
    > broken
    
    * Try:
    Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
    
    * Get more help at https://help.gradle.org
    
    BUILD FAILED in 0s
    
    
    > gradle -q broken
    executing task ':ok' ...
    done
    executing task ':broken' ...
    FAILED
    
    FAILURE: Build failed with an exception.
    
    * What went wrong:
    Execution failed for task ':broken'.
    > broken
    
    * Try:
    Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
    
    * Get more help at https://help.gradle.org
    
    BUILD FAILED in 0s

You can also use a
[TaskExecutionListener](../javadoc/org/gradle/api/execution/TaskExecutionListener.html)
to the
[TaskExecutionGraph](../javadoc/org/gradle/api/execution/TaskExecutionGraph.html)
to receive these events.

* * *

1. Gradle supports partial multi-project builds (see [Executing Multi-Project Builds](intro_multi_project_builds.html)). 

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

Â© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

