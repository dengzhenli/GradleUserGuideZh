

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Using Gradle Plugins

version 6.9-20201126230040+0000

Contents

  * What plugins do
  * Types of plugins
  * Using plugins
  * Binary plugins
  * Script plugins
  * Finding community plugins
  * More on plugins

Gradle at its core intentionally provides very little for real world
automation. All of the useful features, like the ability to compile Java code,
are added by _plugins_. Plugins add new tasks (e.g.
[JavaCompile](../dsl/org.gradle.api.tasks.compile.JavaCompile.html)), domain
objects (e.g. [SourceSet](../dsl/org.gradle.api.tasks.SourceSet.html)),
conventions (e.g. Java source is located at `src/main/java`) as well as
extending core objects and objects from other plugins.

In this chapter we discuss how to use plugins and the terminology and concepts
surrounding plugins.

## What plugins do

Applying a plugin to a project allows the plugin to extend the project's
capabilities. It can do things such as:

  * Extend the Gradle model (e.g. add new DSL elements that can be configured)

  * Configure the project according to conventions (e.g. add new tasks or configure sensible defaults)

  * Apply specific configuration (e.g. add organizational repositories or enforce standards)

By applying plugins, rather than adding logic to the project build script, we
can reap a number of benefits. Applying plugins:

  * Promotes reuse and reduces the overhead of maintaining similar logic across multiple projects

  * Allows a higher degree of modularization, enhancing comprehensibility and organization

  * Encapsulates imperative logic and allows build scripts to be as declarative as possible

## Types of plugins

There are two general types of plugins in Gradle, _binary_ plugins and
_script_ plugins. Binary plugins are written either programmatically by
implementing [Plugin](../javadoc/org/gradle/api/Plugin.html) interface or
declaratively using one of Gradle's DSL languages. Binary plugins can reside
within a build script, within the project hierarchy or externally in a plugin
jar. Script plugins are additional build scripts that further configure the
build and usually implement a declarative approach to manipulating the build.
They are typically used within a build although they can be externalized and
accessed from a remote location.

A plugin often starts out as a script plugin (because they are easy to write)
and then, as the code becomes more valuable, it's migrated to a binary plugin
that can be easily tested and shared between multiple projects or
organizations.

## Using plugins

To use the build logic encapsulated in a plugin, Gradle needs to perform two
steps. First, it needs to _resolve_ the plugin, and then it needs to _apply_
the plugin to the target, usually a
[Project](../dsl/org.gradle.api.Project.html).

_Resolving_ a plugin means finding the correct version of the jar which
contains a given plugin and adding it to the script classpath. Once a plugin
is resolved, its API can be used in a build script. Script plugins are self-
resolving in that they are resolved from the specific file path or URL
provided when applying them. Core binary plugins provided as part of the
Gradle distribution are automatically resolved.

_Applying_ a plugin means actually executing the plugin's
[Plugin.apply(T)](../javadoc/org/gradle/api/Plugin.html#apply-T-) on the
Project you want to enhance with the plugin. Applying plugins is _idempotent_.
That is, you can safely apply any plugin multiple times without side effects.

The most common use case for using a plugin is to both resolve the plugin and
apply it to the current project. Since this is such a common use case, it's
recommended that build authors use the plugins DSL to both resolve and apply
plugins in one step.

## Binary plugins

You apply plugins by their _plugin id_ , which is a globally unique
identifier, or name, for plugins. Core Gradle plugins are special in that they
provide short names, such as `'java'` for the core
[JavaPlugin](../javadoc/org/gradle/api/plugins/JavaPlugin.html). All other
binary plugins must use the fully qualified form of the plugin id (e.g.
`com.github.foo.bar`), although some legacy plugins may still utilize a short,
unqualified form. Where you put the plugin id depends on whether you are using
the plugins DSL or the buildscript block.

### Locations of binary plugins

A plugin is simply any class that implements the
[Plugin](../javadoc/org/gradle/api/Plugin.html) interface. Gradle provides the
core plugins (e.g. `JavaPlugin`) as part of its distribution which means they
are automatically resolved. However, non-core binary plugins need to be
resolved before they can be applied. This can be achieved in a number of ways:

  * Including the plugin from the plugin portal or a custom repository using the plugins DSL (see Applying plugins using the plugins DSL).

  * Including the plugin from an external jar defined as a buildscript dependency (see Applying plugins using the buildscript block).

  * Defining the plugin as a source file under the buildSrc directory in the project (see [Using buildSrc to extract functional logic](organizing_gradle_projects.html#sec:build_sources)).

  * Defining the plugin as an inline class declaration inside a build script.

For more on defining your own plugins, see [Custom
Plugins](custom_plugins.html#custom_plugins).

### Applying plugins with the plugins DSL

The plugins DSL provides a succinct and convenient way to declare plugin
dependencies. It works with the [Gradle plugin
portal](http://plugins.gradle.org) to provide easy access to both core and
community plugins. The plugins DSL block configures an instance of
[PluginDependenciesSpec](../javadoc/org/gradle/plugin/use/PluginDependenciesSpec.html).

To apply a core plugin, the short name can be used:

Example 1. Applying a core plugin

build.gradle

    
    
    plugins {
        id 'java'
    }

build.gradle.kts

    
    
    plugins {
        java
    }

To apply a community plugin from the portal, the fully qualified plugin id
must be used:

Example 2. Applying a community plugin

build.gradle

    
    
    plugins {
        id 'com.jfrog.bintray' version '0.4.1'
    }

build.gradle.kts

    
    
    plugins {
        id("com.jfrog.bintray") version "0.4.1"
    }

See
[PluginDependenciesSpec](../javadoc/org/gradle/plugin/use/PluginDependenciesSpec.html)
for more information on using the Plugin DSL.

#### Limitations of the plugins DSL

This way of adding plugins to a project is much more than a more convenient
syntax. The plugins DSL is processed in a way which allows Gradle to determine
the plugins in use very early and very quickly. This allows Gradle to do smart
things such as:

  * Optimize the loading and reuse of plugin classes.

  * Allow different plugins to use different versions of dependencies.

  * Provide editors detailed information about the potential properties and values in the buildscript for editing assistance.

This requires that plugins be specified in a way that Gradle can easily and
quickly extract, before executing the rest of the build script. It also
requires that the definition of plugins to use be somewhat static.

There are some key differences between the `plugins {}` block mechanism and
the “traditional” `apply()` method mechanism. There are also some constraints,
some of which are temporary limitations while the mechanism is still being
developed and some are inherent to the new approach.

##### Constrained Syntax

The `plugins {}` block does not support arbitrary code. It is constrained, in
order to be idempotent (produce the same result every time) and side effect
free (safe for Gradle to execute at any time).

The form is:

build.gradle

    
    
    plugins {
        id «plugin id»                                            __**(1)**
        id «plugin id» version «plugin version» [apply «false»]   __**(2)**
    }

__**1** | for core Gradle plugins or plugins already available to the build
script  
---|---  
__**2** | for binary Gradle plugins that need to be resolved  
  
build.gradle.kts

    
    
    plugins {
        `«plugin id»`                                             __**(1)**
        id(«plugin id»)                                           __**(2)**
        id(«plugin id») version «plugin version» [apply «false»]  __**(3)**
    }

__**1** | for core Gradle plugins  
---|---  
__**2** | for core Gradle plugins or plugins already available to the build
script  
__**3** | for binary Gradle plugins that need to be resolved  
  
Where `«plugin id»` and `«plugin version»` must be constant, literal, strings
and the `apply` statement with a `boolean` can be used to disable the default
behavior of applying the plugin immediately (e.g. you want to apply it only in
`subprojects`). No other statements are allowed; their presence will cause a
compilation error.

Where `«plugin id»`, in case `#1` is a static Kotlin extension property, named
after the core plugin ID ; and in cases `#2` and `#3` is a string. `«plugin
version»` is also a string. The `apply` statement with a `boolean` can be used
to disable the default behavior of applying the plugin immediately (e.g. you
want to apply it only in `subprojects`).

See plugin version management if you want to use a variable to define a plugin
version.

The `plugins {}` block must also be a top level statement in the buildscript.
It cannot be nested inside another construct (e.g. an if-statement or for-
loop).

##### Can only be used in build scripts and settings file

The `plugins {}` block can currently only be used in a project's build script
and the settings.gradle file. It cannot be used in script plugins or init
scripts.

_Future versions of Gradle will remove this restriction._

If the restrictions of the `plugins {}` block are prohibitive, the recommended
approach is to apply plugins using the buildscript {} block.

#### Applying external plugins with same version to subprojects

If you have a [multi-project
build](multi_project_builds.html#multi_project_builds), you probably want to
apply plugins to some or all of the subprojects in your build, but not to the
`root` project. The default behavior of the `plugins {}` block is to
immediately `resolve` _and_ `apply` the plugins. But, you can use the `apply
false` syntax to tell Gradle not to apply the plugin to the current project
and then use the `plugins {}` block without the version in subprojects' build
scripts:

Example 3. Applying plugins only on certain subprojects

settings.gradle

    
    
    include 'hello-a'
    include 'hello-b'
    include 'goodbye-c'

build.gradle

    
    
    plugins {
        id 'com.example.hello' version '1.0.0' apply false
        id 'com.example.goodbye' version '1.0.0' apply false
    }

hello-a/build.gradle

    
    
    plugins {
        id 'com.example.hello'
    }

hello-b/build.gradle

    
    
    plugins {
        id 'com.example.hello'
    }

goodbye-c/build.gradle

    
    
    plugins {
        id 'com.example.goodbye'
    }

settings.gradle.kts

    
    
    include("hello-a")
    include("hello-b")
    include("goodbye-c")

build.gradle.kts

    
    
    plugins {
        id("com.example.hello") version "1.0.0" apply false
        id("com.example.goodbye") version "1.0.0" apply false
    }

hello-a/build.gradle.kts

    
    
    plugins {
        id("com.example.hello")
    }

hello-b/build.gradle.kts

    
    
    plugins {
        id("com.example.hello")
    }

goodbye-c/build.gradle.kts

    
    
    plugins {
        id("com.example.goodbye")
    }

Even better - you can encapsulate the versions of external plugins by
composing the build logic using your own [convention
plugins](sharing_build_logic_between_subprojects.html#sec:convention_plugins).

#### Applying plugins from the _buildSrc_ directory

You can apply plugins that reside in a project's _buildSrc_ directory as long
as they have a defined ID. The following example shows how to tie a plugin
implementation class — `my.MyPlugin` — defined in _buildSrc_ to the ID "my-
plugin":

Example 4. Defining a buildSrc plugin with an ID

buildSrc/build.gradle

    
    
    plugins {
        id 'java-gradle-plugin'
    }
    
    gradlePlugin {
        plugins {
            myPlugins {
                id = 'my-plugin'
                implementationClass = 'my.MyPlugin'
            }
        }
    }

buildSrc/build.gradle.kts

    
    
    plugins {
        `java-gradle-plugin`
    }
    
    gradlePlugin {
        plugins {
            create("myPlugins") {
                id = "my-plugin"
                implementationClass = "my.MyPlugin"
            }
        }
    }

The plugin can then be applied by ID as normal:

Example 5. Applying a plugin from buildSrc

build.gradle

    
    
    plugins {
        id 'my-plugin'
    }

build.gradle.kts

    
    
    plugins {
        id("my-plugin")
    }

#### Plugin Management

The `pluginManagement {}` block may only appear in either the
`settings.gradle` file, where it must be the first block in the file, or in an
[Initialization Script](init_scripts.html#init_scripts).

Example 6. Configuring pluginManagement per-project and globally

settings.gradle

    
    
    pluginManagement {
        plugins {
        }
        resolutionStrategy {
        }
        repositories {
        }
    }
    rootProject.name = 'plugin-management'

init.gradle

    
    
    settingsEvaluated { settings ->
        settings.pluginManagement {
            plugins {
            }
            resolutionStrategy {
            }
            repositories {
            }
        }
    }

settings.gradle.kts

    
    
    pluginManagement {
        plugins {
        }
        resolutionStrategy {
        }
        repositories {
        }
    }
    rootProject.name = "plugin-management"

init.gradle.kts

    
    
    settingsEvaluated {
        pluginManagement {
            plugins {
            }
            resolutionStrategy {
            }
            repositories {
            }
        }
    }

##### Custom Plugin Repositories

By default, the `plugins {}` DSL resolves plugins from the public [Gradle
Plugin Portal.](https://plugins.gradle.org) Many build authors would also like
to resolve plugins from private Maven or Ivy repositories because the plugins
contain proprietary implementation details, or just to have more control over
what plugins are available to their builds.

To specify custom plugin repositories, use the `repositories {}` block inside
`pluginManagement {}`:

Example 7. Example: Using plugins from custom plugin repositories.

settings.gradle

    
    
    pluginManagement {
        repositories {
            maven {
                url './maven-repo'
            }
            gradlePluginPortal()
            ivy {
                url './ivy-repo'
            }
        }
    }

settings.gradle.kts

    
    
    pluginManagement {
        repositories {
            maven(url = "./maven-repo")
            gradlePluginPortal()
            ivy(url = "./ivy-repo")
        }
    }

This tells Gradle to first look in the Maven repository at `../maven-repo`
when resolving plugins and then to check the Gradle Plugin Portal if the
plugins are not found in the Maven repository. If you don't want the Gradle
Plugin Portal to be searched, omit the `gradlePluginPortal()` line. Finally,
the Ivy repository at `../ivy-repo` will be checked.

##### Plugin Version Management

A `plugins {}` block inside `pluginManagement {}` allows all plugin versions
for the build to be defined in a single location. Plugins can then be applied
by id to any build script via the `plugins {}` block.

One benefit of setting plugin versions this way is that the
`pluginManagement.plugins {}` does not have the same constrained syntax as the
build script `plugins {}` block. This allows plugin versions to be taken from
`gradle.properties`, or loaded via another mechanism.

Example 8. Example: Managing plugin versions via `pluginManagement`.

settings.gradle

    
    
    pluginManagement {
      plugins {
            id 'com.example.hello' version "${helloPluginVersion}"
        }
    }

build.gradle

    
    
    plugins {
        id 'com.example.hello'
    }

gradle.properties

    
    
    helloPluginVersion=1.0.0

settings.gradle.kts

    
    
    pluginManagement {
      val helloPluginVersion: String by settings
      plugins {
        id("com.example.hello") version "${helloPluginVersion}"
      }
    }

build.gradle.kts

    
    
    plugins {
        id("com.example.hello")
    }

gradle.properties

    
    
    helloPluginVersion=1.0.0

The plugin version is loaded from `gradle.properties` and configured in the
settings script, allowing the plugin to be added to any project without
specifying the version.

#### Plugin Resolution Rules

Plugin resolution rules allow you to modify plugin requests made in `plugins
{}` blocks, e.g. changing the requested version or explicitly specifying the
implementation artifact coordinates.

To add resolution rules, use the `resolutionStrategy {}` inside the
`pluginManagement {}` block:

Example 9. Plugin resolution strategy.

settings.gradle

    
    
    pluginManagement {
        resolutionStrategy {
            eachPlugin {
                if (requested.id.namespace == 'com.example') {
                    useModule('com.example:sample-plugins:1.0.0')
                }
            }
        }
        repositories {
            maven {
                url './maven-repo'
            }
            gradlePluginPortal()
            ivy {
                url './ivy-repo'
            }
        }
    }

settings.gradle.kts

    
    
    pluginManagement {
        resolutionStrategy {
            eachPlugin {
                if (requested.id.namespace == "com.example") {
                    useModule("com.example:sample-plugins:1.0.0")
                }
            }
        }
        repositories {
            maven {
                url = uri("./maven-repo")
            }
            gradlePluginPortal()
            ivy {
                url = uri("./ivy-repo")
            }
        }
    }

This tells Gradle to use the specified plugin implementation artifact instead
of using its built-in default mapping from plugin ID to Maven/Ivy coordinates.

Custom Maven and Ivy plugin repositories must contain plugin marker artifacts
in addition to the artifacts which actually implement the plugin. For more
information on publishing plugins to custom repositories read [Gradle Plugin
Development Plugin](java_gradle_plugin.html#java_gradle_plugin).

See
[PluginManagementSpec](../javadoc/org/gradle/plugin/management/PluginManagementSpec.html)
for complete documentation for using the `pluginManagement {}` block.

### Plugin Marker Artifacts

Since the `plugins {}` DSL block only allows for declaring plugins by their
globally unique plugin `id` and `version` properties, Gradle needs a way to
look up the coordinates of the plugin implementation artifact. To do so,
Gradle will look for a Plugin Marker Artifact with the coordinates
`plugin.id:plugin.id.gradle.plugin:plugin.version`. This marker needs to have
a dependency on the actual plugin implementation. Publishing these markers is
automated by the [java-gradle-
plugin](java_gradle_plugin.html#java_gradle_plugin).

For example, the following complete sample from the `sample-plugins` project
shows how to publish a `com.example.hello` plugin and a `com.example.goodbye`
plugin to both an Ivy and Maven repository using the combination of the [java-
gradle-plugin](java_gradle_plugin.html#java_gradle_plugin), the [maven-
publish](publishing_maven.html#publishing_maven) plugin, and the [ivy-
publish](publishing_ivy.html#publishing_ivy) plugin.

Example 10. Complete Plugin Publishing Sample

build.gradle

    
    
    plugins {
        id 'java-gradle-plugin'
        id 'maven-publish'
        id 'ivy-publish'
    }
    
    group 'com.example'
    version '1.0.0'
    
    gradlePlugin {
        plugins {
            hello {
                id = 'com.example.hello'
                implementationClass = 'com.example.hello.HelloPlugin'
            }
            goodbye {
                id = 'com.example.goodbye'
                implementationClass = 'com.example.goodbye.GoodbyePlugin'
            }
        }
    }
    
    publishing {
        repositories {
            maven {
                url '../../consuming/maven-repo'
            }
            ivy {
                url '../../consuming/ivy-repo'
            }
        }
    }

build.gradle.kts

    
    
    plugins {
        `java-gradle-plugin`
        `maven-publish`
        `ivy-publish`
    }
    
    group = "com.example"
    version = "1.0.0"
    
    gradlePlugin {
        plugins {
            create("hello") {
                id = "com.example.hello"
                implementationClass = "com.example.hello.HelloPlugin"
            }
            create("goodbye") {
                id = "com.example.goodbye"
                implementationClass = "com.example.goodbye.GoodbyePlugin"
            }
        }
    }
    
    publishing {
        repositories {
            maven {
                url = uri("../../consuming/maven-repo")
            }
            ivy {
                url = uri("../../consuming/ivy-repo")
            }
        }
    }

Running `gradle publish` in the sample directory causes the following repo
layouts to exist:

![pluginMarkers](img/pluginMarkers.png)

### Legacy Plugin Application

With the introduction of the plugins DSL, users should have little reason to
use the legacy method of applying plugins. It is documented here in case a
build author cannot use the plugins DSL due to restrictions in how it
currently works.

#### Applying Binary Plugins

Example 11. Applying a binary plugin

build.gradle

    
    
    apply plugin: 'java'

build.gradle.kts

    
    
    apply(plugin = "java")

Plugins can be applied using a _plugin id_. In the above case, we are using
the short name ‘`java`’ to apply the
[JavaPlugin](../javadoc/org/gradle/api/plugins/JavaPlugin.html).

Rather than using a plugin id, plugins can also be applied by simply
specifying the class of the plugin:

Example 12. Applying a binary plugin by type

build.gradle

    
    
    apply plugin: JavaPlugin

build.gradle.kts

    
    
    apply<JavaPlugin>()

The `JavaPlugin` symbol in the above sample refers to the
[JavaPlugin](../javadoc/org/gradle/api/plugins/JavaPlugin.html). This class
does not strictly need to be imported as the `org.gradle.api.plugins` package
is automatically imported in all build scripts (see [Default
imports](writing_build_scripts.html#script-default-imports)).

Furthermore, it is not necessary to append `.class` to identify a class
literal in Groovy as it is in Java.

Furthermore, one need to append the `::class` suffix to identify a class
literal in Kotlin instead of `.class` in Java.

#### Applying plugins with the buildscript block

Binary plugins that have been published as external jar files can be added to
a project by adding the plugin to the build script classpath and then applying
the plugin. External jars can be added to the build script classpath using the
`buildscript {}` block as described in [External dependencies for the build
script](tutorial_using_tasks.html#sec:build_script_external_dependencies).

Example 13. Applying a plugin with the buildscript block

build.gradle

    
    
    buildscript {
        repositories {
            jcenter()
        }
        dependencies {
            classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:0.4.1'
        }
    }
    
    apply plugin: 'com.jfrog.bintray'

build.gradle.kts

    
    
    buildscript {
        repositories {
            jcenter()
        }
        dependencies {
            classpath("com.jfrog.bintray.gradle:gradle-bintray-plugin:0.4.1")
        }
    }
    
    apply(plugin = "com.jfrog.bintray")

## Script plugins

Example 14. Applying a script plugin

build.gradle

    
    
    apply from: 'other.gradle'

build.gradle.kts

    
    
    apply(from = "other.gradle.kts")

Script plugins are automatically resolved and can be applied from a script on
the local filesystem or at a remote location. Filesystem locations are
relative to the project directory, while remote script locations are specified
with an HTTP URL. Multiple script plugins (of either form) can be applied to a
given target.

## Finding community plugins

Gradle has a vibrant community of plugin developers who contribute plugins for
a wide variety of capabilities. The Gradle [plugin
portal](https://plugins.gradle.org) provides an interface for searching and
exploring community plugins.

## More on plugins

This chapter aims to serve as an introduction to plugins and Gradle and the
role they play. For more information on the inner workings of plugins, see
[Custom Plugins](custom_plugins.html#custom_plugins).

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

