

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Locking dependency versions

version 6.7.1

Contents

  * Enabling locking on configurations
  * Generating and updating dependency locks
  * Lock state location and format
  * Running a build with lock state present
  * Selectively updating lock state entries
  * Disabling dependency locking
  * Single lock file per project
  * Ignoring specific dependencies from the lock state
  * Locking limitations
  * Nebula locking plugin

Use of dynamic dependency versions (e.g. `1.+` or `[1.0,2.0)`) makes builds
non-deterministic. This causes builds to break without any obvious change, and
worse, can be caused by a transitive dependency that the build author has no
control over.

To achieve [reproducible builds](https://reproducible-builds.org/), it is
necessary to _lock_ versions of dependencies and transitive dependencies such
that a build with the same inputs will always resolve the same module
versions. This is called _dependency locking_.

It enables, amongst others, the following scenarios:

  * Companies dealing with multi repositories no longer need to rely on `-SNAPSHOT` or changing dependencies, which sometimes result in cascading failures when a dependency introduces a bug or incompatibility. Now dependencies can be declared against major or minor version range, enabling to test with the latest versions on CI while leveraging locking for stable developer builds.

  * Teams that want to always use the latest of their dependencies can use dynamic versions, locking their dependencies only for releases. The release tag will contain the lock states, allowing that build to be fully reproducible when bug fixes need to be developed.

Combined with [publishing resolved
versions](publishing_maven.html#publishing_maven:resolved_dependencies), you
can also replace the declared dynamic version part at publication time.
Consumers will instead see the versions that your release resolved.

Locking is enabled per [dependency
configuration](declaring_dependencies.html#sec:what-are-dependency-
configurations). Once enabled, you must create an initial lock state. It will
cause Gradle to verify that resolution results do not change, resulting in the
same selected dependencies even if newer versions are produced. Modifications
to your build that would impact the resolved set of dependencies will cause it
to fail. This makes sure that changes, either in published dependencies or
build definitions, do not alter resolution without adapting the lock state.

__ |

Dependency locking makes sense only with [dynamic
versions](dynamic_versions.html#sub:declaring_dependency_with_dynamic_version).
It will have no impact on [changing
versions](dynamic_versions.html#sub:declaring_dependency_with_changing_version)
(like `-SNAPSHOT`) whose coordinates remain the same, though the content may
change. Gradle will even emit a warning when persisting lock state and
changing dependencies are present in the resolution result.  
  
---|---  
  
## Enabling locking on configurations

Locking of a configuration happens through the
[ResolutionStrategy](../dsl/org.gradle.api.artifacts.ResolutionStrategy.html):

Example 1. Locking a specific configuration

build.gradle

    
    
    configurations {
        compileClasspath {
            resolutionStrategy.activateDependencyLocking()
        }
    }

build.gradle.kts

    
    
    configurations.compileClasspath {
        resolutionStrategy.activateDependencyLocking()
    }

Or the following, as a way to lock all configurations:

Example 2. Locking all configurations

build.gradle

    
    
    dependencyLocking {
        lockAllConfigurations()
    }

build.gradle.kts

    
    
    dependencyLocking {
        lockAllConfigurations()
    }

__ |

Only configurations that can be resolved will have lock state attached to
them. Applying locking on non resolvable-configurations is simply a no-op.  
  
---|---  
  
__ |

The above will lock all _project_ configurations, but not the _buildscript_
ones.  
  
---|---  
  
You can also disable locking on a specific configuration. This can be useful
if a plugin configured locking on all configurations but you happen to add one
that should not be locked.

Example 3. Unlocking a specific configuration

build.gradle

    
    
    configurations {
        compileClasspath {
            resolutionStrategy.deactivateDependencyLocking()
        }
    }

build.gradle.kts

    
    
    configurations.compileClasspath {
        resolutionStrategy.deactivateDependencyLocking()
    }

### Locking buildscript classpath configuration

If you apply plugins to your build, you may want to leverage dependency
locking there as well. In order to lock the [`classpath`
configuration](plugins.html#sec:applying_plugins_buildscript) used for script
plugins, do the following:

Example 4. Locking buildscript classpath configuration

build.gradle

    
    
    buildscript {
        configurations.classpath {
            resolutionStrategy.activateDependencyLocking()
        }
    }

build.gradle.kts

    
    
    buildscript {
        configurations.classpath {
            resolutionStrategy.activateDependencyLocking()
        }
    }

## Generating and updating dependency locks

In order to generate or update lock state, you specify the `--write-locks`
command line argument in addition to the normal tasks that would trigger
configurations to be resolved. This will cause the creation of lock state for
each resolved configuration in that build execution. Note that if lock state
existed previously, it is overwritten.

### Lock all configurations in one build execution

When locking multiple configurations, you may want to lock them all at once,
during a single build execution.

For this, you have two options:

  * Run `gradle dependencies --write-locks`. This will effectively lock all resolvable configurations that have locking enabled. Note that in a multi project setup, `dependencies` only is executed on _one_ project, the root one in this case.

  * Declare a custom task that will resolve all configurations

Example 5. Resolving all configurations

build.gradle

    
    
    task resolveAndLockAll {
        doFirst {
            assert gradle.startParameter.writeDependencyLocks
        }
        doLast {
            configurations.findAll {
                // Add any custom filtering on the configurations to be resolved
                it.canBeResolved
            }.each { it.resolve() }
        }
    }

build.gradle.kts

    
    
    tasks.register("resolveAndLockAll") {
        doFirst {
            require(gradle.startParameter.isWriteDependencyLocks)
        }
        doLast {
            configurations.filter {
                // Add any custom filtering on the configurations to be resolved
                it.isCanBeResolved
            }.forEach { it.resolve() }
        }
    }

That second option, with proper choosing of configurations, can be the only
option in the native world, where not all configurations can be resolved on a
single platform.

## Lock state location and format

Lock state will be preserved in a file located in the folder
`gradle/dependency-locks` inside the project or subproject directory. Each
file is named by the configuration it locks and has the `lockfile` extension.
The one exception to this rule is for configurations for the [buildscript
itself](plugins.html#sec:applying_plugins_buildscript). In that case the
configuration name will be prefixed with `buildscript-`.

The content of the file is a module notation per line, with a header giving
some context. Module notations are ordered alphabetically, to ease diffs.

gradle/dependency-locks/compileClasspath.lockfile

    
    
    # This is a Gradle generated file for dependency locking.
    # Manual edits can break the build and are not advised.
    # This file is expected to be part of source control.
    org.springframework:spring-beans:5.0.5.RELEASE
    org.springframework:spring-core:5.0.5.RELEASE
    org.springframework:spring-jcl:5.0.5.RELEASE

which matches the following dependency declaration:

Example 6. Dynamic dependency declaration

build.gradle

    
    
    dependencies {
        implementation 'org.springframework:spring-beans:[5.0,6.0)'
    }

build.gradle.kts

    
    
    dependencies {
        implementation("org.springframework:spring-beans:[5.0,6.0)")
    }

## Running a build with lock state present

The moment a build needs to resolve a configuration that has locking enabled
and it finds a matching lock state, it will use it to verify that the given
configuration still resolves the same versions.

A successful build indicates that the same dependencies are used as stored in
the lock state, regardless if new versions matching the dynamic selector have
been produced.

The complete validation is as follows:

  * Existing entries in the lock state must be matched in the build

    * A version mismatch or missing resolved module causes a build failure

  * Resolution result must not contain extra dependencies compared to the lock state

### Fine tuning dependency locking behaviour with lock mode

While the default lock mode behaves as described above, two other modes are
available:

Strict mode

    

In this mode, in addition to the validations above, dependency locking will
fail if a configuration marked as _locked_ does not have lock state associated
with it.

Lenient mode

    

In this mode, dependency locking will still pin dynamic versions but otherwise
changes to the dependency resolution are no longer errors.

The lock mode can be controlled from the `dependencyLocking` block as shown
below:

Example 7. Setting the lock mode

build.gradle

    
    
    dependencyLocking {
        lockMode = LockMode.STRICT
    }

build.gradle.kts

    
    
    dependencyLocking {
        lockMode.set(LockMode.STRICT)
    }

## Selectively updating lock state entries

In order to update only specific modules of a configuration, you can use the
`--update-locks` command line flag. It takes a comma (`,`) separated list of
module notations. In this mode, the existing lock state is still used as input
to resolution, filtering out the modules targeted by the update.

    
    
    ❯ gradle classes --update-locks org.apache.commons:commons-lang3,org.slf4j:slf4j-api

Wildcards, indicated with `*`, can be used in the group or module name. They
can be the only character or appear at the end of the group or module
respectively. The following wildcard notation examples are valid:

  * `org.apache.commons:*`: will let all modules belonging to group `org.apache.commons` update

  * `*:guava`: will let all modules named `guava`, whatever their group, update

  * `org.springframework.spring*:spring*`: will let all modules having their group starting with `org.springframework.spring` and name starting with `spring` update

__ |

The resolution may cause other module versions to update, as dictated by the
Gradle resolution rules.  
  
---|---  
  
## Disabling dependency locking

  1. Make sure that the configuration for which you no longer want locking is not configured with locking.

  2. Remove the file matching the configurations where you no longer want locking.

If you only perform the second step above, then locking will effectively no
longer be applied. However, if that configuration happens to be resolved in
the future at a time where lock state is persisted, it will once again be
locked.

## Single lock file per project

Gradle supports an improved lock file format. The goal is to have only a
single lock file per project, which contains the lock state for all
configurations of said project. By default, the file is named
`gradle.lockfile` and is located inside the project directory. The lock state
for the buildscript itself is found in a file named `buildscript-
gradle.lockfile` inside the project directory.

The main benefit is a substantial reduction in the number of lock files
compared to the format requiring one lockfile per locked configuration.

This format requires a migration for existing locking users and is thus opt-
in.

__ |

The objective is to default to this single lock file per project in Gradle
7.0.  
  
---|---  
  
The format can be activated by enabling the matching [feature
preview](feature_lifecycle.html#feature_preview):

Example 8. Single lock file per project activation

settings.gradle

    
    
    rootProject.name = 'locking-single-file'
    
    enableFeaturePreview('ONE_LOCKFILE_PER_PROJECT')

settings.gradle.kts

    
    
    rootProject.name = "locking-single-file"
    
    enableFeaturePreview("ONE_LOCKFILE_PER_PROJECT")

Then with the following dependency declaration and locked configurations:

Example 9. Explicit locking

build.gradle

    
    
    configurations {
        compileClasspath {
            resolutionStrategy.activateDependencyLocking()
        }
        runtimeClasspath {
            resolutionStrategy.activateDependencyLocking()
        }
        annotationProcessor {
            resolutionStrategy.activateDependencyLocking()
        }
    }
    
    dependencies {
        implementation 'org.springframework:spring-beans:[5.0,6.0)'
    }

build.gradle.kts

    
    
    configurations {
        compileClasspath {
            resolutionStrategy.activateDependencyLocking()
        }
        runtimeClasspath {
            resolutionStrategy.activateDependencyLocking()
        }
        annotationProcessor {
            resolutionStrategy.activateDependencyLocking()
        }
    }
    
    dependencies {
        implementation("org.springframework:spring-beans:[5.0,6.0)")
    }

The lockfile will have the following content:

gradle.lockfile

    
    
    # This is a Gradle generated file for dependency locking.
    # Manual edits can break the build and are not advised.
    # This file is expected to be part of source control.
    org.springframework:spring-beans:5.0.5.RELEASE=compileClasspath, runtimeClasspath
    org.springframework:spring-core:5.0.5.RELEASE=compileClasspath, runtimeClasspath
    org.springframework:spring-jcl:5.0.5.RELEASE=compileClasspath, runtimeClasspath
    empty=annotationProcessor

  * Each line still represents a single dependency in the `group:artifact:version` notation

  * It then lists all configurations that contain the given dependency

  * The last line of the file lists all empty configurations, that is configurations known to have no dependencies

### Migrating to the single lockfile per project format

Once you have activated the feature preview (see above), you can simply follow
the documentation for writing or updating dependency lock state.

Then after confirming the single lock file per project contains the lock state
for a given configuration, the matching per configuration lock file can be
removed from `gradle/dependency-locks`.

### Configuring the per project lock file name and location

When using the single lock file per project, you can configure its name and
location. The main reason for providing this is to enable having a file name
that is determined by some project properties, effectively allowing a single
project to store different lock state for different execution contexts. One
trivial example in the JVM ecosystem is the Scala version that is often found
in artifact coordinates.

Example 10. Changing the lock file name

build.gradle

    
    
    def scalaVersion = "2.12"
    dependencyLocking {
        lockFile = file("$projectDir/locking/gradle-${scalaVersion}.lockfile")
    }

build.gradle.kts

    
    
    val scalaVersion = "2.12"
    dependencyLocking {
        lockFile.set(file("$projectDir/locking/gradle-${scalaVersion}.lockfile"))
    }

## Ignoring specific dependencies from the lock state

Dependency locking can be used in cases where reproducibility is not the main
goal. As a build author, you may want to have different frequency of
dependency version updates, based on their origin for example. In that case,
it might be convenient to ignore some dependencies because you always want to
use the latest version for those. An example is the internal dependencies in
an organization which should always use the latest version as opposed to third
party dependencies which have a different upgrade cycle.

__ |

This feature can break reproducibility and should be used with caution. There
are scenarios that are better served with leveraging different lock modes or
using different names for lock files.  
  
---|---  
  
You can configure ignored dependencies in the `dependencyLocking` project
extension:

Example 11. Ignoring dependencies for the lock state

build.gradle

    
    
    dependencyLocking {
        ignoredDependencies.add('com.example:*')
    }

build.gradle.kts

    
    
    dependencyLocking {
        ignoredDependencies.add("com.example:*")
    }

The notation is a `<group>:<name>` dependency notation, where `*` can be used
as a trailing wildcard. See the description on updating lock files for more
details. Note that the value `*:*` is not accepted as it is equivalent to
disabling locking.

Ignoring dependencies will have the following effects:

  * An ignored dependency applies to all locked configurations. The setting is project scoped.

  * Ignoring a dependency does not mean lock state ignores its transitive dependencies.

  * There is no validation that an ignored dependency is present in any configuration resolution.

  * If the dependency is present in lock state, loading it will filter out the dependency.

  * If the dependency is present in the resolution result, it will be ignored when validating that resolution matches the lock state.

  * Finally, if the dependency is present in the resolution result and the lock state is persisted, it will be absent from the written lock state.

## Locking limitations

  * Locking cannot yet be applied to source dependencies.

## Nebula locking plugin

This feature is inspired by the [Nebula Gradle dependency lock
plugin](https://github.com/nebula-plugins/gradle-dependency-lock-plugin).

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

