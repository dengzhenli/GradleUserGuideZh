

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Structuring and Building a Software Product with Gradle

version 6.9-20201126230040+0000

Contents

  * An example
  * Reflecting software architecture in project structure
  * Defining an inner structure for components
  * Assigning types to components
  * Defining custom project types as convention plugins
  * Connecting components
  * The model of your software

As software projects grow, it is common to organize large systems into
components that are connected following a certain software architecture.
Usually, it makes sense to also organize the artifacts (source code etc.) that
make up the software in repositories and folder structures that reflect
component boundaries and architecture. If Gradle is used to build such a
software system, it can help you to perform this organisation and enforce
boundaries between components.

You can look at Gradle as a modelling tool for your software: It allows you to
describe the coarse grained structure and architecture of your software in a
model written in Gradle's DSLs. The build tool Gradle can then interpret this
model to build the software.

## An example

How you architect your software and how you divide it into components depends
on what you are building. There is no one-fits-all solution. Hence, Gradle
does not enforce a particular structure on you, but rather offers the tools to
model your individual setup.

Still, to exemplify these features, we explore a sample project with the
following architecture:

![software architecture](img/software_architecture.png)

__ |  You can download [the full
sample](../samples/sample_structuring_software_projects.html) to explore,
build and run it.  
---|---  
  
The structure follows a typical setup that can be found in similar form in
many commonly used software architectures.

  * At the bottom we define our domain model. There are two components: a _domain-model_ component contains the model definition (i.e. a set of data classes) and a _state_ component is responsible for managing a modifiable state of the model during application runtime.

  * On top of the model, business logic for different features is implemented independently of each other and independently of a concrete application technology. In this example, we have two features: _user_ and _admin_.

  * At the top, we have concrete applications users use to interact with the features. In the example, we build a Spring Boot application that supports both features via a web browser. And an Android app that only supports the _user_ feature.

Our components may rely on existing components that are retrieved from binary
repositories. For example, the Spring Boot and Android frameworks.

Apart from the production code, there are also components that deal with
building and delivering the product:

  * The _build-logic_ component contains the configuration details about building the software. For example, defining a Java version to use or configuring a test framework. It may also contain additional build logic for Gradle ([custom plugins](custom_plugins.html) with [custom tasks](custom_tasks.html)) that is not covered by commonly available Gradle plugins.

  * The _platforms_ component is a central place to define which versions of external components are to be used in all of our own components. By that, it defines the constraints for the environments – that is, _the platforms_ – to build, test and run the software product.

  * The _aggregation_ component contains the setup of the delivery pipeline that is required to push the product to production and doing automated end-to-end testing as part of that. Basically, this is the part of the build that is not required on local development machines.

__ |  The domain of our example is to get informed about [Gradle Build Tool
releases](https://gradle.org/releases/). Concretely, the application lists
Gradle releases with links to release notes ( _user_ feature) and offers an
administration interface for the range of releases to be listed ( _admin_
feature).  
---|---  
  
## Reflecting software architecture in project structure

Let's look at how to implement the architecture of the sample with Gradle. We
can represent each of our _components_ as a separate _Gradle build_. We'll get
to the details of what that means and how components are connected in a bit.

Each Gradle build has its own folder. The minimum to make these folders Gradle
builds is to add an empty `settings.gradle(.kts)` file to each of them. Let's
do this for all the components we have in our software:

    
    
    ├── android-app
    │   └── settings.gradle
    ├── server-application
    │   └── settings.gradle
    │
    ├── admin-feature
    │   └── settings.gradle
    ├── user-feature
    │   └── settings.gradle
    │
    ├── state
    │   └── settings.gradle
    │
    ├── domain-model
    │   └── settings.gradle
    │
    ├── build-logic
    │   └── settings.gradle
    │
    ├── platforms
    │   └── settings.gradle
    │
    └── aggregation
        └── settings.gradle
    
    
    ├── android-app
    │   └── settings.gradle.kts
    ├── server-application
    │   └── settings.gradle.kts
    │
    ├── admin-feature
    │   └── settings.gradle.kts
    ├── user-feature
    │   └── settings.gradle.kts
    │
    ├── state
    │   └── settings.gradle.kts
    │
    ├── domain-model
    │   └── settings.gradle.kts
    │
    ├── build-logic
    │   └── settings.gradle.kts
    │
    ├── platforms
    │   └── settings.gradle.kts
    │
    └── aggregation
        └── settings.gradle.kts

In the listing, each component lives in a separate folder. Here we arrange
them as a flat list in a root folder. This root folder can be used as root of
a Git repository for example.

This is only the setup of the sample. You can freely choose where to
physically locate your components. For instance, you can group all components
that live in one "layer" in a common subfolder. Or, since these are all
independent Gradle builds, you can have each component live in a separate
repository. It's up to you to decide what works best for you, the software you
are building, and the teams working on it.

## Defining an inner structure for components

Before we get to the topic of connecting the components, lets first look at
them individually.

So far, each component is just an empty folder with an empty
`settings.gradle(.kts)` file indicating that this is a component Gradle can
work with in some form. To fill the component with content, you should define
at least one project (referred to as subproject in Gradle's DSLs) in it.

You can start with components consisting of a single project each, but
introduce additional projects later to structure a single component more
internally. In our sample, we start with a single project in each component.

A project is added by using the `include()` construct in the settings file.

Example 1. Use include() to add a project to a component

domain-model/settings.gradle

    
    
    include('release') // a project for data classes that represent software releases

domain-model/settings.gradle.kts

    
    
    include("release") // a project for data classes that represent software releases

Once included, you may create a folder matching the project name and create a
`build.gradle(.kts)` file in it to configure that part of the component. You
can find more information in the chapter about [structuring Gradle builds for
a single software component](multi_project_builds.html).

## Assigning types to components

Let's zoom into the _domain-model_ component:

    
    
    └── domain-model              <-- component
        ├── settings.gradle       <-- define inner structure of component and where to locate other components
        └── release               <-- project in component
            └── build.gradle      <-- defines type of the project and its dependencies
    
    
    └── domain-model              <-- component
        ├── settings.gradle.kts   <-- define inner structure of component and where to locate other components
        └── release               <-- project in component
            └── build.gradle.kts  <-- defines type of the project and its dependencies

Initially, `release/build.gradle(.kts)` is empty. The project is of no
specific type and does not offer any useful content. If we add more files to
the `domain-model/release` folder now, for example Java source files, Gradle
won't know what to do with these files and just ignore them. We need to assign
a type to the project to make Gradle aware of the purpose of such files in the
project.

In Gradle, you assgn a type to a project by [applying a plugin](plugins.html).
The simplest thing you can do is applying one of Gradle's core plugins, like
`base` or `java-library`.

However, usually you have additional configuration to do in the context of the
product you are building. For example, if your project should be a "Java
Library", it would not only apply the `java-library` plugin but also configure
details such as setting the Java version to 11. You can add details like that
directly in `release/build.gradle(.kts)` but than you would have to repeat
them in other components that also contain "Java Library" projects.

Thus, the recommendation is to start using custom project types right away:

Example 2. Assign the custom type `com.example.java-library` to a project in
the `user-feature` component

user-feature/data/build.gradle

    
    
    plugins {
        id('com.example.java-library')
    }

user-feature/data/build.gradle.kts

    
    
    plugins {
        id("com.example.java-library")
    }

Example 3. Assign the custom type `com.example.kotlin-library` to a project in
the `domain-model` component

domain-model/release/build.gradle

    
    
    plugins {
        id('com.example.kotlin-library')
    }

domain-model/release/build.gradle.kts

    
    
    plugins {
        id("com.example.kotlin-library")
    }

As stated above, a project type is represented by a plugin in Gradle. We thus
define custom project types, such as `com.example.java-library` and
`com.example.kotlin-library`, as plugins. The next section explains how to
define such plugins.

## Defining custom project types as convention plugins

Where do we get `com.example.kotlin-library` plugin from? This is what our
`build-logic` component is for.

The `build-logic` component contains project types that Gradle itself
understands as build configuration. That is, Gradle plugins for your specific
needs, which we call _convention plugins_.

Currently, there are different project types you can use to define _convention
plugins_ depending on which tools and languages you prefer. In general, any
JVM language (Java, Groovy, Kotlin, Scala) can be used to write Gradle plugins
as classes that implement the `Plugin<Project>` interface. The most compact
way however, is to write them as scripts in Gradle's Groovy or Kotlin DSL.

Which method you choose is up to you. If you are familiar with one of Gradle's
DSLs you may choose that, as it is the most compact way to write _convention
plugins_. If you are new to Gradle (and also new to Groovy and Kotlin) you may
prefer to write the _convention plugins_ in Java or another language like
Scala. Then you reduce the interaction with Gradle's Groovy or Kotlin DSL to a
minimum.

You need to use one of the following project types (i.e. Gradle core plugins)
in projects of your `build-logic` component:

  * `kotlin-dsl` – Build logic projects with this type (i.e., that apply the `kotlin-dsl` plugin) allow you to write convention plugins as `.gradle.kts` files in `src/main/kotlin`.

  * `groovy-gradle-plugin` – Build logic projects with this type (i.e., that apply the `groovy-gradle-plugin` plugin) allow you to write convention plugins as `.gradle` files in `src/main/groovy`.

  * `java-gradle-plugin` – Build logic projects with this type (i.e., that apply the `java-gradle-plugin` plugin) allow you to write convention plugins as `.java` classes that implement the `Plugin<Project>` interface in `src/main/java`. If you apply other JVM language plugins on top, like `groovy`, `scala` or `org.jetbrains.kotlin.jvm`, you can also write the plugin class in the corresponding language.

In our sample, we choose the option of using Gradle's DSLs for the convention
plugins. The `build-logic` component has several projects where each of them
defines a project type through a convention plugin – `java-library`, `kotlin-
library`, `spring-application`, `android-application`. Also, there is a
project called `commons` for build configuration shared by all our project
types.

Example 4. Assign a custom type to a component's project by applying a
convention plugin

build-logic/spring-boot-application/build.gradle

    
    
    plugins {
        id('groovy-gradle-plugin') __**(1)**
    }
    
    dependencies {
        implementation(platform('com.example.platform:plugins-platform')) __**(2)**
    
        implementation(project(':commons')) __**(3)**
    
        implementation('org.springframework.boot:org.springframework.boot.gradle.plugin')  __**(4)**
    }

build-logic/spring-boot-application/build.gradle.kts

    
    
    plugins {
        `kotlin-dsl` __**(1)**
    }
    
    dependencies {
        implementation(platform("com.example.platform:plugins-platform")) __**(2)**
    
        implementation(project(":commons")) __**(3)**
    
        implementation("org.springframework.boot:org.springframework.boot.gradle.plugin")  __**(4)**
    }

Looking at the `build.gradle(.kts)` of the `build-logic` project for spring
boot applications, we see:

__**1** | That it is of type `groovy-gradle-plugin` or `kotlin-dsl` to allow
convention plugins written in the corresponding DSL  
---|---  
__**2** | It depends on our own `plugins-platform` from the `platforms`
component  
__**3** | It depends on the `commons` project from `build-logic` to have
access to our own commons convention plugin  
__**4** | It depends on the Spring Boot Gradle plugin from the Gradle Plugin
Portal so that we may apply it  
  
Now, we can write the convention plugin for Spring application like this:

Example 5. Defining a custom project type as convention plugin

build-logic/spring-boot-application/src/main/groovy/com.example.spring-boot-
application.gradle

    
    
    plugins {
        id('com.example.commons')
        id('org.springframework.boot')
    }
    
    dependencies {
        implementation('org.springframework.boot:spring-boot-starter-web')
        implementation('org.springframework.boot:spring-boot-starter-thymeleaf')
    }

build-logic/spring-boot-application/src/main/kotlin/com.example.spring-boot-
application.gradle.kts

    
    
    plugins {
        id("com.example.commons")
        id("org.springframework.boot")
    }
    
    dependencies {
        implementation("org.springframework.boot:spring-boot-starter-web")
        implementation("org.springframework.boot:spring-boot-starter-thymeleaf")
    }

We see that we apply our own `com.example.commons` plugin which is another
convention plugin that, among other things, configures the Java version we are
targeting and adds a dependency to a platform (`com.example.platform:product-
platform` from our `platforms` component). And we apply the spring boot
plugin. Furthermore, we add two dependencies that Spring Boot projects should
always have in our context.

Similarly, we define convention plugins for "Java Libraries", "Kotlin
Libraries" and "Android Applications". With that, we have four different
project types defined that we assign to the projects of our production code
components.

You can find more information about writing convention plugins in section on
[sharing build logic](sharing_build_logic_between_subprojects.html) and the
[associated sample](../samples/sample_convention_plugins.html). For using
classes to implement plugins, and for writing more advanced custom build
logic, consult the chapter on [Gradle plugin developmet](custom_plugins.html).

## Connecting components

As demonstrated in the architecture figure, our production code components
depend on each other. Above, we already saw that the `platforms` component is
used in the `build-logic` component. We also said that we want to use the
`build-logic` component, which declares project types through convention
plugins, to asssign those types to the projects in our production code
components.

How do you define these dependencies? There are two distinct things to do:

  1. _Make components (builds) known to each other._ This is done by adding `includeBuild(…​)` statements to `settings.gradle(.kts)`. This is _not_ adding a dependency between (projects of) components. It just makes the physical location of one component known to another. In that sense it is similar to repository declarations to discover binary components. Consult [the section on defining composite builds](composite_builds.html#defining_composite_builds) for more information about how to include builds.

  2. _Declare dependencies between (projects of) components._ This is done similarly to [declaring dependencies to binary components](declaring_dependencies.html) by using GA ( _group_ and _artifact_ ) coordinates in the `dependencies { }` block of a `build.gradle(.kts)` file: `implementation("com.example.platform:product-platform")`. Or, if the included component provides a plugin, you [apply the plugin by ID](plugins.html#sec:plugins_block) similar to how you would apply a plugin from the plugin portal: `plugins { id("com.example.java-library") }`

As another example, consider the setup of our `server-application` component:

Example 6. Defining component locations and inner structure of the `server-
application` component

server-application/settings.gradle

    
    
    // == Define locations for build logic ==
    pluginManagement {
        repositories {
            gradlePluginPortal()
        }
    }
    includeBuild('../platforms')
    includeBuild('../build-logic')
    
    // == Define locations for components ==
    dependencyResolutionManagement {
        repositories {
            mavenCentral()
        }
    }
    includeBuild('../user-feature')
    includeBuild('../admin-feature')
    
    // == Define the inner structure of this component ==
    rootProject.name = 'server-application' // the component name
    include('app')

server-application/settings.gradle.kts

    
    
    // == Define locations for build logic ==
    pluginManagement {
        repositories {
            gradlePluginPortal()
        }
    }
    includeBuild("../platforms")
    includeBuild("../build-logic")
    
    // == Define locations for components ==
    dependencyResolutionManagement {
        repositories {
            mavenCentral()
        }
    }
    includeBuild("../user-feature")
    includeBuild("../admin-feature")
    
    // == Define the inner structure of this component ==
    rootProject.name = "server-application" // the component name
    include("app")

We see that the `settings.gradle(.kts)` file only defines location for build
logic components, other production code components and the inner structue of
the component. Only the `build.gradle(.kts)` file in the `app` project then
defines actual dependencies by applying a convention plugin and utilizing the
_dependencies_ block.

Example 7. Configuring type and dependencies of the `app` project inside the
`server-application` component

server-application/app/build.gradle

    
    
    plugins {
        id('com.example.spring-boot-application')
    }
    
    group = "${group}.server-application"
    
    dependencies {
        implementation('com.example.myproduct.user-feature:table')
        implementation('com.example.myproduct.admin-feature:config')
    
        implementation('org.apache.juneau:juneau-marshall')
    }

server-application/app/build.gradle.kts

    
    
    plugins {
        id("com.example.spring-boot-application")
    }
    
    group = "${group}.server-application"
    
    dependencies {
        implementation("com.example.myproduct.user-feature:table")
        implementation("com.example.myproduct.admin-feature:config")
    
        implementation("org.apache.juneau:juneau-marshall")
    }

## The model of your software

That's it. This chapter gave an overview of which techniques to use to
structure a software project into components with Gradle by following a
sample. Download [the full
sample](../samples/sample_structuring_software_projects.html) to explore
further details. The [next
chapter](structuring_software_products_details.html) covers more details about
how to work with and evolve this kind of project structure. The [chapter on
composite builds](composite_builds.html) gives you more technical background
about the capabilities build composition offers.

To summarize, if you follow the suggestions from this chapter, your setup
should clearly separate the following concerns to give you a flexible and
clean model of your software product:

  1. _Write compact`build.gradle(.kts)` files._ While in traditional Gradle builds these files tend to grow and mix a lot of different concerns, the structure presented here keeps these files compact. In most cases they only declare a project type by applying a single convention plugin and dependencies in the `dependencies {}` block. They might include minimal project-specific configuration, but these should be kept as minimal as possible. This also makes builds less dependent on Gradle's DSLs: If you put your build logic into convention plugins, you can write it directly in Java if you like.

  2. _Isolate cross-cutting technical concerns into project types._ Technical motivated build configuration is often cross-cutting the software architecture. If a project is a "Java Library" or "Kotlin Library" may be totally independent of where it is located in the hierarchy of your components. Using convention plugins, allows you to isolate the definition of such project types in a central place, while still reusing them wherever needed. (This is a huge advantage over so called [cross project configuration](sharing_build_logic_between_subprojects.html#sec:convention_plugins_vs_cross_configuration), which has been popular with older Gradle versions, but is bound to the hierarchy of your project.)

  3. _Declare the origins of components in a central place._ In this structure, the places where a build can find other components, independent of whether they are [located in a binary repository](declaring_repositories.html#sub:centralized-repository-declaration) or are [available locally as other Gradle builds](composite_builds.html#settings_defined_composite), are defined centrally in the `settings.gradle(.kts)` file. This makes it easy to change the origin of a component and [move from a binary to a from-source version of a component](structuring_software_products_details.html#binary_vs_source_components). Note that [there are different strategies to avoid duplicating this information](structuring_software_products_details.html#settings_convention_plugins) in each `settings.gradle(.kts)` of each of your components.

  4. _Declare platforms in a central place._ Having a platform component as in the example is optional. You could do things without, e.g. by declaring [dependency constraints](dependency_constraints.html) directly in your convention plugins. However, [platforms](platforms.html) are a good option to have all the boundaries for the environment in which your software operates defined in a central place.

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

