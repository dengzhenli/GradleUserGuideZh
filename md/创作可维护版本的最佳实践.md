

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle DSLs and API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)
    * [Groovy to Kotlin DSL Migration](../userguide/migrating_from_groovy_to_kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Using the Build Cache
    * [Enabling and Configuring](../userguide/build_cache.html)
    * [Why use the Build Cache?](../userguide/build_cache_use_cases.html)
    * [Understanding the Impact](../userguide/build_cache_performance.html)
    * [Learning Basic Concepts](../userguide/build_cache_concepts.html)
    * [Caching Java Project](../userguide/caching_java_projects.html)
    * [Caching Android Project](../userguide/caching_android_projects.html)
    * [Debugging Caching Issues](../userguide/build_cache_debugging.html)
    * [Troubleshooting](../userguide/common_caching_problems.html)
  * Optimizing Build Times
    * [Improving Performance of Gradle Builds](../userguide/performance.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Writing Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Structuring Individual Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Structuring Software Products
    * [Structuring large Projects](../userguide/structuring_software_products.html)
    * [Tweaking Project Structure](../userguide/structuring_software_products_details.html)
    * [Composing Builds](../userguide/composite_builds.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * Developing Gradle Plugins
    * [Starting Plugin Development](../userguide/custom_plugins.html)
    * [Designing Plugins](../userguide/designing_gradle_plugins.html)
    * [Implementing Plugins](../userguide/implementing_gradle_plugins.html)
    * [Testing Plugins](../userguide/testing_gradle_plugins.html)
    * [Publishing Plugins](../userguide/publishing_gradle_plugins.html)
  * Developing Gradle Tasks
    * [Writing Gradle Task Types](../userguide/custom_tasks.html)
    * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
    * [Avoiding Unnecessary Task Configuration](../userguide/task_configuration_avoidance.html)
    * [Developing Parallel Tasks](../userguide/worker_api.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * Gradle & Third-party Tools
    * [Third-party Tools](../userguide/third_party_integration.html)
    * [Jenkins](../userguide/jenkins.html)
    * [TeamCity](../userguide/teamcity.html)
    * [Travis CI](../userguide/travis-ci.html)
  * [](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Best practices for authoring maintainable builds

version 6.9-20201126230040+0000

Contents

  * Avoid using imperative logic in scripts
  * Avoid using internal Gradle APIs
  * Follow conventions when declaring tasks
  * Improve task discoverability
  * Minimize logic executed during the configuration phase
  * Avoid using the `GradleBuild` task type
  * Avoid inter-project configuration
  * Externalize and encrypt your passwords

Gradle has a rich API with several approaches to creating build logic. The
associated flexibility can easily lead to unnecessarily complex builds with
custom code commonly added directly to build scripts. In this chapter, we
present several best practices that will help you develop expressive and
maintainable builds that are easy to use.

__ |  The third-party [Gradle lint plugin](https://github.com/nebula-
plugins/gradle-lint-plugin) helps with enforcing a desired code style in build
scripts if that's something that would interest you.  
---|---  
  
## Avoid using imperative logic in scripts

The Gradle runtime does not enforce a specific style for build logic. For that
very reason, it's easy to end up with a build script that mixes declarative
DSL elements with imperative, procedural code. Let's talk about some concrete
examples.

  * _Declarative code:_ Built-in, language-agnostic DSL elements (e.g. [Project.dependencies{}](../dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies\(groovy.lang.Closure\)) or [Project.repositories{}](../dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories\(groovy.lang.Closure\))) or DSLs exposed by plugins

  * _Imperative code:_ Conditional logic or very complex task action implementations

The end goal of every build script should be to only contain declarative
language elements which makes the code easier to understand and maintain.
Imperative logic should live in binary plugins and which in turn is applied to
the build script. As a side product, you automatically enable your team to
[reuse the plugin logic in other
projects](../samples/sample_publishing_convention_plugins.html) if you publish
the artifact to a binary repository.

The following sample build shows a negative example of using conditional logic
directly in the build script. While this code snippet is small, it is easy to
imagine a full-blown build script using numerous procedural statements and the
impact it would have on readability and maintainability. By moving the code
into a class, it can also be tested individually.

Example 1. A build script using conditional logic to create a task

build.gradle

    
    
    if (project.findProperty('releaseEngineer') != null) {
        tasks.register('release') {
            doLast {
                logger.quiet 'Releasing to production...'
    
                // release the artifact to production
            }
        }
    }

build.gradle.kts

    
    
    if (project.findProperty("releaseEngineer") != null) {
        tasks.register("release") {
            doLast {
                logger.quiet("Releasing to production...")
    
                // release the artifact to production
            }
        }
    }

Let's compare the build script with the same logic implemented as a binary
plugin. The code might look more involved at first but clearly looks more like
typical application code. This particular plugin class lives in the
[`buildSrc` directory](organizing_gradle_projects.html#sec:build_sources)
which makes it available to the build script automatically.

Example 2. A binary plugin implementing imperative logic

ReleasePlugin.java

    
    
    package com.enterprise;
    
    import org.gradle.api.Action;
    import org.gradle.api.Plugin;
    import org.gradle.api.Project;
    import org.gradle.api.Task;
    import org.gradle.api.tasks.TaskProvider;
    
    public class ReleasePlugin implements Plugin<Project> {
        private static final String RELEASE_ENG_ROLE_PROP = "releaseEngineer";
        private static final String RELEASE_TASK_NAME = "release";
    
        @Override
        public void apply(Project project) {
            if (project.findProperty(RELEASE_ENG_ROLE_PROP) != null) {
                Task task = project.getTasks().create(RELEASE_TASK_NAME);
    
                task.doLast(new Action<Task>() {
                    @Override
                    public void execute(Task task) {
                        task.getLogger().quiet("Releasing to production...");
    
                        // release the artifact to production
                    }
                });
            }
        }
    }

Now that the build logic has been translated into a plugin, you can apply it
in the build script. The build script has been shrunk from 8 lines of code to
a one liner.

Example 3. A build script applying a plugin that encapsulates imperative logic

build.gradle

    
    
    plugins {
        id 'com.enterprise.release'
    }

build.gradle.kts

    
    
    plugins {
        id("com.enterprise.release")
    }

## Avoid using internal Gradle APIs

Use of Gradle internal APIs in plugins and build scripts has the potential to
break builds when either Gradle or plugins change.

The following packages are listed in the [Gradle public API
definition](https://github.com/gradle/gradle/blob/180b9d3fa84b91768364c603380e82947437eda1/buildSrc/subprojects/configuration/src/main/kotlin/org/gradle/gradlebuild/public-
api.kt), with the exception of any subpackage with `internal` in the name:

    
    
    org/gradle/*
    org/gradle/api/**
    org/gradle/authentication/**
    org/gradle/buildinit/**
    org/gradle/caching/**
    org/gradle/concurrent/**
    org/gradle/deployment/**
    org/gradle/external/javadoc/**
    org/gradle/ide/**
    org/gradle/includedbuild/**
    org/gradle/ivy/**
    org/gradle/jvm/**
    org/gradle/language/**
    org/gradle/maven/**
    org/gradle/nativeplatform/**
    org/gradle/normalization/**
    org/gradle/platform/**
    org/gradle/play/**
    org/gradle/plugin/devel/**
    org/gradle/plugin/repository/*
    org/gradle/plugin/use/*
    org/gradle/plugin/management/*
    org/gradle/plugins/**
    org/gradle/process/**
    org/gradle/testfixtures/**
    org/gradle/testing/jacoco/**
    org/gradle/tooling/**
    org/gradle/swiftpm/**
    org/gradle/model/**
    org/gradle/testkit/**
    org/gradle/testing/**
    org/gradle/vcs/**
    org/gradle/workers/**

### Alternatives for oft-used internal APIs

To provide a nested DSL for your custom task, don't use
`org.gradle.internal.reflect.Instantiator`; use
[ObjectFactory](../javadoc/org/gradle/api/model/ObjectFactory.html) instead.
It may also be helpful to read [the chapter on lazy
configuration](lazy_configuration.html#lazy_configuration).

Don't use `org.gradle.api.internal.ConventionMapping`. Use
[Provider](../javadoc/org/gradle/api/provider/Provider.html) and/or
[Property](../javadoc/org/gradle/api/provider/Property.html). You can find an
example for capturing user input to configure runtime behavior in the
[implementing plugins
section](implementing_gradle_plugins.html#capturing_user_input_to_configure_plugin_runtime_behavior).

Instead of `org.gradle.internal.os.OperatingSystem`, use another method to
detect operating system, such as [Apache commons-lang
SystemUtils](https://commons.apache.org/proper/commons-
lang/apidocs/org/apache/commons/lang3/SystemUtils.html) or
`System.getProperty("os.name")`.

Use other collections or I/O frameworks instead of
`org.gradle.util.CollectionUtils`, `org.gradle.util.GFileUtils`, and other
classes under `org.gradle.util.*`.

Gradle plugin authors may find the Designing Gradle Plugins subsection on
[restricting the plugin implementation to Gradle's public
API](designing_gradle_plugins.html#restricting_the_plugin_implementation_to_gradle_s_public_api)
helpful.

## Follow conventions when declaring tasks

The task API gives a build author a lot of flexibility to declare tasks in a
build script. For optimal readability and maintainability follow these rules:

  * The task type should be the only key-value pair within the parentheses after the task name.

  * Other configuration should be done within the task's configuration block.

  * [Task actions](tutorial_using_tasks.html#sec:hello_world) added when declaring a task should only be declared with the methods [Task.doFirst{}](../dsl/org.gradle.api.Task.html#org.gradle.api.Task:doFirst\(org.gradle.api.Action\)) or [Task.doLast{}](../dsl/org.gradle.api.Task.html#org.gradle.api.Task:doLast\(org.gradle.api.Action\)).

  * When declaring an ad-hoc task — one that doesn't have an explicit type — you should use [Task.doLast{}](../dsl/org.gradle.api.Task.html#org.gradle.api.Task:doLast\(org.gradle.api.Action\)) if you're only declaring a single action.

  * A task should define a group and description.

Example 4. Definition of tasks following best practices

build.gradle

    
    
    import com.enterprise.DocsGenerate
    
    def generateHtmlDocs = tasks.register('generateHtmlDocs', DocsGenerate) {
        group = JavaBasePlugin.DOCUMENTATION_GROUP
        description = 'Generates the HTML documentation for this project.'
        title = 'Project docs'
        outputDir = file("$buildDir/docs")
    }
    
    tasks.register('allDocs') {
        group = JavaBasePlugin.DOCUMENTATION_GROUP
        description = 'Generates all documentation for this project.'
        dependsOn generateHtmlDocs
    
        doLast {
            logger.quiet('Generating all documentation...')
        }
    }

build.gradle.kts

    
    
    import com.enterprise.DocsGenerate
    
    tasks.register<DocsGenerate>("generateHtmlDocs") {
        group = JavaBasePlugin.DOCUMENTATION_GROUP
        description = "Generates the HTML documentation for this project."
        title = "Project docs"
        outputDir = file("$buildDir/docs")
    }
    
    tasks.register("allDocs") {
        group = JavaBasePlugin.DOCUMENTATION_GROUP
        description = "Generates all documentation for this project."
        dependsOn("generateHtmlDocs")
    
        doLast {
            logger.quiet("Generating all documentation...")
        }
    }

## Improve task discoverability

Even new users to a build should to be able to find crucial information
quickly and effortlessly. In Gradle you can declare a
[group](../dsl/org.gradle.api.Project.html#org.gradle.api.Project:group) and a
[description](../dsl/org.gradle.api.Project.html#org.gradle.api.Project:description)
for any task of the build. The [tasks
report](command_line_interface.html#sec:listing_tasks) uses the assigned
values to organize and render the task for easy discoverability. Assigning a
group and description is most helpful for any task that you expect build users
to invoke.

The example task `generateDocs` generates documentation for a project in the
form of HTML pages. The task should be organized underneath the bucket
`Documentation`. The description should express its intent.

Example 5. A task declaring the group and description

build.gradle

    
    
    tasks.register('generateDocs') {
        group = 'Documentation'
        description = 'Generates the HTML documentation for this project.'
    
        doLast {
            // action implementation
        }
    }

build.gradle.kts

    
    
    tasks.register("generateDocs") {
        group = "Documentation"
        description = "Generates the HTML documentation for this project."
    
        doLast {
            // action implementation
        }
    }

The output of the tasks report reflects the assigned values.

    
    
    > gradle tasks
    
    > Task :tasks
    
    Documentation tasks
    -------------------
    generateDocs - Generates the HTML documentation for this project.

## Minimize logic executed during the configuration phase

It's important for every build script developer to understand the different
phases of the [build lifecycle](build_lifecycle.html#build_lifecycle) and
their implications on performance and evaluation order of build logic. During
the configuration phase the project and its domain objects should be
_configured_ , whereas the execution phase only executes the actions of the
task(s) requested on the command line plus their dependencies. Be aware that
any code that is not part of a task action will be executed with _every single
run_ of the build. A [build scan](https://scans.gradle.com/get-started) can
help you with identifying the time spent during each of the lifecycle phases.
It's an invaluable tool for diagnosing common performance issues.

Let's consider the following incantation of the anti-pattern described above.
In the build script you can see that the dependencies assigned to the
configuration `printArtifactNames` are resolved outside of the task action.

Example 6. Executing logic during configuration should be avoided

build.gradle

    
    
    dependencies {
        implementation 'log4j:log4j:1.2.17'
    }
    
    tasks.register('printArtifactNames') {
        // always executed
        def libraryNames = configurations.compileClasspath.collect { it.name }
    
        doLast {
            logger.quiet libraryNames
        }
    }

build.gradle.kts

    
    
    dependencies {
        implementation("log4j:log4j:1.2.17")
    }
    
    tasks.register("printArtifactNames") {
        // always executed
        val libraryNames = configurations.compileClasspath.get().map { it.name }
    
        doLast {
            logger.quiet(libraryNames.toString())
        }
    }

The code for resolving the dependencies should be moved into the task action
to avoid the performance impact of resolving the dependencies before they are
actually needed.

Example 7. Executing logic during execution phase is preferred

build.gradle

    
    
    dependencies {
        implementation 'log4j:log4j:1.2.17'
    }
    
    tasks.register('printArtifactNames') {
        doLast {
            def libraryNames = configurations.compileClasspath.collect { it.name }
            logger.quiet libraryNames
        }
    }

build.gradle.kts

    
    
    dependencies {
        implementation("log4j:log4j:1.2.17")
    }
    
    tasks.register("printArtifactNames") {
        doLast {
            val libraryNames = configurations.compileClasspath.get().map { it.name }
            logger.quiet(libraryNames.toString())
        }
    }

## Avoid using the `GradleBuild` task type

The [GradleBuild](../dsl/org.gradle.api.tasks.GradleBuild.html) task type
allows a build script to define a task that invokes another Gradle build. The
use of this type is generally discouraged. There are some corner cases where
the invoked build doesn't expose the same runtime behavior as from the command
line or through the Tooling API leading to unexpected results.

Usually, there's a better way to model the requirement. The appropriate
approach depends on the problem at hand. Here're some options:

  * Model the build as [multi-project build](multi_project_builds.html#multi_project_builds) if the intention is to execute tasks from different modules as unified build.

  * Use [composite builds](composite_builds.html#composite_builds) for projects that are physically separated but should occasionally be built as a single unit.

## Avoid inter-project configuration

Gradle does not restrict build script authors from reaching into the domain
model from one project into another one in a [multi-project
build](multi_project_builds.html#multi_project_builds). Strongly-coupled
projects hurts [build execution
performance](multi_project_configuration_and_execution.html#sec:parallel_execution)
as well as readability and maintainability of code.

The following practices should be avoided:

  * Explicitly depending on a task from another project via [Task.dependsOn(java.lang.Object...)](../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn\(java.lang.Object\[\]\)).

  * Setting property values or calling methods on domain objects from another project.

  * Executing another portion of the build with GradleBuild.

  * Declaring unnecessary [project dependencies](declaring_dependencies.html#sub:project_dependencies).

## Externalize and encrypt your passwords

Most builds need to consume one or many passwords. The reasons for this need
may vary. Some builds need a password for publishing artifacts to a secured
binary repository, other builds need a password for downloading binary files.
Passwords should always kept safe to prevent fraud. Under no circumstance
should you add the password to the build script in plain text or declare it in
`gradle.properties` file in the project's directory. Those files usually live
in a version control repository and can be viewed by anyone that has access to
it.

Passwords together with any other sensitive data should be kept external from
the version controlled project files. Gradle exposes an API for providing
credentials in
[ProviderFactory](../javadoc/org/gradle/api/provider/ProviderFactory.html#credentials-
java.lang.Class-java.lang.String-) as well as [Artifact
Repositories](declaring_repositories.html#sec:handling_credentials) that
allows to supply credential values using [Gradle
properties](build_environment.html#sec:gradle_configuration_properties) when
they are needed by the build. This way the credentials can be stored in the
`gradle.properties` file that resides in the user's home directory or be
injected to the build using command line arguments or environment variables.

If you store sensitive credentials in user home's `gradle.properties`,
consider encrypting them. At the moment Gradle does not provide a built-in
mechanism for encrypting, storing and accessing passwords. A good solution for
solving this problem is the [Gradle Credentials
plugin](https://github.com/etiennestuder/gradle-credentials-plugin).

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

