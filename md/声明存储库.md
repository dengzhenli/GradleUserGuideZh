

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Declaring repositories

version 6.7.1

Contents

  * Declaring a publicly-available repository
  * Declaring a custom repository by URL
  * Declaring multiple repositories
  * Supported repository types
  * Maven repositories
  * The case for mavenLocal()
  * Ivy repositories
  * Repository content filtering
  * Supported metadata sources
  * Plugin repositories vs. build repositories
  * Supported repository transport protocols
  * HTTP(S) authentication schemes configuration
  * AWS S3 repositories configuration
  * Google Cloud Storage repositories configuration
  * Handling credentials

Gradle can resolve dependencies from one or many repositories based on Maven,
Ivy or flat directory formats. Check out the full reference on all types of
repositories for more information.

## Declaring a publicly-available repository

Organizations building software may want to leverage public binary
repositories to download and consume open source dependencies. Popular public
repositories include Maven Central, Bintray JCenter and the Google Android
repository. Gradle provides built-in shorthand notations for these widely-used
repositories.

![dependency management shortcut repositories](img/dependency-management-
shortcut-repositories.png)

Figure 1. Declaring a repository with the help of shorthand notations

Under the covers Gradle resolves dependencies from the respective URL of the
public repository defined by the shorthand notation. All shorthand notations
are available via the
[RepositoryHandler](../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html)
API. Alternatively, you can spell out the URL of the repository for more fine-
grained control.

### Maven Central repository

Maven Central is a popular repository hosting open source libraries for
consumption by Java projects.

To declare the [Maven Central
repository](https://repo.maven.apache.org/maven2/) for your build add this to
your script:

Example 1. Adding central Maven repository

build.gradle

    
    
    repositories {
        mavenCentral()
    }

build.gradle.kts

    
    
    repositories {
        mavenCentral()
    }

### JCenter Maven repository

[Bintray](http://bintray.com)'s JCenter is an up-to-date collection of all
popular Maven OSS artifacts, including artifacts published directly to
Bintray.

To declare the [JCenter Maven repository](https://jcenter.bintray.com) add
this to your build script:

Example 2. Adding Bintray's JCenter Maven repository

build.gradle

    
    
    repositories {
        jcenter()
    }

build.gradle.kts

    
    
    repositories {
        jcenter()
    }

### Google Maven repository

The Google repository hosts Android-specific artifacts including the Android
SDK. For usage examples, see the [relevant Android
documentation](https://developer.android.com/studio/build/dependencies.html#google-
maven).

To declare the [Google Maven repository](https://maven.google.com/) add this
to your build script:

Example 3. Adding Google Maven repository

build.gradle

    
    
    repositories {
        google()
    }

build.gradle.kts

    
    
    repositories {
        google()
    }

## Declaring a custom repository by URL

Most enterprise projects set up a binary repository available only within an
intranet. In-house repositories enable teams to publish internal binaries,
setup user management and security measure and ensure uptime and availability.
Specifying a custom URL is also helpful if you want to declare a less popular,
but publicly-available repository.

Repositories with custom URLs can be specified as Maven or Ivy repositories by
calling the corresponding methods available on the
[RepositoryHandler](../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html)
API. Gradle supports other protocols than `http` or `https` as part of the
custom URL e.g. `file`, `sftp` or `s3`. For a full coverage see the section on
supported repository types.

You can also define your own repository layout by using `ivy { }` repositories
as they are very flexible in terms of how modules are organised in a
repository.

## Declaring multiple repositories

You can define more than one repository for resolving dependencies. Declaring
multiple repositories is helpful if some dependencies are only available in
one repository but not the other. You can mix any type of repository described
in the reference section.

This example demonstrates how to declare various named and custom URL
repositories for a project:

Example 4. Declaring multiple repositories

build.gradle

    
    
    repositories {
        jcenter()
        maven {
            url "https://maven.springframework.org/release"
        }
        maven {
            url "https://maven.restlet.com"
        }
    }

build.gradle.kts

    
    
    repositories {
        jcenter()
        maven {
            url = uri("https://maven.springframework.org/release")
        }
        maven {
            url = uri("https://maven.restlet.com")
        }
    }

__ |

The order of declaration determines how Gradle will check for dependencies at
runtime. If Gradle finds a module descriptor in a particular repository, it
will attempt to download all of the artifacts for that module from _the same
repository_. You can learn more about the inner workings of [dependency
downloads](dependency_resolution.html#sec:how-gradle-downloads-deps).  
  
---|---  
  
### Strict limitation to declared repositories

Maven POM metadata can reference additional repositories. These will be
_ignored_ by Gradle, which will only use the repositories declared in the
build itself.

__ |

This is a reproducibility safe-guard but also a security protection. Without
it, an updated version of a dependency could pull artifacts from anywhere into
your build.  
  
---|---  
  
## Supported repository types

Gradle supports a wide range of sources for dependencies, both in terms of
format and in terms of connectivity. You may resolve dependencies from:

  * Different formats

    * a Maven compatible artifact repository (e.g: Maven Central, JCenter, …​)

    * an Ivy compatible artifact repository (including custom layouts)

    * local (flat) directories

  * with different connectivity

    * authenticated repositories

    * a wide variety of remote protocols such as HTTPS, SFTP, AWS S3 and Google Cloud Storage

### Flat directory repository

Some projects might prefer to store dependencies on a shared drive or as part
of the project source code instead of a binary repository product. If you want
to use a (flat) filesystem directory as a repository, simply type:

Example 5. Flat repository resolver

build.gradle

    
    
    repositories {
        flatDir {
            dirs 'lib'
        }
        flatDir {
            dirs 'lib1', 'lib2'
        }
    }

build.gradle.kts

    
    
    repositories {
        flatDir {
            dirs("lib")
        }
        flatDir {
            dirs("lib1", "lib2")
        }
    }

This adds repositories which look into one or more directories for finding
dependencies.

This type of repository does not support any meta-data formats like Ivy XML or
Maven POM files. Instead, Gradle will dynamically generate a module descriptor
(without any dependency information) based on the presence of artifacts.

__ |

As Gradle prefers to use modules whose descriptor has been created from real
meta-data rather than being generated, flat directory repositories cannot be
used to override artifacts with real meta-data from other repositories
declared in the build.

For example, if Gradle finds only `jmxri-1.2.1.jar` in a flat directory
repository, but `jmxri-1.2.1.pom` in another repository that supports meta-
data, it will use the second repository to provide the module.

For the use case of overriding remote artifacts with local ones consider using
an Ivy or Maven repository instead whose URL points to a local directory.  
  
---|---  
  
If you only work with flat directory repositories you don't need to set all
attributes of a dependency.

### Local repositories

The following sections describe repositories format, Maven or Ivy. These can
be declared as local repositories, using a local filesystem path to access
them.

The difference with the flat directory repository is that they do respect a
format and contain metadata.

When such a repository is configured, Gradle totally bypasses its [dependency
cache](dependency_resolution.html#sec:dependency_cache) for it as there can be
no guarantee that content may not change between executions. Because of that
limitation, they can have a performance impact.

They also make build reproducibility much harder to achieve and their use
should be limited to tinkering or prototyping.

## Maven repositories

Many organizations host dependencies in an in-house Maven repository only
accessible within the company's network. Gradle can declare Maven repositories
by URL.

For adding a custom Maven repository you can do:

Example 6. Adding custom Maven repository

build.gradle

    
    
    repositories {
        maven {
            url "http://repo.mycompany.com/maven2"
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("http://repo.mycompany.com/maven2")
        }
    }

### Setting up composite Maven repositories

Sometimes a repository will have the POMs published to one location, and the
JARs and other artifacts published at another location. To define such a
repository, you can do:

Example 7. Adding additional Maven repositories for JAR files

build.gradle

    
    
    repositories {
        maven {
            // Look for POMs and artifacts, such as JARs, here
            url "http://repo2.mycompany.com/maven2"
            // Look for artifacts here if not found at the above location
            artifactUrls "http://repo.mycompany.com/jars"
            artifactUrls "http://repo.mycompany.com/jars2"
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            // Look for POMs and artifacts, such as JARs, here
            url = uri("http://repo2.mycompany.com/maven2")
            // Look for artifacts here if not found at the above location
            artifactUrls("http://repo.mycompany.com/jars")
            artifactUrls("http://repo.mycompany.com/jars2")
        }
    }

Gradle will look at the base `url` location for the POM and the JAR. If the
JAR can't be found there, the extra `artifactUrls` are used to look for JARs.

### Accessing authenticated Maven repositories

You can specify credentials for Maven repositories secured by different type
of authentication.

See Supported repository transport protocols for authentication options.

### Local Maven repository

Gradle can consume dependencies available in the [local Maven
repository](https://maven.apache.org/guides/introduction/introduction-to-
repositories.html). Declaring this repository is beneficial for teams that
publish to the local Maven repository with one project and consume the
artifacts by Gradle in another project.

__ |

Gradle stores resolved dependencies in [its own
cache](dependency_resolution.html#sec:dependency_cache). A build does not need
to declare the local Maven repository even if you resolve dependencies from a
Maven-based, remote repository.  
  
---|---  
  
__ |

Before adding Maven local as a repository, you should make sure this is really
required.  
  
---|---  
  
To declare the local Maven cache as a repository add this to your build
script:

Example 8. Adding the local Maven cache as a repository

build.gradle

    
    
    repositories {
        mavenLocal()
    }

build.gradle.kts

    
    
    repositories {
        mavenLocal()
    }

Gradle uses the same logic as Maven to identify the location of your local
Maven cache. If a local repository location is defined in a `settings.xml`,
this location will be used. The `settings.xml` in `_USER_HOME_ /.m2` takes
precedence over the `settings.xml` in `_M2_HOME_ /conf`. If no `settings.xml`
is available, Gradle uses the default location `_USER_HOME_ /.m2/repository`.

## The case for mavenLocal()

As a general advice, you should avoid adding `mavenLocal()` as a repository.
There are different issues with using `mavenLocal()` that you should be aware
of:

  * Maven uses it as a cache, not a repository, meaning it can contain partial modules.

    * For example, if Maven never downloaded the source or javadoc files for a given module, Gradle will not find them either since it [searches for files in a single repository](dependency_resolution.html#sec:how-gradle-downloads-deps) once a module has been found.

  * As a local repository, Gradle does not trust its content, because:

    * Origin of artifacts cannot be tracked, which is a correctness and security problem

    * Artifacts can be easily overwritten, which is a security, correctness and reproducibility problem

  * To mitigate the fact that metadata and/or artifacts can be changed, Gradle does not perform [any caching](dependency_resolution.html#sec:dependency_cache) for local repositories

    * As a consequence, your builds are slower

    * Given that order of repositories is important, adding `mavenLocal()` _first_ means that all your builds are going to be slower

There are a few cases where you might have to use `mavenLocal()`:

  * For interoperability with Maven

    * For example, project A is built with Maven, project B is built with Gradle, and you need to share the artifacts during development

    * It is _always_ preferable to use an internal full featured repository instead

    * In case this is not possible, you should limit this to _local builds only_

  * For interoperability with Gradle itself

    * In a multi-repository world, you want to check that changes to project A work with project B

    * It is preferable to use [composite builds](composite_builds.html#composite_builds) for this use case

    * If for some reason neither composite builds nor full featured repository are possible, then `mavenLocal()` is a last resort option

After all these warnings, if you end up using `mavenLocal()`, consider
combining it with a repository filter. This will make sure it only provides
what is expected and nothing else.

## Ivy repositories

Organizations might decide to host dependencies in an in-house Ivy repository.
Gradle can declare Ivy repositories by URL.

### Defining an Ivy repository with a standard layout

To declare an Ivy repository using the standard layout no additional
customization is needed. You just declare the URL.

Example 9. Ivy repository

build.gradle

    
    
    repositories {
        ivy {
            url "http://repo.mycompany.com/repo"
        }
    }

build.gradle.kts

    
    
    repositories {
        ivy {
            url = uri("http://repo.mycompany.com/repo")
        }
    }

### Defining a named layout for an Ivy repository

You can specify that your repository conforms to the Ivy or Maven default
layout by using a named layout.

Example 10. Ivy repository with named layout

build.gradle

    
    
    repositories {
        ivy {
            url "http://repo.mycompany.com/repo"
            layout "maven"
        }
    }

build.gradle.kts

    
    
    repositories {
        ivy {
            url = uri("http://repo.mycompany.com/repo")
            layout("maven")
        }
    }

Valid named layout values are `'gradle'` (the default), `'maven'` and `'ivy'`.
See
[IvyArtifactRepository.layout(java.lang.String)](../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html#org.gradle.api.artifacts.repositories.IvyArtifactRepository:layout\(java.lang.String\))
in the API documentation for details of these named layouts.

### Defining custom pattern layout for an Ivy repository

To define an Ivy repository with a non-standard layout, you can define a
_pattern_ layout for the repository:

Example 11. Ivy repository with pattern layout

build.gradle

    
    
    repositories {
        ivy {
            url "http://repo.mycompany.com/repo"
            patternLayout {
                artifact "[module]/[revision]/[type]/[artifact].[ext]"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        ivy {
            url = uri("http://repo.mycompany.com/repo")
            patternLayout {
                artifact("[module]/[revision]/[type]/[artifact].[ext]")
            }
        }
    }

To define an Ivy repository which fetches Ivy files and artifacts from
different locations, you can define separate patterns to use to locate the Ivy
files and artifacts:

Each `artifact` or `ivy` specified for a repository adds an _additional_
pattern to use. The patterns are used in the order that they are defined.

Example 12. Ivy repository with multiple custom patterns

build.gradle

    
    
    repositories {
        ivy {
            url "http://repo.mycompany.com/repo"
            patternLayout {
                artifact "3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"
                artifact "company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"
                ivy "ivy-files/[organisation]/[module]/[revision]/ivy.xml"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        ivy {
            url = uri("http://repo.mycompany.com/repo")
            patternLayout {
                artifact("3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]")
                artifact("company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]")
                ivy("ivy-files/[organisation]/[module]/[revision]/ivy.xml")
            }
        }
    }

Optionally, a repository with pattern layout can have its `'organisation'`
part laid out in Maven style, with forward slashes replacing dots as
separators. For example, the organisation `my.company` would then be
represented as `my/company`.

Example 13. Ivy repository with Maven compatible layout

build.gradle

    
    
    repositories {
        ivy {
            url "http://repo.mycompany.com/repo"
            patternLayout {
                artifact "[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"
                m2compatible = true
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        ivy {
            url = uri("http://repo.mycompany.com/repo")
            patternLayout {
                artifact("[organisation]/[module]/[revision]/[artifact]-[revision].[ext]")
                setM2compatible(true)
            }
        }
    }

### Accessing authenticated Ivy repositories

You can specify credentials for Ivy repositories secured by basic
authentication.

Example 14. Ivy repository with authentication

build.gradle

    
    
    repositories {
        ivy {
            url "http://repo.mycompany.com"
            credentials {
                username "user"
                password "password"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        ivy {
            url = uri("http://repo.mycompany.com")
            credentials {
                username = "user"
                password = "password"
            }
        }
    }

See Supported repository transport protocols for authentication options.

## Repository content filtering

Gradle exposes an API to declare what a repository may or may not contain.
There are different use cases for it:

  * performance, when you know a dependency will never be found in a specific repository

  * security, by avoiding leaking what dependencies are used in a private project

  * reliability, when some repositories contain corrupted metadata or artifacts

It's even more important when considering that the declared order of
repositories matter.

### Declaring a repository filter

Example 15. Declaring repository contents

build.gradle

    
    
    repositories {
        maven {
            url "https://repo.mycompany.com/maven2"
            content {
                // this repository *only* contains artifacts with group "my.company"
                includeGroup "my.company"
            }
        }
        jcenter {
            content {
                // this repository contains everything BUT artifacts with group starting with "my.company"
                excludeGroupByRegex "my\\.company.*"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("https://repo.mycompany.com/maven2")
            content {
                // this repository *only* contains artifacts with group "my.company"
                includeGroup("my.company")
            }
        }
        jcenter {
            content {
                // this repository contains everything BUT artifacts with group starting with "my.company"
                excludeGroupByRegex("my\\.company.*")
            }
        }
    }

By default, repositories include everything and exclude nothing:

  * If you declare an include, then it excludes everything _but_ what is included.

  * If you declare an exclude, then it includes everything _but_ what is excluded.

  * If you declare both includes and excludes, then it includes only what is explicitly included and not excluded.

It is possible to filter either by explicit _group_ , _module_ or _version_ ,
either strictly or using regular expressions. When using a strict version, it
is possible to use a version range, using [the format
supported](single_versions.html) by Gradle. In addition, there are filtering
options by resolution context: configuration name or even configuration
attributes. See
[RepositoryContentDescriptor](../javadoc/org/gradle/api/artifacts/repositories/RepositoryContentDescriptor.html)
for details.

### Declaring content exclusively found in one repository

Filters declared using the repository-level content filter are not exclusive.
This means that declaring that a repository _includes_ an artifact doesn't
mean that the other repositories can't have it either: you must declare what
every repository contains in extension.

Alternatively, Gradle provides an API which lets you declare that a repository
_exclusively includes_ an artifact. If you do so:

  * an artifact declared in a repository _can 't_ be found in any other

  * exclusive repository content must be declared in extension (just like for repository-level content)

Example 16. Declaring exclusive repository contents

build.gradle

    
    
    repositories {
        // This repository will _not_ be searched for artifacts in my.company
        // despite being declared first
        jcenter()
        exclusiveContent {
            forRepository {
                maven {
                    url "https://repo.mycompany.com/maven2"
                }
            }
            filter {
                // this repository *only* contains artifacts with group "my.company"
                includeGroup "my.company"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        // This repository will _not_ be searched for artifacts in my.company
        // despite being declared first
        jcenter()
        exclusiveContent {
            forRepository {
                maven {
                    url = uri("https://repo.mycompany.com/maven2")
                }
            }
            filter {
                // this repository *only* contains artifacts with group "my.company"
                includeGroup("my.company")
            }
        }
    }

It is possible to filter either by explicit _group_ , _module_ or _version_ ,
either strictly or using regular expressions. See
[InclusiveRepositoryContentDescriptor](../javadoc/org/gradle/api/artifacts/repositories/InclusiveRepositoryContentDescriptor.html)
for details.

### Maven repository filtering

For Maven repositories, it's often the case that a repository would either
contain releases or snapshots. Gradle lets you declare what kind of artifacts
are found in a repository using this DSL:

Example 17. Splitting snapshots and releases

build.gradle

    
    
    repositories {
        maven {
            url "https://repo.mycompany.com/releases"
            mavenContent {
                releasesOnly()
            }
        }
        maven {
            url "https://repo.mycompany.com/snapshots"
            mavenContent {
                snapshotsOnly()
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("https://repo.mycompany.com/releases")
            mavenContent {
                releasesOnly()
            }
        }
        maven {
            url = uri("https://repo.mycompany.com/snapshots")
            mavenContent {
                snapshotsOnly()
            }
        }
    }

## Supported metadata sources

When searching for a module in a repository, Gradle, by default, checks for
[supported metadata file formats](declaring_dependencies.html#sec:supported-
metadata-formats) in that repository. In a Maven repository, Gradle looks for
a `.pom` file, in an ivy repository it looks for an `ivy.xml` file and in a
flat directory repository it looks directly for `.jar` files as it does not
expect any metadata. Starting with 5.0, Gradle also looks for `.module`
(Gradle module metadata) files.

However, if you define a customized repository you might want to configure
this behavior. For example, you can define a Maven repository without `.pom`
files but only jars. To do so, you can configure _metadata sources_ for any
repository.

Example 18. Maven repository that supports artifacts without metadata

build.gradle

    
    
    repositories {
        maven {
            url "http://repo.mycompany.com/repo"
            metadataSources {
                mavenPom()
                artifact()
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("http://repo.mycompany.com/repo")
            metadataSources {
                mavenPom()
                artifact()
            }
        }
    }

You can specify multiple sources to tell Gradle to keep looking if a file was
not found. In that case, the order of checking for sources is predefined.

The following metadata sources are supported:

Table 1. Supported metadata sources Metadata source | Description | Order |
Maven | Ivy / flat dir  
---|---|---|---|---  
  
`gradleMetadata()`

|

Look for Gradle `.module` files

|

1st

|

yes

|

yes  
  
`mavenPom()`

|

Look for Maven `.pom` files

|

2nd

|

yes

|

yes  
  
`ivyDescriptor()`

|

Look for `ivy.xml` files

|

2nd

|

no

|

yes  
  
`artifact()`

|

Look directly for artifact

|

3rd

|

yes

|

yes  
  
__ |

The defaults for Ivy and Maven repositories change with Gradle 6.0. Before
6.0, `artifact()` was included in the defaults. Leading to some inefficiency
when modules are missing completely. To restore this behavior, for example,
for Maven central you can use `mavenCentral { metadataSources { mavenPom();
artifact() } }`. In a similar way, you can opt into the new behavior in older
Gradle versions using `mavenCentral { metadataSources { mavenPom() } }`  
  
---|---  
  
Since Gradle 5.3, when parsing a metadata file, be it Ivy or Maven, Gradle
will look for a marker indicating that a matching Gradle Module Metadata files
exists. If it is found, it will be used instead of the Ivy or Maven file.

Starting with Gradle 5.6, you can disable this behavior by adding
`ignoreGradleMetadataRedirection()` to the metadataSources declaration.

Example 19. Maven repository that does not use gradle metadata redirection

build.gradle

    
    
    repositories {
        maven {
            url "http://repo.mycompany.com/repo"
            metadataSources {
                mavenPom()
                artifact()
                ignoreGradleMetadataRedirection()
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("http://repo.mycompany.com/repo")
            metadataSources {
                mavenPom()
                artifact()
                ignoreGradleMetadataRedirection()
            }
        }
    }

## Plugin repositories vs. build repositories

Gradle will use repositories at two different phases during your build.

The first phase is when [configuring your
build](build_lifecycle.html#sec:build_phases) and loading the plugins it
applied. To do that Gradle will use a special set of repositories.

The second phase is during dependency resolution. At this point Gradle will
use the repositories declared in your project, as shown in the previous
sections.

### Plugin repositories

By default Gradle will use the [Gradle plugin
portal](http://plugins.gradle.org) to look for plugins.

However, for different reasons, there are plugins available in other, public
or not, repositories. When a build requires one of these plugins, additional
repositories need to be specified so that Gradle knows where to search.

As the way to declare the repositories and what they are expected to contain
depends on the way the plugin is applied, it is best to refer to [Custom
Plugin Repositories](plugins.html#sec:custom_plugin_repositories).

## Supported repository transport protocols

Maven and Ivy repositories support the use of various transport protocols. At
the moment the following protocols are supported:

Table 2. Repository transport protocols Type | Credential types | Link  
---|---|---  
  
`file`

|

none

|  
  
`http`

|

username/password

|

Documentation  
  
`https`

|

username/password

|

Documentation  
  
`sftp`

|

username/password

|

Documentation  
  
`s3`

|

access key/secret key/session token or Environment variables

|

Documentation  
  
`gcs`

|

[default application
credentials](https://developers.google.com/identity/protocols/application-
default-credentials) sourced from well known files, Environment variables etc.

|

Documentation  
  
__ |

Username and password should never be checked in plain text into version
control as part of your build file. You can store the credentials in a local
`gradle.properties` file and use one of the open source Gradle plugins for
encrypting and consuming credentials e.g. the [credentials
plugin](https://plugins.gradle.org/plugin/nu.studer.credentials).  
  
---|---  
  
The transport protocol is part of the URL definition for a repository. The
following build script demonstrates how to create HTTP-based Maven and Ivy
repositories:

Example 20. Declaring a Maven and Ivy repository

build.gradle

    
    
    repositories {
        maven {
            url "http://repo.mycompany.com/maven2"
        }
    
        ivy {
            url "http://repo.mycompany.com/repo"
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("http://repo.mycompany.com/maven2")
        }
    
        ivy {
            url = uri("http://repo.mycompany.com/repo")
        }
    }

The following example shows how to declare SFTP repositories:

Example 21. Using the SFTP protocol for a repository

build.gradle

    
    
    repositories {
        maven {
            url "sftp://repo.mycompany.com:22/maven2"
            credentials {
                username "user"
                password "password"
            }
        }
    
        ivy {
            url "sftp://repo.mycompany.com:22/repo"
            credentials {
                username "user"
                password "password"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("sftp://repo.mycompany.com:22/maven2")
            credentials {
                username = "user"
                password = "password"
            }
        }
    
        ivy {
            url = uri("sftp://repo.mycompany.com:22/repo")
            credentials {
                username = "user"
                password = "password"
            }
        }
    }

For details on HTTP related authentication, see the section HTTP(S)
authentication schemes configuration.

When using an AWS S3 backed repository you need to authenticate using
[AwsCredentials](../dsl/org.gradle.api.credentials.AwsCredentials.html),
providing access-key and a private-key. The following example shows how to
declare a S3 backed repository and providing AWS credentials:

Example 22. Declaring an S3 backed Maven and Ivy repository

build.gradle

    
    
    repositories {
        maven {
            url "s3://myCompanyBucket/maven2"
            credentials(AwsCredentials) {
                accessKey "someKey"
                secretKey "someSecret"
                // optional
                sessionToken "someSTSToken"
            }
        }
    
        ivy {
            url "s3://myCompanyBucket/ivyrepo"
            credentials(AwsCredentials) {
                accessKey "someKey"
                secretKey "someSecret"
                // optional
                sessionToken "someSTSToken"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("s3://myCompanyBucket/maven2")
            credentials(AwsCredentials::class) {
                accessKey = "someKey"
                secretKey = "someSecret"
                // optional
                sessionToken = "someSTSToken"
            }
        }
    
        ivy {
            url = uri("s3://myCompanyBucket/ivyrepo")
            credentials(AwsCredentials::class) {
                accessKey = "someKey"
                secretKey = "someSecret"
                // optional
                sessionToken = "someSTSToken"
            }
        }
    }

You can also delegate all credentials to the AWS sdk by using the
AwsImAuthentication. The following example shows how:

Example 23. Declaring an S3 backed Maven and Ivy repository using IAM

build.gradle

    
    
    repositories {
        maven {
            url "s3://myCompanyBucket/maven2"
            authentication {
               awsIm(AwsImAuthentication) // load from EC2 role or env var
            }
        }
    
        ivy {
            url "s3://myCompanyBucket/ivyrepo"
            authentication {
               awsIm(AwsImAuthentication)
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("s3://myCompanyBucket/maven2")
            authentication {
                create<AwsImAuthentication>("awsIm") // load from EC2 role or env var
            }
        }
    
        ivy {
            url = uri("s3://myCompanyBucket/ivyrepo")
            authentication {
                create<AwsImAuthentication>("awsIm")
            }
        }
    }

For details on AWS S3 related authentication, see the section AWS S3
repositories configuration.

When using a Google Cloud Storage backed repository default application
credentials will be used with no further configuration required:

Example 24. Declaring a Google Cloud Storage backed Maven and Ivy repository
using default application credentials

build.gradle

    
    
    repositories {
        maven {
            url "gcs://myCompanyBucket/maven2"
        }
    
        ivy {
            url "gcs://myCompanyBucket/ivyrepo"
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("gcs://myCompanyBucket/maven2")
        }
    
        ivy {
            url = uri("gcs://myCompanyBucket/ivyrepo")
        }
    }

For details on Google GCS related authentication, see the section Google Cloud
Storage repositories configuration.

## HTTP(S) authentication schemes configuration

When configuring a repository using HTTP or HTTPS transport protocols,
multiple authentication schemes are available. By default, Gradle will attempt
to use all schemes that are supported by the Apache HttpClient library,
[documented here](http://hc.apache.org/httpcomponents-client-
ga/tutorial/html/authentication.html#d5e625). In some cases, it may be
preferable to explicitly specify which authentication schemes should be used
when exchanging credentials with a remote server. When explicitly declared,
only those schemes are used when authenticating to a remote repository.

You can specify credentials for Maven repositories secured by basic
authentication using
[PasswordCredentials](../javadoc/org/gradle/api/credentials/PasswordCredentials.html).

Example 25. Accessing password-protected Maven repository

build.gradle

    
    
    repositories {
        maven {
            url "http://repo.mycompany.com/maven2"
            credentials {
                username "user"
                password "password"
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("http://repo.mycompany.com/maven2")
            credentials {
                username = "user"
                password = "password"
            }
        }
    }

The following example show how to configure a repository to use only
[DigestAuthentication](../javadoc/org/gradle/authentication/http/DigestAuthentication.html):

Example 26. Configure repository to use only digest authentication

build.gradle

    
    
    repositories {
        maven {
            url 'https://repo.mycompany.com/maven2'
            credentials {
                username "user"
                password "password"
            }
            authentication {
                digest(DigestAuthentication)
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("https://repo.mycompany.com/maven2")
            credentials {
                username = "user"
                password = "password"
            }
            authentication {
                create<DigestAuthentication>("digest")
            }
        }
    }

Currently supported authentication schemes are:

[BasicAuthentication](../javadoc/org/gradle/authentication/http/BasicAuthentication.html)

    

Basic access authentication over HTTP. When using this scheme, credentials are
sent preemptively.

[DigestAuthentication](../javadoc/org/gradle/authentication/http/DigestAuthentication.html)

    

Digest access authentication over HTTP.

[HttpHeaderAuthentication](../javadoc/org/gradle/authentication/http/HttpHeaderAuthentication.html)

    

Authentication based on any custom HTTP header, e.g. private tokens, OAuth
tokens, etc.

### Using preemptive authentication

Gradle's default behavior is to only submit credentials when a server responds
with an authentication challenge in the form of an HTTP 401 response. In some
cases, the server will respond with a different code (ex. for repositories
hosted on GitHub a 404 is returned) causing dependency resolution to fail. To
get around this behavior, credentials may be sent to the server preemptively.
To enable preemptive authentication simply configure your repository to
explicitly use the
[BasicAuthentication](../javadoc/org/gradle/authentication/http/BasicAuthentication.html)
scheme:

Example 27. Configure repository to use preemptive authentication

build.gradle

    
    
    repositories {
        maven {
            url 'https://repo.mycompany.com/maven2'
            credentials {
                username "user"
                password "password"
            }
            authentication {
                basic(BasicAuthentication)
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("https://repo.mycompany.com/maven2")
            credentials {
                username = "user"
                password = "password"
            }
            authentication {
                create<BasicAuthentication>("basic")
            }
        }
    }

### Using HTTP header authentication

You can specify any HTTP header for secured Maven repositories requiring
token, OAuth2 or other HTTP header based authentication using
[HttpHeaderCredentials](../javadoc/org/gradle/api/credentials/HttpHeaderCredentials.html)
with
[HttpHeaderAuthentication](../javadoc/org/gradle/authentication/http/HttpHeaderAuthentication.html).

Example 28. Accessing header-protected Maven repository

build.gradle

    
    
    repositories {
        maven {
            url "http://repo.mycompany.com/maven2"
            credentials(HttpHeaderCredentials) {
                name = "Private-Token"
                value = "TOKEN"
            }
            authentication {
                header(HttpHeaderAuthentication)
            }
        }
    }

build.gradle.kts

    
    
    repositories {
        maven {
            url = uri("http://repo.mycompany.com/maven2")
            credentials(HttpHeaderCredentials::class) {
                name = "Private-Token"
                value = "TOKEN"
            }
            authentication {
                create<HttpHeaderAuthentication>("header")
            }
        }
    }

## AWS S3 repositories configuration

### S3 configuration properties

The following system properties can be used to configure the interactions with
s3 repositories:

`org.gradle.s3.endpoint`

    

Used to override the AWS S3 endpoint when using a non AWS, S3 API compatible,
storage service.

`org.gradle.s3.maxErrorRetry`

    

Specifies the maximum number of times to retry a request in the event that the
S3 server responds with a HTTP 5xx status code. When not specified a default
value of 3 is used.

### S3 URL formats

S3 URL's are 'virtual-hosted-style' and must be in the following format

    
    
    s3://<bucketName>[.<regionSpecificEndpoint>]/<s3Key>

e.g. `s3://myBucket.s3.eu-central-1.amazonaws.com/maven/release`

  * `myBucket` is the AWS S3 bucket name.

  * `s3.eu-central-1.amazonaws.com` is the _optional_ [region specific endpoint](http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region).

  * `/maven/release` is the AWS S3 key (unique identifier for an object within a bucket)

### S3 proxy settings

A proxy for S3 can be configured using the following system properties:

  * `https.proxyHost`

  * `https.proxyPort`

  * `https.proxyUser`

  * `https.proxyPassword`

  * `http.nonProxyHosts`

If the `org.gradle.s3.endpoint` property has been specified with a HTTP (not
HTTPS) URI the following system proxy settings can be used:

  * `http.proxyHost`

  * `http.proxyPort`

  * `http.proxyUser`

  * `http.proxyPassword`

  * `http.nonProxyHosts`

### AWS S3 V4 Signatures (AWS4-HMAC-SHA256)

Some of the AWS S3 regions (eu-central-1 - Frankfurt) require that all HTTP
requests are signed in accordance with AWS's [signature version
4](http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html). It
is recommended to specify S3 URL's containing the region specific endpoint
when using buckets that require V4 signatures. e.g.

    
    
    s3://somebucket.s3.eu-central-1.amazonaws.com/maven/release

__ |

When a region-specific endpoint is not specified for buckets requiring V4
Signatures, Gradle will use the default AWS region (us-east-1) and the
following warning will appear on the console:

> Attempting to re-send the request to …​. with AWS V4 authentication. To
> avoid this warning in the future, use region-specific endpoint to access
> buckets located in regions that require V4 signing.

Failing to specify the region-specific endpoint for buckets requiring V4
signatures means:

  * 3 round-trips to AWS, as opposed to one, for every file upload and download.

  * Depending on location - increased network latencies and slower builds.

  * Increased likelihood of transmission failures.

  
  
---|---  
  
#### AWS S3 Cross Account Access

Some organizations may have multiple AWS accounts, e.g. one for each team. The
AWS account of the bucket owner is often different from the artifact publisher
and consumers. The bucket owner needs to be able to grant the consumers access
otherwise the artifacts will only be usable by the publisher's account. This
is done by adding the `bucket-owner-full-control` [Canned
ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-
acl) to the uploaded objects. Gradle will do this in every upload. Make sure
the publisher has the required IAM permission, `PutObjectAcl` (and
`PutObjectVersionAcl` if bucket versioning is enabled), either directly or via
an assumed IAM Role (depending on your case). You can read more at [AWS S3
Access Permissions](https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-
control.html).

## Google Cloud Storage repositories configuration

### GCS configuration properties

The following system properties can be used to configure the interactions with
[Google Cloud Storage](https://cloud.google.com/storage/) repositories:

`org.gradle.gcs.endpoint`

    

Used to override the Google Cloud Storage endpoint when using a non-Google
Cloud Platform, Google Cloud Storage API compatible, storage service.

`org.gradle.gcs.servicePath`

    

Used to override the Google Cloud Storage root service path which the Google
Cloud Storage client builds requests from, defaults to `/`.

### GCS URL formats

Google Cloud Storage URL's are 'virtual-hosted-style' and must be in the
following format `gcs://<bucketName>/<objectKey>`

e.g. `gcs://myBucket/maven/release`

  * `myBucket` is the Google Cloud Storage bucket name.

  * `/maven/release` is the Google Cloud Storage key (unique identifier for an object within a bucket)

## Handling credentials

Repository credentials should never be part of your build script but rather be
kept external. Gradle provides [an API in artifact
repositories](../javadoc/org/gradle/api/artifacts/repositories/AuthenticationSupported.html#credentials-
java.lang.Class-) that allows you to declare only the type of required
credentials. Credential values are looked up from the [Gradle
Properties](build_environment.html#sec:gradle_configuration_properties) during
the build that requires them.

For example, given repository configuration:

Example 29. Externalized repository credentials

build.gradle

    
    
        repositories {
            maven {
                name = 'mySecureRepository'
                credentials(PasswordCredentials)
                // url = uri(<<some repository url>>)
            }
        }

build.gradle.kts

    
    
        repositories {
            maven {
                name = "mySecureRepository"
                credentials(PasswordCredentials::class)
                // url = uri(<<some repository url>>)
            }
        }

The username and password will be looked up from `mySecureRepositoryUsername`
and `mySecureRepositoryPassword` properties.

Note that the configuration property prefix - the identity - is determined
from the repository name. Credentials can then be provided in any of supported
ways for Gradle Properties - `gradle.properties` file, command line arguments,
environment variables or a combination of those options.

Also, note that credentials will only be required if the invoked build
requires them. If for example a project is configured to publish artifacts to
a secured repository, but the build does not invoke publishing task, Gradle
will not require publishing credentials to be present. On the other hand, if
the build needs to execute a task that requires credentials at some point,
Gradle will check for credential presence first thing and will not start
running any of the tasks if it knows that the build will fail at a later point
because of missing credentials.

Here is a [downloadable sample](../samples/sample_publishing_credentials.html)
that demonstrates the concept in more detail.

The same rules apply for supplying
[AwsCredentials](../javadoc/org/gradle/api/credentials/AwsCredentials.html).

**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

