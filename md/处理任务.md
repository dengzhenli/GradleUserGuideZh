# 创作任务


内容

  * [任务成果](#任务成果)
  * [定义任务](#定义任务)
  * [定位任务](#定位任务)
  * [配置任务](#配置任务)
  * [将参数传递给任务构造函数](#将参数传递给任务构造函数)
  * [向任务添加依赖项](#向任务添加依赖项)
  * [订购任务](#订购任务)
  * [为任务添加描述](#为任务添加描述)
  * [跳过任务](#跳过任务)
  * [最新检查（又称增量构建）](#最新检查（又称增量构建）)
  * [任务规则](#任务规则)
  * [终结器任务](#终结器任务)
  * [生命周期任务](#生命周期任务)
  * [概要](#概要)

在[入门教程中，](/md/构建脚本基础.md#tutorial_using_tasks)您学习了如何创建简单任务。您还学习了以后如何向这些任务添加其他行为，还学习了如何在任务之间创建依赖关系。这些都是关于简单任务的，但是Gradle将任务的概念进一步扩展了。Gradle支持具有自己的属性和方法的任务。这些任务要么由您提供，要么内置在Gradle中。

## [任务成果](#任务成果)

当Gradle执行任务时，它可以在控制台UI中以及通过[Tooling
API](/md/Gradle和第三方工具_md#使用Tooling%20API嵌入Gradle)将任务标记为不同的结果。这些标签基于任务是否具有要执行的动作，是否应执行那些动作，是否确实执行了这些动作以及这些动作是否进行了任何更改。

`(no label)` 要么 `EXECUTED`

    

任务执行了其动作。

  * Task有动作，Gradle已确定应将其作为构建的一部分执行。

  * Task没有动作，并且有一些依赖关系，并且任何依赖关系都将执行。另请参见[生命周期任务](#生命周期任务)。

`UP-TO-DATE`

    

任务的输出未更改。

  * 任务具有输出和输入，并且它们没有改变。请参阅[增量构建](#最新检查（又称增量构建）)。

  * 任务有动作，但是任务告诉Gradle它没有更改其输出。

  * 任务没有任何动作，并且有一些依赖关系，但是所有依赖关系都是最新的，已跳过或来自缓存。另请参见[生命周期任务](#生命周期任务)。

  * 任务没有动作，也没有依赖关系。

`FROM-CACHE`

    

任务的输出可以从先前的执行中找到。

  * 任务的输出已从构建缓存中还原。请参阅[构建缓存](/md/构建缓存.md#build_cache)。

`SKIPPED`

    

任务未执行其动作。

  * 任务已从命令行中明确排除。请参阅[从执行中排除任务](/md/命令行界面_md#从执行中排除任务)。

  * 任务有一个`onlyIf`谓词返回false。请参阅[使用谓词](#使用谓词)。

`NO-SOURCE`

    

任务不需要执行其动作。

  * 任务具有输入和输出，但[没有源](#skip-when-empty)。例如，源文件是[JavaCompile的](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html)`.java`文件。[](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html)

## [定义任务](#定义任务)

在[本章中，](/md/构建脚本基础.md#tutorial_using_tasks)我们已经看到了如何使用字符串作为任务名称来定义任务。此样式有一些变体，您可能需要在某些情况下使用。

╔═════════════════════════════

在“[避免任务配置”一章](/md/避免任务配置.md)中将更详细地描述任务配置API
。  
  
╚═════════════════════════════  
  
示例1.使用字符串作为任务名称定义任务

`Groovy``Kotlin`

build.gradle

    
    
    task('hello') {
        doLast {
            println "hello"
        }
    }
    
    task('copy', type: Copy) {
        from(file('srcDir'))
        into(buildDir)
    }

build.gradle.kts

    
    
    tasks.register("hello") {
        doLast {
            println("hello")
        }
    }
    
    tasks.register<Copy>("copy") {
        from(file("srcDir"))
        into(buildDir)
    }

有一种定义任务的替代语法，您可能更喜欢使用：

例子2.使用`tasks`容器定义任务

`Groovy``Kotlin`

build.gradle

    
    
    tasks.create('hello') {
        doLast {
            println "hello"
        }
    }
    
    tasks.create('copy', Copy) {
        from(file('srcDir'))
        into(buildDir)
    }

build.gradle.kts

    
    
    tasks.register("hello") {
        doLast {
            println("hello")
        }
    }
    
    tasks {
        register<Copy>("copy") {
            from(file("srcDir"))
            into(buildDir)
        }
    }

在这里，我们将任务添加到`tasks`集合中。看一下[TaskContainer](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskContainer.html)，了解该`register()`方法的更多变化。

最后，Groovy和Kotlin DSL有特定于语言的语法：

例子3.使用DSL特定语法定义任务

`Groovy``Kotlin`

build.gradle

    
    
    // Using Groovy dynamic keywords
    
    task(hello) {
        doLast {
            println "hello"
        }
    }
    
    task(copy, type: Copy) {
        from(file('srcDir'))
        into(buildDir)
    }

build.gradle.kts

    
    
    // Using Kotlin delegated properties
    
    val hello by tasks.registering {
        doLast {
            println("hello")
        }
    }
    
    val copy by tasks.registering(Copy::class) {
        from(file("srcDir"))
        into(buildDir)
    }

Note that the Kotlin [delegated
properties](https://kotlinlang.org/docs/reference/delegated-properties.html)
syntax is particularly useful if you need the created task for further
reference.

## [定位任务](#定位任务)

您通常需要找到在构建文件中定义的任务，例如，对其进行配置或将其用于依赖项。有很多方法可以做到这一点。首先，就像定义任务一样，Groovy和Kotlin
DSL具有特定于语言的语法：

示例4.使用DSL特定语法访问任务

`Groovy``Kotlin`

build.gradle

    
    
    task hello
    task copy(type: Copy)
    
    // Access tasks using Groovy dynamic properties on Project
    
    println hello.name
    println project.hello.name
    
    println copy.destinationDir
    println project.copy.destinationDir

build.gradle.kts

    
    
    task("hello")
    task<Copy>("copy")
    
    // Access tasks using Kotlin delegated properties
    
    val hello by tasks.getting
    println(hello.name)
    
    val copy by tasks.getting(Copy::class)
    println(copy.destinationDir)

任务也可以通过`tasks`集合获得。

例子5.通过任务集合访问任务

`Groovy``Kotlin`

build.gradle

    
    
    task hello
    task copy(type: Copy)
    
    println tasks.hello.name
    println tasks.named('hello').get().name
    
    println tasks.copy.destinationDir
    println tasks.named('copy').get().destinationDir

build.gradle.kts

    
    
    tasks.register("hello")
    tasks.register<Copy>("copy")
    
    println(tasks["hello"].name)
    println(tasks.named("hello").get().name)
    
    println(tasks.getByName<Copy>("copy").destinationDir)
    println(tasks.named<Copy>("copy").get().destinationDir)

您可以使用`tasks.getByPath()`方法使用任务的路径访问任何项目中的任务。您可以`getByPath()`使用任务名称，相对路径或绝对路径来调用该方法。

例子6.通过路径访问任务

`Groovy``Kotlin`

project-a / build.gradle

    
    
    task hello

build.gradle

    
    
    task hello
    
    println tasks.getByPath('hello').path
    println tasks.getByPath(':hello').path
    println tasks.getByPath('project-a:hello').path
    println tasks.getByPath(':project-a:hello').path

project-a/build.gradle.kts

    
    
    tasks.register("hello")

build.gradle.kts

    
    
    tasks.register("hello")
    
    println(tasks.getByPath("hello").path)
    println(tasks.getByPath(":hello").path)
    println(tasks.getByPath("project-a:hello").path)
    println(tasks.getByPath(":project-a:hello").path)

输出 **`gradle -q hello`**

    
    
    > gradle -q hello
    :hello
    :hello
    :project-a:hello
    :project-a:hello

使用该`tasks.withType()`方法也可以访问特定类型的任务。这使得可以轻松避免代码重复并减少冗余。

例子7.按任务类型访问任务

`Groovy``Kotlin`

build.gradle

    
    
    tasks.withType(Tar).configureEach {
        enabled = false
    }
    
    task test {
        dependsOn tasks.withType(Copy)
    }

build.gradle.kts

    
    
    tasks.withType<Tar>().configureEach {
        enabled = false
    }
    
    tasks.register("test") {
        dependsOn(tasks.withType<Copy>())
    }

请查看[TaskContainer，](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskContainer.html)以获取更多用于定位任务的选项。

## [配置任务](#配置任务)

作为示例，让我们看一下`Copy`Gradle提供的任务。要`Copy`为构建创建任务，可以在构建脚本中声明：

例子8.创建复制任务

`Groovy``Kotlin`

build.gradle

    
    
    task myCopy(type: Copy)

build.gradle.kts

    
    
    tasks.register<Copy>("myCopy")

这将创建一个没有默认行为的复制任务。可以使用其API配置任务（请参见[Copy](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.Copy.html)）。以下示例显示了实现同一配置的几种不同方法。

为了清楚起见，请意识到此任务的名称为“ `myCopy`”，但 _类型为_ “ `Copy`”。您可以具有多个 _类型_
相同但名称不同的任务。您会发现这为您提供了强大的能力来跨特定类型的所有任务实施跨领域关注点。

示例9.使用API​​配置任务

`Groovy``Kotlin`

build.gradle

    
    
    Copy myCopy = tasks.getByName("myCopy")
    myCopy.from 'resources'
    myCopy.into 'target'
    myCopy.include('**/*.txt', '**/*.xml', '**/*.properties')

build.gradle.kts

    
    
    val myCopy = tasks.named<Copy>("myCopy")
    myCopy {
        from("resources")
        into("target")
        include("**/*.txt", "**/*.xml", "**/*.properties")
    }

这类似于我们在Java中配置对象的方式。您`myCopy`每次必须在配置语句中重复上下文（）。这是多余的，阅读起来也不是很好。

还有另一种配置任务的方法。它还保留了上下文，并且可以说是最易读的。通常是我们的最爱。

示例10.使用DSL特定语法配置任务

`Groovy``Kotlin`

build.gradle

    
    
    // Configure task using Groovy dynamic task configuration block
    myCopy {
       from 'resources'
       into 'target'
    }
    myCopy.include('**/*.txt', '**/*.xml', '**/*.properties')

build.gradle.kts

    
    
    // Configure task using Kotlin delegated properties and a lambda
    val myCopy by tasks.existing(Copy::class) {
        from("resources")
        into("target")
    }
    myCopy { include("**/*.txt", "**/*.xml", "**/*.properties") }

这适用于 _任何_
任务。任务访问只是`tasks.named()`（Kotlin）或`tasks.getByName()`（Groovy）方法的快捷方式。重要的是要注意，此处使用的块用于
_配置_ 任务，并且在执行任务时不会对其进行评估。

看一下[TaskContainer](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskContainer.html)，了解更多配置任务的选项。

定义任务时，也可以使用配置块。

例子11.用配置块定义一个任务

`Groovy``Kotlin`

build.gradle

    
    
    task copy(type: Copy) {
       from 'resources'
       into 'target'
       include('**/*.txt', '**/*.xml', '**/*.properties')
    }

build.gradle.kts

    
    
    tasks.register<Copy>("copy") {
       from("resources")
       into("target")
       include("**/*.txt", "**/*.xml", "**/*.properties")
    }

╔═════════════════════════════

不要忘记构建阶段

任务具有配置和动作。使用时`doLast`，您只是在使用快捷方式来定义动作。任务的配置部分中定义的代码将在构建的配置阶段执行，无论目标对象是什么。有关[构建生命周期](/md/构建生命周期.md#build_lifecycle)的更多详细信息，请参见[构建生命](/md/构建生命周期.md#build_lifecycle)周期。  
  
╚═════════════════════════════  
  
## [将参数传递给任务构造函数](#将参数传递给任务构造函数)

与`Task`在创建后配置可变属性相反，您可以将参数值传递给`Task`类的构造函数。为了将值传递给`Task`构造函数，您必须使用注释相关的构造函数`@javax.inject.Inject`。

例子12.带有`@Inject`构造函数的任务类

`Groovy``Kotlin`

build.gradle

    
    
    class CustomTask extends DefaultTask {
        final String message
        final int number
    
        @Inject
        CustomTask(String message, int number) {
            this.message = message
            this.number = number
        }
    }

build.gradle.kts

    
    
    open class CustomTask @Inject constructor(
        private val message: String,
        private val number: Int
    ) : DefaultTask()

然后，您可以创建一个任务，并在参数列表的末尾传递构造函数参数。

例子13.使用TaskContainer创建带有构造函数参数的任务

`Groovy``Kotlin`

build.gradle

    
    
    tasks.create('myTask', CustomTask, 'hello', 42)

build.gradle.kts

    
    
    tasks.register<CustomTask>("myTask", "hello", 42)

您还可以`constructorArgs`使用Project API使用Map参数创建任务：

例子14.使用Map创建带有构造函数参数的任务

`Groovy``Kotlin`

build.gradle

    
    
    task myTask(type: CustomTask, constructorArgs: ['hello', 42])

build.gradle.kts

    
    
    task("myTask", "type" to CustomTask::class.java, "constructorArgs" to listOf("hello", 42))

╔═════════════════════════════

首选使用TaskContainer使用构造函数参数创建任务

建议使用“[避免任务配置”](/md/避免任务配置.md)
API来缩短配置时间。  
  
╚═════════════════════════════  
  
在所有情况下，作为构造函数参数传递的值都必须为非null。如果您尝试传递一个`null`值，Gradle将抛出一个`NullPointerException`指示，指出哪个运行时值是`null`。

## [向任务添加依赖项](#向任务添加依赖项)

您可以通过多种方式定义任务的依赖关系。在“[任务依赖项”中](/md/构建脚本基础_md#任务依赖性)，介绍了使用任务名称定义依赖项。任务名称可以引用与该任务在同一项目中的任务，也可以引用其他项目中的任务。要引用另一个项目中的任务，请在任务名称前添加其所属项目的路径。以下是添加从`project-a:taskX`到的依赖的示例`project-b:taskY`：

例子15.从另一个项目添加对任务的依赖

`Groovy``Kotlin`

build.gradle

    
    
    project('project-a') {
        task taskX {
            dependsOn ':project-b:taskY'
            doLast {
                println 'taskX'
            }
        }
    }
    
    project('project-b') {
        task taskY {
            doLast {
                println 'taskY'
            }
        }
    }

build.gradle.kts

    
    
    project("project-a") {
        tasks.register("taskX") {
            dependsOn(":project-b:taskY")
            doLast {
                println("taskX")
            }
        }
    }
    
    project("project-b") {
        tasks.register("taskY") {
            doLast {
                println("taskY")
            }
        }
    }

输出 **`gradle -q taskX`**

    
    
    > gradle -q taskX
    TaskY
    TaskX

您可以使用`Task`对象定义依赖项，而不是使用任务名称，如本示例所示：

例子16.使用任务对象添加依赖

`Groovy``Kotlin`

build.gradle

    
    
    task taskX {
        doLast {
            println 'taskX'
        }
    }
    
    task taskY {
        doLast {
            println 'taskY'
        }
    }
    
    taskX.dependsOn taskY

build.gradle.kts

    
    
    val taskX by tasks.registering {
        doLast {
            println("taskX")
        }
    }
    
    val taskY by tasks.registering {
        doLast {
            println("taskY")
        }
    }
    
    taskX {
        dependsOn(taskY)
    }

输出 **`gradle -q taskX`**

    
    
    > gradle -q taskX
    TaskY
    TaskX

对于更高级的用途，您可以使用惰性块定义任务依赖项。求值时，会将正在​​计算依赖关系的任务传递给该块。惰性块应返回单个`Task`或`Task`对象集合，然后将其视为任务的依赖项。下面的示例`taskX`将对项目以名称开头的所有任务添加从的依赖`lib`：

例子17.使用惰性块添加依赖项

`Groovy``Kotlin`

build.gradle

    
    
    task taskX {
        doLast {
            println 'taskX'
        }
    }
    
    // Using a Groovy Closure
    taskX.dependsOn {
        tasks.findAll { task -> task.name.startsWith('lib') }
    }
    
    task lib1 {
        doLast {
            println 'lib1'
        }
    }
    
    task lib2 {
        doLast {
            println 'lib2'
        }
    }
    
    task notALib {
        doLast {
            println 'notALib'
        }
    }

build.gradle.kts

    
    
    val taskX by tasks.registering {
        doLast {
            println("taskX")
        }
    }
    
    // Using a Gradle Provider
    taskX {
        dependsOn(provider {
            tasks.filter { task -> task.name.startsWith("lib") }
        })
    }
    
    tasks.register("lib1") {
        doLast {
            println("lib1")
        }
    }
    
    tasks.register("lib2") {
        doLast {
            println("lib2")
        }
    }
    
    tasks.register("notALib") {
        doLast {
            println("notALib")
        }
    }

输出 **`gradle -q taskX`**

    
    
    > gradle -q taskX
    lib1
    lib2
    taskX

有关任务依赖关系的更多信息，请参见[任务](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html)API。

## [订购任务](#订购任务)

在某些情况下，控制两个任务的执行 _顺序_ 很有用，而不必在这些任务之间引入明确的依赖关系。任务 _排序_ 和任务 _相关性_
之间的主要区别在于，排序规则不影响将执行哪些任务，仅影响将执行它们的顺序。

任务排序在许多情况下很有用：

  * 强制执行任务的顺序排序：例如，“ build”在“ clean”之前永远不会运行。

  * 在构建的早期进行构建验证：例如，在开始发布构建工作之前，请先验证我是否具有正确的凭据。

  * 通过在长验证任务之前运行快速验证任务来更快地获得反馈：例如，单元测试应在集成测试之前运行。

  * 汇总特定类型的所有任务的结果的任务：例如，测试报告任务将所有已执行的测试任务的输出合并。

有两个可用的排序规则：“ _必须在_ ” _之后运行_ 和“ _应在_ ” _之后运行_ 。

使用“必须在之后运行”排序规则时，您指定`taskB`必须始终在之后运行`taskA`，`taskA`并且两者都`taskB`将运行。这表示为`taskB.mustRunAfter(taskA)`。“应在之后运行”排序规则是相似的，但不太严格，因为它将在两种情况下被忽略。首先，如果使用该规则会引入一个订购周期。其次，当使用并行执行时，除了“应在后面运行”任务之外，还满足了任务的所有依赖关系，则无论该任务是否在“应在后面运行”依赖关系运行，都将运行该任务。您应该使用“应该在之后运行”，在该顺序很有帮助但并非严格要求的情况下。

这些规则目前仍然可以执行`taskA`没有`taskB`，反之亦然。

例子18.添加一个“必须在之后运行”任务排序

`Groovy``Kotlin`

build.gradle

    
    
    task taskX {
        doLast {
            println 'taskX'
        }
    }
    task taskY {
        doLast {
            println 'taskY'
        }
    }
    taskY.mustRunAfter taskX

build.gradle.kts

    
    
    val taskX by tasks.registering {
        doLast {
            println("taskX")
        }
    }
    val taskY by tasks.registering {
        doLast {
            println("taskY")
        }
    }
    taskY { mustRunAfter(taskX) }

输出 **`gradle -q taskY taskX`**

    
    
    > gradle -q taskY taskX
    TaskX
    TaskY

例子19.添加一个“应该在之后运行”任务排序

`Groovy``Kotlin`

build.gradle

    
    
    task taskX {
        doLast {
            println 'taskX'
        }
    }
    task taskY {
        doLast {
            println 'taskY'
        }
    }
    taskY.shouldRunAfter taskX

build.gradle.kts

    
    
    val taskX by tasks.registering {
        doLast {
            println("taskX")
        }
    }
    val taskY by tasks.registering {
        doLast {
            println("taskY")
        }
    }
    taskY { shouldRunAfter(taskX) }

输出 **`gradle -q taskY taskX`**

    
    
    > gradle -q taskY taskX
    TaskX
    TaskY

在上面的示例中，仍然可以执行`taskY`而无需`taskX`运行：

例子20.任务排序并不意味着任务执行

输出 **`gradle -q taskY`**

    
    
    > gradle -q taskY
    TaskY

要指定两个任务之间的“必须在之后运行”或“应在之后运行”顺序，请使用[Task.mustRunAfter（java.lang.Object
...）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter\(java.lang.Object\[\]\))和[Task.shouldRunAfter（java.lang.Object
...）](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/Task.html#shouldRunAfter-
java.lang.Object...-)方法。这些方法接受[Task.dependsOn（java.lang.Object
...）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn\(java.lang.Object\[\]\))接受的任务实例，任务名称或任何其他输入。

请注意，“ `B.mustRunAfter(A)`”或“ `B.shouldRunAfter(A)`”并不意味着任务之间有任何执行依赖性：

  * 它是可以执行的任务`A`和`B`独立。只有两个任务都计划执行时，排序规则才有效。

  * 当与一起运行时`--continue`，有可能`B`在`A`失败的情况下执行。

如前所述，如果引入了订购周期，则“应在之后运行”订购规则将被忽略：

例21.如果引入了一个订购周期，则“应在之后运行”任务订购被忽略

`Groovy``Kotlin`

build.gradle

    
    
    task taskX {
        doLast {
            println 'taskX'
        }
    }
    task taskY {
        doLast {
            println 'taskY'
        }
    }
    task taskZ {
        doLast {
            println 'taskZ'
        }
    }
    taskX.dependsOn taskY
    taskY.dependsOn taskZ
    taskZ.shouldRunAfter taskX

build.gradle.kts

    
    
    val taskX by tasks.registering {
        doLast {
            println("taskX")
        }
    }
    val taskY by tasks.registering {
        doLast {
            println("taskY")
        }
    }
    val taskZ by tasks.registering {
        doLast {
            println("taskZ")
        }
    }
    taskX { dependsOn(taskY) }
    taskY { dependsOn(taskZ) }
    taskZ { shouldRunAfter(taskX) }

输出 **`gradle -q taskX`**

    
    
    > gradle -q taskX
    taskZ
    TaskY
    TaskX

## [为任务添加描述](#为任务添加描述)

您可以在任务中添加描述。执行时将显示此描述`gradle tasks`。

例子22.给任务添加描述

`Groovy``Kotlin`

build.gradle

    
    
    task copy(type: Copy) {
       description 'Copies the resource directory to the target directory.'
       from 'resources'
       into 'target'
       include('**/*.txt', '**/*.xml', '**/*.properties')
    }

build.gradle.kts

    
    
    tasks.register<Copy>("copy") {
       description = "Copies the resource directory to the target directory."
       from("resources")
       into("target")
       include("**/*.txt", "**/*.xml", "**/*.properties")
    }

## [跳过任务](#跳过任务)

Gradle提供了多种方法来跳过任务的执行。

### [使用谓词](#使用谓词)

您可以使用该`onlyIf()`方法将谓词附加到任务。仅当谓词评估为true时，才执行任务的动作。您将谓词实现为闭包。闭包作为参数传递给任务，如果任务应执行，则应返回true；如果应跳过任务，则应返回false。在即将执行任务之前就对谓词进行评估。

例子23.使用谓词跳过任务

`Groovy``Kotlin`

build.gradle

    
    
    task hello {
        doLast {
            println 'hello world'
        }
    }
    
    hello.onlyIf { !project.hasProperty('skipHello') }

build.gradle.kts

    
    
    val hello by tasks.registering {
        doLast {
            println("hello world")
        }
    }
    
    hello {
        onlyIf { !project.hasProperty("skipHello") }
    }

输出 **`gradle hello -PskipHello`**

    
    
    > gradle hello -PskipHello
    > Task :hello SKIPPED
    
    BUILD SUCCESSFUL in 0s

### [使用StopExecutionException](#使用StopExecutionException)

如果跳过任务的逻辑不能用谓词表示，则可以使用[StopExecutionException](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/StopExecutionException.html)。如果某个动作引发了此异常，则将跳过该动作的进一步执行以及该任务的任何后续动作的执行。构建继续执行下一个任务。

例子24.使用StopExecutionException跳过任务

`Groovy``Kotlin`

build.gradle

    
    
    task compile {
        doLast {
            println 'We are doing the compile.'
        }
    }
    
    compile.doFirst {
        // Here you would put arbitrary conditions in real life.
        // But this is used in an integration test so we want defined behavior.
        if (true) { throw new StopExecutionException() }
    }
    task myTask {
        dependsOn('compile')
        doLast {
            println 'I am not affected'
        }
    }

build.gradle.kts

    
    
    val compile by tasks.registering {
        doLast {
            println("We are doing the compile.")
        }
    }
    
    compile {
        doFirst {
            // Here you would put arbitrary conditions in real life.
            // But this is used in an integration test so we want defined behavior.
            if (true) {
                throw StopExecutionException()
            }
        }
    }
    tasks.register("myTask") {
        dependsOn(compile)
        doLast {
            println("I am not affected")
        }
    }

输出 **`gradle -q myTask`**

        
    > gradle -q myTask
    I am not affected

如果您使用Gradle提供的任务，此功能将非常有用。它允许您添加此类任务的内置操作的 _有条件_ 执行。[
[1](#_footnotedef_1
"查看脚注。") ]

### [启用和禁用任务](#启用和禁用任务)

每个任务都有一个`enabled`默认为的标志`true`。将其设置为`false`禁止执行任何任务动作。禁用的任务将标记为“跳过”。

例子25.启用和禁用任务

`Groovy``Kotlin`

build.gradle

    
    
    task disableMe {
        doLast {
            println 'This should not be printed if the task is disabled.'
        }
    }
    disableMe.enabled = false

build.gradle.kts

    
    
    val disableMe by tasks.registering {
        doLast {
            println("This should not be printed if the task is disabled.")
        }
    }
    disableMe {
        enabled = false
    }

输出 **`gradle disableMe`**

    
    
    > gradle disableMe
    > Task :disableMe SKIPPED
    
    BUILD SUCCESSFUL in 0s

### [任务超时](#任务超时)

每个任务都有一个`timeout`可用于限制其执行时间的属性。当任务达到超时时，其任务执行线程将被中断。该任务将被标记为失败。终结器任务仍将运行。如果`--continue`使用，其他任务可以在此之后继续运行。不响应中断的任务无法超时。Gradle的所有内置任务均会及时响应超时。

例子26.指定任务超时

`Groovy``Kotlin`

build.gradle

    
    
    task hangingTask() {
        doLast {
            Thread.sleep(100000)
        }
        timeout = Duration.ofMillis(500)
    }

build.gradle.kts

    
    
    import java.time.Duration
    
    tasks {
        register("hangingTask") {
            doLast {
                Thread.sleep(100000)
            }
            timeout.set(Duration.ofMillis(500))
        }
    }

## [最新检查（又称增量构建）](#最新检查（又称增量构建）)

任何构建工具的重要组成部分是避免执行已经完成的工作的能力。考虑编译过程。编译完源文件后，除非更改了一些会影响输出的内容（例如修改源文件或删除输出文件），否则就无需重新编译它们。而且编译可能要花费大量时间，因此在不需要时跳过该步骤可以节省大量时间。

Gradle通过调用增量构建的功能来开箱即用地支持此行为。您几乎可以肯定已经在实际中看到了它：`UP-TO-
DATE`运行构建时，几乎每次在任务名称旁边出现文本时，它就处于活动状态。任务结果在[任务结果中](#任务成果)进行了描述。

增量构建如何工作？在自己的任务中需要使用什么呢？让我们来看看。

### [任务输入和输出](#任务输入和输出)

在最常见的情况下，任务需要一些输入并产生一些输出。如果使用前面的编译示例，则可以看到源文件是输入，对于Java，生成的类文件是输出。其他输入可能包括诸如是否应包含调试信息之类的内容。

![taskInputsOutputs](img/taskInputsOutputs.png)

图1.示例任务输入和输出

如上图所示，输入的一个重要特征是它会影响一个或多个输出。根据源文件的内容以及要在其上运行代码的Java运行时的最低版本，会生成不同的字节码。这使它们成为任务输入。但是，由`memoryMaximumSize`属性确定编译是否具有500MB或600MB的最大可用内存，对生成什么字节码没有影响。用Gradle术语来说，`memoryMaximumSize`只是内部任务属性。

作为增量构建的一部分，Gradle会测试自上次构建以来是否已更改任何任务输入或输出。如果还没有，Gradle可以考虑该任务是最新的，因此跳过执行其动作。另请注意，除非一个任务至少具有一个任务输出，否则增量构建将无法正常工作，尽管任务通常也至少具有一个输入。

对于构建作者来说，这很简单：您需要告诉Gradle哪些任务属性是输入，哪些是输出。如果任务属性影响输出，请确保将其注册为输入，否则，该任务将被认为是最新的。相反，如果属性不会影响输出，则不要将其注册为输入，否则任务可能会在不需要时执行。也要注意那些不确定的任务，这些任务可能为完全相同的输入生成不同的输出：不应为增量构建配置这些任务，因为最新的检查将不起作用。

现在让我们看一下如何将任务属性注册为输入和输出。

#### [自定义任务类型](#自定义任务类型)

如果您要以类的形式实现自定义任务，则只需两步即可使其与增量构建一起使用：

  1. 为每个任务输入和输出创建类型化的属性（通过getter方法）

  2. 向每个属性添加适当的注释

╔═════════════════════════════

注释必须放在吸气剂或Groovy属性上。放置在setter上或没有相应带注释的getter的Java字段上的注释将被忽略。  
  
╚═════════════════════════════  
  
Gradle支持三种主要的输入和输出类别：

  * 简单的价值观

诸如字符串和数字之类的东西。更一般而言，简单值可以具有实现的任何类型`Serializable`。

  * 文件系统类型

这些包括标准`File`类，还包括Gradle的[FileCollection](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/file/FileCollection.html)类型的[派生](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/file/FileCollection.html)类，以及可以传递给[Project.file（java.lang.Object）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file\(java.lang.Object\))方法（用于单个文件/目录属性）或[Project.files（java）的任何其他内容。
lang.Object
...）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files\(java.lang.Object\[\]\))方法。

  * 嵌套值

自定义类型不符合其他两个类别，但是具有自己的属性，即输入或输出。实际上，任务输入或输出嵌套在这些自定义类型中。

例如，假设您有一个任务来处理各种类型的模板，例如FreeMarker，Velocity，Moustache等。它需要模板源文件，并将它们与一些模型数据结合起来以生成模板文件的填充版本。

该任务将具有三个输入和一个输出：

  * 模板源文件

  * 模型数据

  * 模板引擎

  * 写入输出文件的位置

在编写自定义任务类时，很容易通过注释将属性注册为输入或输出。为了演示，这是一个基本任务实现，其中包含一些合适的输入和输出以及它们的注释：

例子27.定制任务类

buildSrc / src / main / java / org / example / ProcessTemplates.java

    
    
    package org.example;
    
    import java.io.File;
    import java.util.HashMap;
    import org.gradle.api.*;
    import org.gradle.api.file.*;
    import org.gradle.api.tasks.*;
    
    public class ProcessTemplates extends DefaultTask {
        private TemplateEngineType templateEngine;
        private FileCollection sourceFiles;
        private TemplateData templateData;
        private File outputDir;
    
        @Input
        public TemplateEngineType getTemplateEngine() {
            return this.templateEngine;
        }
    
        @InputFiles
        public FileCollection getSourceFiles() {
            return this.sourceFiles;
        }
    
        @Nested
        public TemplateData getTemplateData() {
            return this.templateData;
        }
    
        @OutputDirectory
        public File getOutputDir() { return this.outputDir; }
    
        // + setter methods for the above - assume we’ve defined them
    
        @TaskAction
        public void processTemplates() {
            // ...
        }
    }

buildSrc / src / main / java / org / example / TemplateData.java

    
    
    package org.example;
    
    import java.util.HashMap;
    import java.util.Map;
    import org.gradle.api.tasks.Input;
    
    public class TemplateData {
        private String name;
        private Map<String, String> variables;
    
        public TemplateData(String name, Map<String, String> variables) {
            this.name = name;
            this.variables = new HashMap<>(variables);
        }
    
        @Input
        public String getName() { return this.name; }
    
        @Input
        public Map<String, String> getVariables() {
            return this.variables;
        }
    }

输出 `gradle processTemplates`

    
    > gradle processTemplates
    > Task :processTemplates
    
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

输出`gradle processTemplates`（再次运行）

    
    
    > gradle processTemplates
    > Task :processTemplates UP-TO-DATE
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 up-to-date

在此示例中有很多要讨论的内容，因此让我们依次研究每个输入和输出属性：

  * `templateEngine`

表示在处理源模板（例如FreeMarker，Velocity等）时要使用的引擎。您可以将其实现为字符串，但是在这种情况下，我们选择了自定义枚举，因为它提供了更多的类型信息和安全性。由于枚举是`Serializable`自动实现的，因此可以像对待属性`@Input`一样将其视为简单值并使用批注`String`。

  * `sourceFiles`

任务将要处理的源模板。单个文件和文件集合需要它们自己的特殊注释。在这种情况下，我们正在处理输入文件的集合，因此我们使用`@InputFiles`注释。稍后，您会在表格中看到更多面向文件的注释。

  * `templateData`

对于此示例，我们使用自定义类来表示模型数据。但是，它没有实现`Serializable`，因此我们不能使用`@Input`注释。这不是问题，因为其中的属性`TemplateData`（带有可序列化类型参数的字符串和哈希图）是可序列化的，并且可以使用进行注释`@Input`。我们使用`@Nested`on`templateData`让Gradle知道这是具有嵌套输入属性的值。

  * `outputDir`

生成文件所在的目录。与输入文件一样，输出文件和目录也有一些注释。表示单个目录的属性需要`@OutputDirectory`。您很快就会了解其他。

这些带注释的属性意味着，自从Gradle上次执行任务以来，如果源文件，模板引擎，模型数据或生成的文件均未更改，则Gradle将跳过任务。这通常会节省大量时间。您可以[稍后](#它是如何工作的？)了解Gradle如何检测[更改](#它是如何工作的？)。

这个示例特别有趣，因为它可以处理源文件的集合。如果仅更改一个源文件，会发生什么？该任务会再次处理所有源文件还是仅处理已修改的源文件？这取决于任务的实现。如果是后者，那么任务本身就是增量的，但这与我们在此讨论的功能不同。Gradle通过其[增量任务输入](/md/开发自定义Gradle任务类型_md#增量任务)功能确实可以帮助任务实施者。

现在您已经在实践中看到了一些输入和输出注释，下面让我们看一下所有可用的注释以及何时使用它们。下表列出了可用的注释以及可以与每个注释一起使用的相应属性类型。

表1.增量构建属性类型注释

 注解 | 预期物业类型 | 描述  
---|---|---  
@[Input](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Input.html)|任何`Serializable`类型|一个简单的输入值    
@[InputFile](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/InputFile.html)|`File`*|单个输入文件（非目录）  
@[InputDirectory](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/InputDirectory.html)|`File`*|单个输入目录（不是文件）  
@[InputFiles](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/InputFiles.html)|`Iterable<File>`*|输入文件和目录的迭代  
@[Classpath](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Classpath.html)|`Iterable<File>`*|代表Java类路径的输入文件和目录的可迭代项。  这使任务可以忽略对属性的不相关更改，例如相同文件的名称不同。  它与注释属性相似，`@PathSensitive(RELATIVE)`但是它将忽略直接添加到类路径中的JAR文件的名称，并且会将文件顺序中的更改视为类路径中的更改。Gradle将检查类路径上jar文件的内容，并忽略不影响类路径语义的更改（例如文件日期和输入顺序）。   另请参阅[使用类路径注释](#使用类路径注释)。<br/> **注：** 该`@Classpath`注释在Gradle3.2中引入。为了与Gradle的早期版本保持兼容，类路径属性也应使用注释`@InputFiles`。
@[CompileClasspath](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/CompileClasspath.html)|`Iterable<File>`*|代表Java编译类路径的输入文件和目录的可迭代项。这使任务可以忽略不影响classpath中类API的不相关更改。另请参阅[使用类路径注释](#使用类路径注释)。<br>对类路径的以下更改将被忽略：<br>* 更改jar或顶级目录的路径。<br> * 更改时间戳和Jars中条目的顺序。<br>* 对资源和Jar清单的更改，包括添加或删除资源。<br>* 更改私有类元素，例如私有字段，方法和内部类。<br>* 对代码的更改，例如方法体，静态初始化器和字段初始化器（常量除外）。<br>* 调试信息的更改，例如，对注释的更改会影响类调试信息中的行号。<br>* 更改目录，包括Jars中的目录条目。<br>  ╔═════════════════════════════  <br>该`@CompileClasspath`注释在Gradle3.4推出。为了与Gradle  3.3和3.2保持兼容，还应使用注释编译类路径属性`@Classpath`。为了与3.2之前的Gradle版本兼容，该属性也应使用注释`@InputFiles`。   <br>╚═════════════════════════════  
@[OutputFile](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/OutputFile.html)|`File`*|单个输出文件（不是目录）  
@[OutputDirectory](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/OutputDirectory.html)|`File`*|单个输出目录（不是文件）  
@[OutputFiles](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/OutputFiles.html)|`Map<String, File>`**或`Iterable<File>`*|输出文件的可迭代或映射。使用文件树将关闭该任务的[缓存](/md/构建缓存_md#任务输出缓存)。  
@[OutputDirectories](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/OutputDirectories.html)|`Map<String, File>`**或`Iterable<File>`*|可迭代的输出目录。使用文件树将关闭该任务的[缓存](/md/构建缓存_md#任务输出缓存)。  
@[Destroys](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Destroys.html)|`File`或`Iterable<File>`*|指定此任务删除的一个或多个文件。请注意，任务可以定义输入/输出或可销毁对象，但不能同时定义两者。  
@[LocalState](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/LocalState.html)|`File`或`Iterable<File>`*|指定一个或多个表示[任务本地状态的](/md/开发自定义Gradle任务类型_md#为缓存的任务存储增量状态)文件。从缓存中加载任务时，将删除这些文件。  
@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)|任何自定义类型|一种自定义类型，可能无法实现，`Serializable`但至少具有一个用此表中的注释之一标记的字段或属性。甚至可能是另一个`@Nested`。  
@[Console](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Console.html)|随便哪种|指示该属性既不是输入也不是输出。它只是以某种方式影响任务的控制台输出，例如增加或减少任务的详细程度。  
@[Internal](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Internal.html)|随便哪种|指示该属性在内部使用，但既不是输入也不是输出。  
@[ReplacedBy](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/model/ReplacedBy.html)|随便哪种|指示该属性已被另一个属性替代，应作为输入或输出忽略。  
@[SkipWhenEmpty](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/SkipWhenEmpty.html)|`File`*|如果相应的文件或目录为空，以及与此注释声明的所有其他输入文件为空，则与`@InputFiles`或`@InputDirectory`告诉Gradle跳过任务。由于使用该批注声明为空的所有输入文件而被跳过的任务将导致明显的“无源”结果。例如，`NO-SOURCE`将在控制台输出中发出。暗示`[@Incremental](#incremental)`。  
@[Incremental](https://docs.gradle.org/6.7.1/javadoc/org/gradle/work/Incremental.html)|`Provider<FileSystemLocation>` 要么 `FileCollection`|与`@InputFiles`或`@InputDirectory`一起指示Gradle跟踪对带注释的文件属性的更改，因此可以通过来查询更改。[增量任务](/md/开发自定义Gradle任务类型_md#增量任务)所需。`@[InputChanges.getFileChanges()](https://docs.gradle.org/6.7.1/dsl/org.gradle.work.InputChanges.html)`[](/md/开发自定义Gradle任务类型_md#增量任务)  
@[Optional](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Optional.html)|随便哪种|与[可选](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Optional.html)API文档中列出的任何属性类型注释一起使用。此批注禁用对相应属性的验证检查。有关更多详细信息，请参见[验证部分](#输入和输出验证)。  
@[PathSensitive](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/PathSensitive.html)|`File`*|与任何输入文件属性一起使用，以告诉Gradle仅将文件路径的给定部分视为重要。例如，如果使用标记了属性`@PathSensitive(PathSensitivity.NAME_ONLY)`，则在不更改文件内容的情况下移动文件不会使任务过时。  
  
╔═════════════════════════════


实际上，`File`可以是[Project.file（java.lang.Object）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file\(java.lang.Object\))`Iterable<File>`接受的任何类型，也可以是[Project.files（java.lang.Object
...）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files\(java.lang.Object\[\]\))接受的任何类型。这包括的实例`Callable`，例如闭包，允许对属性值进行延迟评估。请注意，类型`FileCollection`和`FileTree`是`Iterable<File>`。  
  
╚═════════════════════════════  


与上述类似，`File`可以是[Project.file（java.lang.Object）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file\(java.lang.Object\))接受的任何类型。的`Map`本身可被包裹在`Callable`S，如封闭件。  
  
注释从所有父类型（包括已实现的接口）继承。属性类型注释会覆盖父类型中声明的任何其他属性类型注释。这样，`@InputFile`可以将属性转换`@InputDirectory`为子任务类型的属性。

用类型声明的属性上的注释将覆盖超类和任何已实现接口中声明的类似注释。超类注释优先于已实现接口中声明的注释。

表格中的[Console](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Console.html)和[Internal](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Internal.html)注释是特殊情况，因为它们未声明任务输入或任务输出。那为什么要使用它们呢？这样，您就可以利用[Java
Gradle插件开发插件](https://docs.gradle.org/6.7.1/userguide/java_gradle_plugin.html#java_gradle_plugin)来帮助您开发和发布自己的插件。该插件检查您的自定义任务类的任何属性是否缺少增量构建注释。这样可以防止您在开发过程中忘记添加适当的注释。

##### [使用类路径注释](#使用类路径注释)

此外`@InputFiles`，对于与JVM相关的任务，Gradle理解类路径输入的概念。当Gradle寻找更改时，对运行时和编译类路径的处理会有所不同。

与用注释的输入属性相反，对于类路径属性，文件集合中条目的顺序很重要。另一方面，类路径本身上的目录和jar文件的名称和路径将被忽略。类路径上jar文件中的时间戳以及类文件和资源的顺序也将被忽略，因此使用不同文件日期重新创建jar文件不会使任务过期。`@[InputFiles](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/InputFiles.html)`

运行时类路径用标记，并且它们通过[类路径规范化](#配置输入标准化)提供进一步的自定义。`@[Classpath](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Classpath.html)`[](#配置输入标准化)

带有注释的输入属性被视为Java编译类路径。除上述常规类路径规则外，编译类路径会忽略对除类文件以外的所有内容的更改。Gradle使用[Java避免编译中](https://docs.gradle.org/6.7.1/userguide/java_plugin.html#sec:java_compile_avoidance)描述的相同类分析来进一步过滤不影响类ABI的更改。这意味着仅涉及类实现的更改不会使任务过时。`@[CompileClasspath](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/CompileClasspath.html)`[](https://docs.gradle.org/6.7.1/userguide/java_plugin.html#sec:java_compile_avoidance)

##### [嵌套输入](#嵌套输入)

分析已声明的输入和输出子属性的任务属性时，Gradle使用实际值的类型。因此，它可以发现运行时子类型声明的所有子属性。`@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)`

当添加到时，的值被视为嵌套输入。`@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)``[Provider](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/provider/Provider.html)``Provider`

在添加到可迭代对象时，每个元素都被视为单独的嵌套输入。为Iterable中的每个嵌套输入分配一个名称，默认情况下为美元符号，后跟Iterable中的索引，例如。如果iterable的元素实现，则将该名称用作属性名称。如果不是所有元素都实现的话，迭代器中元素的顺序对于可靠的最新检查和缓存至关重要。不允许使用多个具有相同名称的元素。`@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)``$2``[Named](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/Named.html)``[Named](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/Named.html)`

在添加到地图时，然后使用键作为名称，为每个值添加一个嵌套输入。`@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)`

嵌套输入的类型和类路径也将被跟踪。这确保了对嵌套输入的实现的更改会导致构建过时。通过这种方式，也可以添加用户提供的代码作为输入，例如通过使用注释属性。请注意，应通过操作上的注释属性或通过在任务中手动注册这些操作来跟踪对此类操作的任何输入。`@[Action](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/Action.html)``@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)`

使用嵌套输入可以为任务提供更丰富的建模和可扩展性，例如[Test.getJvmArgumentProviders（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:jvmArgumentProviders)所示。

这使我们可以对JaCoCo Java代理进行建模，从而声明必要的JVM参数并将输入和输出提供给Gradle：

JacocoAgent.java

    
    
    class JacocoAgent implements CommandLineArgumentProvider {
        private final JacocoTaskExtension jacoco;
    
        public JacocoAgent(JacocoTaskExtension jacoco) {
            this.jacoco = jacoco;
        }
    
        @Nested
        @Optional
        public JacocoTaskExtension getJacoco() {
            return jacoco.isEnabled() ? jacoco : null;
        }
    
        @Override
        public Iterable<String> asArguments() {
            return jacoco.isEnabled() ? ImmutableList.of(jacoco.getAsJvmArg()) : Collections.<String>emptyList();
        }
    }
    
    test.getJvmArgumentProviders().add(new JacocoAgent(extension));

为此，`[JacocoTaskExtension](https://docs.gradle.org/6.7.1/dsl/org.gradle.testing.jacoco.plugins.JacocoTaskExtension.html)`需要具有正确的输入和输出注释。

该方法适用于Test
JVM参数，因为`[Test.getJvmArgumentProviders()](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:jvmArgumentProviders)`带有`Iterable`注释。`@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)`

还有其他类型的嵌套输入可用的任务类型：

  * [JavaExec.getArgumentProviders（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.JavaExec.html#org.gradle.api.tasks.JavaExec:argumentProviders) -模型，例如自定义工具

  * [JavaExec.getJvmArgumentProviders（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.JavaExec.html#org.gradle.api.tasks.JavaExec:jvmArgumentProviders) -用于Jacoco Java代理

  * [CompileOptions.getCompilerArgumentProviders（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:compilerArgumentProviders) -模型，例如注释处理器

  * [Exec.getArgumentProviders（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.Exec.html#org.gradle.api.tasks.Exec:argumentProviders) -模型，例如自定义工具

同样，这种建模可用于自定义任务。

##### [运行时验证](#运行时验证)

执行构建时，Gradle检查任务类型是否用适当的注释声明。它尝试识别问题，例如在不兼容的类型或设置器等上使用注释。未标记有输入/输出注释的任何吸气剂也会被标记。然后，在执行任务时，这些问题就会变成弃用警告。

带有未声明输入和输出的任务的示例输出

    
    
    > gradle processTemplatesRuntime
    > Task :processTemplatesRuntime
    Property 'outputDir' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
    Property 'sourceFiles' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
    Property 'templateData' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
    Property 'templateEngine' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
    
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed

#### [运行时API](#运行时API)

自定义任务类是将您自己的构建逻辑带入增量构建领域的一种简便方法，但是您并不总是拥有这种选择。因此，Gradle还提供了可用于任何任务的替代API，我们接下来将介绍。

如果您无权访问自定义任务类的源，则无法添加上一节中介绍的任何注释。幸运的是，Gradle为此类场景提供了运行时API。它也可以用于临时任务，正如您将在下面看到的那样。

##### [将其用于临时任务](#将其用于临时任务)

此运行时API是通过每个Gradle任务上可用的几个恰当命名的属性提供的：

  * [TaskInputs](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:inputs)类型的[Task.getInputs ](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskInputs.html)[（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:inputs)[](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskInputs.html)

  * [TaskOutputs](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:outputs)类型的[Task.getOutputs ](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskOutputs.html)[（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:outputs)[](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskOutputs.html)

  * [TaskDestroyables](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:destroyables)类型的[Task.getDestroyables ](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskDestroyables.html)[（）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:destroyables)[](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskDestroyables.html)

这些对象具有允许您指定构成任务输入和输出的文件，目录和值的方法。实际上，运行时API与注释几乎具有同等功能。它所缺少的只是的等价物。`@[Nested](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Nested.html)`

让我们以前面的模板处理示例为例，看看它使用运行时API的即席任务的外观：

例子28.临时任务

`Groovy``Kotlin`

build.gradle

    
    
    task processTemplatesAdHoc {
        inputs.property("engine", TemplateEngineType.FREEMARKER)
        inputs.files(fileTree("src/templates"))
            .withPropertyName("sourceFiles")
            .withPathSensitivity(PathSensitivity.RELATIVE)
        inputs.property("templateData.name", "docs")
        inputs.property("templateData.variables", [year: 2013])
        outputs.dir("$buildDir/genOutput2")
            .withPropertyName("outputDir")
    
        doLast {
            // Process the templates here
        }
    }

build.gradle.kts

    
    
    tasks.register("processTemplatesAdHoc") {
        inputs.property("engine", TemplateEngineType.FREEMARKER)
        inputs.files(fileTree("src/templates"))
            .withPropertyName("sourceFiles")
            .withPathSensitivity(PathSensitivity.RELATIVE)
        inputs.property("templateData.name", "docs")
        inputs.property("templateData.variables", mapOf("year" to "2013"))
        outputs.dir("$buildDir/genOutput2")
            .withPropertyName("outputDir")
    
        doLast {
            // Process the templates here
        }
    }

输出 **`gradle processTemplatesAdHoc`**

    
    
    > gradle processTemplatesAdHoc
    > Task :processTemplatesAdHoc
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed
和以前一样，有很多要讨论的。首先，您应该为此真正编写一个自定义任务类，因为它是一个具有多个配置选项的非平凡实现。在这种情况下，没有任务属性可以存储根源文件夹，输出目录的位置或任何其他设置。故意强调这一事实，即运行时API不需要任务具有任何状态。在增量构建方面，上述临时任务的行为与自定义任务类相同。

所有输入和输出的定义是通过在方法完成`inputs`和`outputs`，如`property()`，`files()`和`dir()`。Gradle对参数值执行最新检查，以确定任务是否需要再次运行。每种方法都对应一个增量构建批注，例如`inputs.property()`映射到`@Input`和`outputs.dir()`映射到`@OutputDirectory`。

任务删除的文件可以通过指定`destroyables.register()`。

例子29.宣告可销毁的临时任务

`Groovy``Kotlin`

build.gradle

    
    
    task removeTempDir {
        destroyables.register("$projectDir/tmpDir")
        doLast {
            delete("$projectDir/tmpDir")
        }
    }

build.gradle.kts

    
    
    tasks.register("removeTempDir") {
        destroyables.register("$projectDir/tmpDir")
        doLast {
            delete("$projectDir/tmpDir")
        }
    }

运行时API与注释之间的显着区别是缺少一种直接对应于的方法`@Nested`。这就是为什么该示例`property()`对模板数据使用两个声明，对每个`TemplateData`属性使用一个声明的原因。将运行时API与嵌套值一起使用时，应使用相同的技术。任何给定任务都可以声明可销毁物品或输入/输出，但不能同时声明两者。

##### [细粒度配置](#细粒度配置)

运行时API方法仅允许您自己声明输入和输出。但是，面向文件的工具会返回一个生成器，类型为[TaskInputFilePropertyBuilder](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskInputFilePropertyBuilder.html)，它使您可以提供有关这些输入和输出的其他信息。

您可以在其API文档中了解该构建器提供的所有选项，但在这里我们将向您展示一个简单的示例，让您大致了解可以做什么。

假设`processTemplates`如果没有源文件，我们就不想运行任务，无论它是否是干净的构建。毕竟，如果没有源文件，则无需执行任何任务。构建器允许我们这样配置：

例子30.通过运行时API使用skipWhenEmpty（）

`Groovy``Kotlin`

build.gradle

    
    
    task processTemplatesAdHocSkipWhenEmpty {
        // ...
    
        inputs.files(fileTree("src/templates") {
                include "**/*.fm"
            })
            .skipWhenEmpty()
            .withPropertyName("sourceFiles")
            .withPathSensitivity(PathSensitivity.RELATIVE)
    
        // ...
    }

build.gradle.kts

    
    
    tasks.register("processTemplatesAdHocSkipWhenEmpty") {
        // ...
    
        inputs.files(fileTree("src/templates") {
                include("**/*.fm")
            })
            .skipWhenEmpty()
            .withPropertyName("sourceFiles")
            .withPathSensitivity(PathSensitivity.RELATIVE)
    
        // ...
    }

输出 **`gradle clean processTemplatesAdHocSkipWhenEmpty`**

    
    
    > gradle clean processTemplatesAdHocSkipWhenEmpty
    > Task :processTemplatesAdHocSkipWhenEmpty NO-SOURCE
    
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 up-to-date

该`TaskInputs.files()`方法返回具有方法的构建器`skipWhenEmpty()`。调用此方法等效于使用注释属性[`@SkipWhenEmpty`](#skip-
when-empty)。

现在您已经看到了注释和运行时API，您可能想知道应该使用哪个API。我们的建议是尽可能使用注释，有时值得创建自定义任务类，以便您可以使用它们。运行时API更适用于无法使用注释的情况。

##### [将其用于自定义任务类型](#将其用于自定义任务类型)

另一类型的示例涉及为自定义任务类的实例注册其他输入和输出。例如，假设`ProcessTemplates`任务也需要读取`src/headers/headers.txt`（例如，因为它是从其中一个来源中包含的）。您希望Gradle知道此输入文件，以便只要此文件的内容更改，它就可以重新执行任务。使用运行时API，您可以做到这一点：

例子31.使用运行时API和自定义任务类型

`Groovy``Kotlin`

build.gradle

    
    
    task processTemplatesWithExtraInputs(type: ProcessTemplates) {
        // ...
    
        inputs.file("src/headers/headers.txt")
            .withPropertyName("headers")
            .withPathSensitivity(PathSensitivity.NONE)
    }

build.gradle.kts

    
    
    tasks.register<ProcessTemplates>("processTemplatesWithExtraInputs") {
        // ...
    
        inputs.file("src/headers/headers.txt")
            .withPropertyName("headers")
            .withPathSensitivity(PathSensitivity.NONE)
    }

像这样使用运行时API有点像使用`doLast()`和`doFirst()`将额外的操作附加到任务，除了在这种情况下，我们将附加有关输入和输出的信息。

╔═════════════════════════════

如果任务类型已经在使用增量构建批注，则使用相同的属性名称注册输入或输出将导致错误。  
  
╚═════════════════════════════  
  
#### [重要的有益副作用](#重要的有益副作用)

一旦声明了任务的正式输入和输出，Gradle便可以推断出那些属性。例如，如果将一个任务的输入设置为另一个任务的输出，则意味着第一个任务取决于第二个任务，对吗？Gradle知道这一点并可以采取行动。

接下来，我们将介绍此功能，以及Gradle了解输入和输出知识的其他一些功能。

##### [推断的任务依赖性](#推断的任务依赖性)

考虑一个打包任务输出的存档`processTemplates`任务。构建作者将看到，存档任务显然需要`processTemplates`首先运行，因此可以添加显式的`dependsOn`。但是，如果您这样定义归档任务：

例子32.通过任务输出推断任务依赖

`Groovy``Kotlin`

build.gradle

    
    
    task packageFiles(type: Zip) {
        from processTemplates.outputs
    }

build.gradle.kts

    
    
    tasks.register<Zip>("packageFiles") {
        from(processTemplates.get().outputs)
    }

输出 **`gradle clean packageFiles`**

    
    > gradle clean packageFiles
    > Task :processTemplates
    > Task :packageFiles
    
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 2 executed, 1 up-to-date

Gradle将自动使`packageFiles`依赖`processTemplates`。之所以可以这样做，是因为它知道packageFiles的输入之一需要processTemplates任务的输出。我们称其为推断的任务依赖性。

上面的例子也可以写成

例子33.通过任务参数推断任务依赖

`Groovy``Kotlin`

build.gradle

    
    
    task packageFiles2(type: Zip) {
        from processTemplates
    }

build.gradle.kts

    
    
    tasks.register<Zip>("packageFiles2") {
        from(processTemplates)
    }

输出 **`gradle clean packageFiles2`**

    
    

    Output of gradle clean packageFiles2
    
    > gradle clean packageFiles2
    > Task :processTemplates
    > Task :packageFiles2
    
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 2 executed, 1 up-to-date



这是因为该`from()`方法可以接受任务对象作为参数。在幕后，`from()`使用该`project.files()`方法包装参数，从而将任务的正式输出公开为文件集合。换句话说，这是特例！

##### [输入和输出验证](#输入和输出验证)

增量构建批注为Gradle提供足够的信息，以对批注的属性执行一些基本验证。特别是，在任务执行之前，它将对每个属性执行以下操作：

  * `@InputFile` -验证该属性具有值，并且该路径对应于存在的文件（而非目录）。

  * `@InputDirectory`-与for相同`@InputFile`，除了路径必须对应于目录。

  * `@OutputDirectory` -验证路径与文件不匹配，并在目录不存在的情况下创建目录。

这种验证提高了构建的健壮性，使您可以快速识别与输入和输出有关的问题。

您有时会希望禁用某些验证，特别是在输入文件可能确实不存在的情况下。这就是Gradle提供`@Optional`注释的原因：您使用它来告诉Gradle特定输入是可选的，因此，如果对应的文件或目录不存在，构建也不会失败。

##### [持续建造](#持续建造)

定义任务输入和输出的另一个好处是连续构建。由于Gradle知道任务所依赖的文件，因此如果其任何输入发生更改，它可以自动再次运行任务。通过在运行Gradle时激活连续构建（通过`--continuous`或`-t`选项），可以将Gradle置于一种状态，在该状态下Gradle不断检查更改并在遇到此类更改时执行所请求的任务。

您可以在[Continuous
build中](/md/命令行界面_md#持续构建)找到有关此功能的更多信息。

##### [任务并行](#任务并行)

定义任务输入和输出的最后一个好处是，当使用“
--parallel”选项时，Gradle可以使用此信息来决定如何运行任务。例如，Gradle在选择要运行的下一个任务时将检查任务的输出，并且将避免并发执行写入同一输出目录的任务。同样，Gradle将使用有关任务销毁哪些文件的信息（例如，由`Destroys`注释），并避免在运行另一个消耗或创建相同文件的任务时运行删除一组文件的任务（反之亦然）。它还可以确定创建一组文件的任务已经运行，并且消耗这些文件的任务尚未运行，并且将避免运行将两者之间的文件删除的任务。通过以这种方式提供任务输入和输出信息，Gradle可以推断任务之间的创建/消耗/销毁关系，并可以确保任务执行不违反那些关系。

### [它是如何工作的？](#它是如何工作的？)

在第一次执行任务之前，Gradle会对输入进行指纹识别。此指纹包含输入文件的路径以及每个文件内容的哈希值。然后Gradle执行任务。如果任务成功完成，Gradle将对输出进行指纹识别。此指纹包含一组输出文件以及每个文件内容的哈希值。Gradle会在下一次执行任务时保留两个指纹。

每次之后，在执行任务之前，Gradle都会对输入和输出采用新的指纹。如果新的指纹与以前的指纹相同，则Gradle会假定输出是最新的，并跳过该任务。如果它们不相同，则Gradle执行任务。Gradle会在下一次执行任务时保留两个指纹。

如果文件的统计信息（即`lastModified`和`size`）未更改，则Gradle将重复使用上次运行时的文件指纹。这意味着当文件的统计信息未更改时，Gradle不会检测到更改。

Gradle还将任务 _代码_ 视为任务输入的一部分。当任务，其动作或其依赖关系在两次执行之间发生变化时，Gradle会将任务视为过时的。

Gradle了解文件属性（例如，持有Java类路径的文件属性）是否对顺序敏感。比较此类属性的指纹时，即使文件顺序发生更改，也将导致任务过时。

请注意，如果任务指定了输出目录，则自上次执行该任务以来添加到该目录的所有文件都将被忽略，并且不会导致该任务过时。这样一来，不相关的任务可以共享一个输出目录，而不会互相干扰。如果由于某种原因这不是您想要的行为，请考虑使用[TaskOutputs.upToDateWhen（groovy.lang.Closure）](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-
groovy.lang.Closure-)

另请注意，将通过最新检查来检测和处理更改不可用文件的可用性（例如，将断开的符号链接的目标修改为有效文件，反之亦然）。

任务的输入还用于计算[构建缓存](/md/构建缓存.md#build_cache)键，该键在启用后将加载任务输出。有关更多详细信息，请参见[任务输出缓存](/md/构建缓存_md#任务输出缓存)。

╔═════════════════════════════

为了跟踪任务，任务动作和嵌套输入的实现，Gradle使用类名称和包含实现的类路径标识符。在某些情况下，Gradle无法准确跟踪实现：

未知的类加载器

    

当Gradle尚未创建加载实现的类加载器时，无法确定类路径。

Java Lambda

    

Java lambda类是在运行时使用不确定的类名创建的。因此，类名称不能标识lambda的实现，并且不能在不同的Gradle运行之间进行更改。

当无法精确跟踪任务，任务动作或嵌套输入的实现时，Gradle将禁用该任务的任何缓存。这意味着该任务永远不会是最新的，也不会从[构建缓存中](/md/构建缓存_md#任务输出缓存)加载。  
  
╚═════════════════════════════  
  
### [先进技术](#先进技术)

到目前为止，您在本节中看到的所有内容都将涵盖您将遇到的大多数用例，但是有些情况需要特殊对待。接下来，我们将介绍其中一些解决方案。

#### [添加自己的缓存的输入/输出方法](#添加自己的缓存的输入/输出方法)

您是否想知道任务`from()`方法如何`Copy`工作？它没有注释，`@InputFiles`但是传递给它的任何文件都被视为任务的正式输入。发生了什么？

实现非常简单，您可以针对自己的任务使用相同的技术来改进其API。编写您的方法，以便它们将文件直接添加到适当的带注释的属性。例如，以下是向前面介绍`sources()`的自定义`ProcessTemplates`类添加方法的方法：

例子34.声明一种添加任务输入的方法

`Groovy``Kotlin`

build.gradle

    
    
    task processTemplates(type: ProcessTemplates) {
        templateEngine = TemplateEngineType.FREEMARKER
        templateData = new TemplateData("test", [year: 2012])
        outputDir = file("$buildDir/genOutput")
    
        sources fileTree("src/templates")
    }

build.gradle.kts

    
    
    tasks.register<ProcessTemplates>("processTemplates") {
        templateEngine = TemplateEngineType.FREEMARKER
        templateData = TemplateData("test", mapOf("year" to "2012"))
        outputDir = file("$buildDir/genOutput")
    
        sources(fileTree("src/templates"))
    }

ProcessTemplates.java

    
    
    public class ProcessTemplates extends DefaultTask {
        // ...
        private FileCollection sourceFiles = getProject().getLayout().files();
    
        @SkipWhenEmpty
        @InputFiles
        @PathSensitive(PathSensitivity.NONE)
        public FileCollection getSourceFiles() {
            return this.sourceFiles;
        }
    
        public void sources(FileCollection sourceFiles) {
            this.sourceFiles = this.sourceFiles.plus(sourceFiles);
        }
    
        // ...
    }

输出 `gradle processTemplates`

    
    

    Output of gradle processTemplates
    
    > gradle processTemplates
    > Task :processTemplates
    
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 executed



换句话说，只要您在配置阶段将值和文件添加到正式任务输入和输出中，无论您在构建中的何处添加它们，它们都将被视为此类。

如果我们也想支持任务作为参数，并将其输出作为输入，则可以使用如下`project.layout.files()`方法：

例子35.声明一个添加任务作为输入的方法

`Groovy``Kotlin`

build.gradle

    
    
    task copyTemplates(type: Copy) {
        into "$buildDir/tmp"
        from "src/templates"
    }
    
    task processTemplates2(type: ProcessTemplates) {
        // ...
        sources copyTemplates
    }

build.gradle.kts

    
    
    val copyTemplates by tasks.registering(Copy::class) {
        into("$buildDir/tmp")
        from("src/templates")
    }
    
    tasks.register<ProcessTemplates>("processTemplates2") {
        // ...
        sources(copyTemplates.get())
    }

ProcessTemplates.java

    
    
        // ...
        public void sources(Task inputTask) {
            this.sourceFiles = this.sourceFiles.plus(getProject().getLayout().files(inputTask));
        }
        // ...

输出 `gradle processTemplates2`

    
    
    > gradle processTemplates2
    > Task :copyTemplates
    > Task :processTemplates2
    
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 2 executed
此技术可以使您的自定义任务更易于使用，并生成更干净的构建文件。另外一个好处是，使用`getProject().getLayout().files()`意味着我们的自定义方法可以设置推断的任务依赖性。

最后要注意的一点是：如果要开发一个将源文件集合作为输入的任务，如本例所示，请考虑使用内置的[SourceTask](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.tasks.SourceTask.html)。这将使您不必实施我们放入的某些管道`ProcessTemplates`。

#### [链接`@OutputDirectory`到`@InputFiles`](#链接`@OutputDirectory`到`@InputFiles`)

当您要将一个任务的输出链接到另一任务的输入时，类型通常匹配，并且简单的属性分配将提供该链接。例如，`File`可以将输出属性分配给`File`输入。

不幸的是，当您希望某个任务`@OutputDirectory`（类型为`File`）中的文件成为另一个任务的`@InputFiles`属性（类型为`FileCollection`）的源时，这种方法会失效。由于这两种类型不同，因此属性分配将不起作用。

例如，假设您想通过`destinationDir`属性将Java编译任务的输出用作定制任务的输入，该定制任务检测一组包含Java字节码的文件。此自定义任务（我们将其称为`Instrument`）具有一个用`classFiles`注释的属性`@InputFiles`。您最初可能会尝试像这样配置任务：

例子36.尝试建立推断的任务依赖项失败

`Groovy``Kotlin`

build.gradle

    
    
    plugins {
        id 'java'
    }
    
    task badInstrumentClasses(type: Instrument) {
        classFiles = fileTree(compileJava.destinationDir)
        destinationDir = file("$buildDir/instrumented")
    }

build.gradle.kts

    
    
    plugins {
        java
    }
    
    tasks.register<Instrument>("badInstrumentClasses") {
        classFiles = fileTree(tasks.compileJava.get().destinationDir)
        destinationDir = file("$buildDir/instrumented")
    }

输出 **`gradle clean badInstrumentClasses`**

    
    
    > gradle clean badInstrumentClasses
    > Task :clean UP-TO-DATE
    > Task :badInstrumentClasses NO-SOURCE
    
    
    BUILD SUCCESSFUL in 0s
    1 actionable task: 1 up-to-date

这段代码显然没有错，但是您可以从控制台输出中看到缺少编译任务。在这种情况下，你需要添加之间的明确任务相关性`instrumentClasses`和`compileJava`通过`dependsOn`。使用`fileTree()`手段意味着Gradle无法推断任务依赖项本身。

一种解决方案是使用该`TaskOutputs.files`属性，如以下示例所示：

例子37.在输出目录和输入文件之间建立一个推断的任务依赖关系

`Groovy``Kotlin`

build.gradle

    
    
    task instrumentClasses(type: Instrument) {
        classFiles = compileJava.outputs.files
        destinationDir = file("$buildDir/instrumented")
    }

build.gradle.kts

    
    
    tasks.register<Instrument>("instrumentClasses") {
        classFiles = tasks.compileJava.get().outputs.files
        destinationDir = file("$buildDir/instrumented")
    }

输出 **`gradle clean instrumentClasses`**

    
    
    > gradle clean instrumentClasses
    > Task :clean UP-TO-DATE
    > Task :compileJava
    > Task :instrumentClasses
    
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 2 executed, 1 up-to-date

或者，你可以通过Gradle使用的一个来访问相应的属性本身`project.files()`，`project.layout.files()`或`project.objects.fileCollection()`代替`project.fileTree()`：

例子38.使用以下命令建立一个推断的任务依赖关系 `layout.files()`

`Groovy``Kotlin`

build.gradle

    
    
    task instrumentClasses2(type: Instrument) {
        classFiles = layout.files(compileJava)
        destinationDir = file("$buildDir/instrumented")
    }

build.gradle.kts

    
    
    tasks.register<Instrument>("instrumentClasses2") {
        classFiles = layout.files(tasks.compileJava.get())
        destinationDir = file("$buildDir/instrumented")
    }

输出 **`gradle clean instrumentClasses2`**

    
    
    > gradle clean instrumentClasses2
    > Task :clean UP-TO-DATE
    > Task :compileJava
    > Task :instrumentClasses2
    
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 2 executed, 1 up-to-date

请记住`files()`，`layout.files()`并且`objects.fileCollection()`可以将任务作为参数，而`fileTree()`不能。

这种方法的缺点是，源任务的所有文件输出都将成为目标的输入文件-`instrumentClasses`在这种情况下。只要源任务（例如任务）只有一个基于文件的输出，就可以了`JavaCompile`。但是，如果您必须仅链接多个输出属性中的一个，则需要使用以下`builtBy`方法明确告诉Gradle哪个任务生成输入文件：

例子39.用builtBy（）设置一个推断的任务依赖项

`Groovy``Kotlin`

build.gradle

    
    
    task instrumentClassesBuiltBy(type: Instrument) {
        classFiles = fileTree(compileJava.destinationDir) {
            builtBy compileJava
        }
        destinationDir = file("$buildDir/instrumented")
    }

build.gradle.kts

    
    
    tasks.register<Instrument>("instrumentClassesBuiltBy") {
        classFiles = fileTree(tasks.compileJava.get().destinationDir) {
            builtBy(tasks.compileJava.get())
        }
        destinationDir = file("$buildDir/instrumented")
    }

输出 **`gradle clean instrumentClassesBuiltBy`**

    
    
    > gradle clean instrumentClassesBuiltBy
    > Task :clean UP-TO-DATE
    > Task :compileJava
    > Task :instrumentClassesBuiltBy
    
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 2 executed, 1 up-to-date

当然，您可以通过添加一个明确的任务依赖关系`dependsOn`，但是以上方法提供了更多的语义含义，解释了为什么`compileJava`必须事先运行。

#### [提供自定义的最新逻辑](#提供自定义的最新逻辑)

Gradle自动处理输出文件和目录的最新检查，但是如果任务输出完全是其他东西怎么办？也许这是对Web服务或数据库表的更新。在这种情况下，Gradle无法知道如何检查任务是否最新。

这就是`upToDateWhen()`方法的`TaskOutputs`用武之地。它带有一个谓词函数，该函数用于确定任务是否最新。一种用例是完全禁用一项任务的最新检查，如下所示：

例子40.忽略最新的检查

`Groovy``Kotlin`

build.gradle

    
    
    task alwaysInstrumentClasses(type: Instrument) {
        classFiles = layout.files(compileJava)
        destinationDir = file("$buildDir/instrumented")
        outputs.upToDateWhen { false }
    }

build.gradle.kts

    
    
    tasks.register<Instrument>("alwaysInstrumentClasses") {
        classFiles = layout.files(tasks.compileJava.get())
        destinationDir = file("$buildDir/instrumented")
        outputs.upToDateWhen { false }
    }

输出 `gradle clean alwaysInstrumentClasses`

    
    
    > gradle clean alwaysInstrumentClasses
    > Task :compileJava
    > Task :alwaysInstrumentClasses
    
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 2 executed, 1 up-to-date

输出 `gradle alwaysInstrumentClasses`

    
    
    > gradle alwaysInstrumentClasses
    > Task :compileJava UP-TO-DATE
    > Task :alwaysInstrumentClasses
    
    
    BUILD SUCCESSFUL in 0s
    2 actionable tasks: 1 executed, 1 up-to-date

所述`{ false }`封闭件可确保`alwaysInstrumentClasses`将总是被执行，而不论是否存在于输入或输出没有变化。

您当然可以在闭包中添加更复杂的逻辑。例如，您可以检查数据库表中的特定记录是否存在或已更改。请注意，最新的检查应该可以 _节省_
您的时间。不要添加比标准执行任务花费更多或更多时间的支票。实际上，如果某个任务由于很少更新而最终经常运行，则根本不值得进行最新检查。请记住，如果任务在执行任务图中，则检查将始终运行。

一个常见的错误是使用`upToDateWhen()`而不是`Task.onlyIf()`。如果要基于与任务输入和输出无关的某些条件跳过任务，则应使用`onlyIf()`。例如，在要设置或不设置特定属性的情况下要跳过任务的情况。

#### [配置输入标准化](#配置输入标准化)

对于最新检查和[构建缓存，](/md/构建缓存.md#build_cache)
Gradle需要确定两个任务输入属性是否具有相同的值。为了做到这一点，Gradle首先将两个输入标准化，然后比较结果。例如，对于编译类路径，Gradle从类路径上的类中提取ABI签名，然后按照[Java编译规避中的](https://docs.gradle.org/6.7.1/userguide/java_plugin.html#sec:java_compile_avoidance)描述比较上一次Gradle运行和当前Gradle运行之间的签名。

规范化适用于类路径上的所有zip文件（例如jar，wars，ars，apk等）。这使Gradle能够识别两个zip文件在功能上何时相同，即使zip文件本身由于元数据（例如时间戳或文件顺序）而可能略有不同。标准化不仅适用于直接在类路径上的zip文件，而且还适用于嵌套在目录中或类路径上其他zip文件内的zip文件。

可以自定义Gradle的内置策略以用于运行时类路径规范化。所有带有注解的输入均被视为运行时类路径。`@[Classpath](https://docs.gradle.org/6.7.1/javadoc/org/gradle/api/tasks/Classpath.html)`

假设您要向`build-
info.properties`所有生成的jar文件中添加一个文件，其中包含有关构建的信息，例如，构建开始时的时间戳或一些ID，以标识发布该工件的CI作业。该文件仅用于审计目的，对运行测试的结果没有影响。但是，此文件是`test`任务的运行时类路径的一部分，并且在每次构建调用时都会更改。因此，`test`它将永远不会是最新的，也不会从构建缓存中提取。为了再次从增量构建中受益，您可以通过使用[Project.normalization（org.gradle.api.Action）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:normalization\(org.gradle.api.Action\))（在
_使用_ 项目中）在项目级别告诉Gradle在运行时类路径上忽略此文件：

例子41.运行时类路径规范化

`Groovy``Kotlin`

build.gradle

    
    
    normalization {
        runtimeClasspath {
            ignore 'build-info.properties'
        }
    }

build.gradle.kts

    
    
    normalization {
        runtimeClasspath {
            ignore("build-info.properties")
        }
    }

如果要对jar文件中的所有项目执行此文件添加操作，并且要为所有使用者过滤此文件，则应考虑在[约定插件中](/md/在子项目之间共享构建逻辑_md#约定插件)配置此类规范化以便在子项目之间共享。

这种配置的效果是，`build-
info.properties`对于最新检查和[构建缓存](/md/构建缓存.md#build_cache)键计算，对的更改将被忽略。请注意，这不会改变`test`任务的运行时行为，即，任何测试仍然可以加载`build-
info.properties`，并且运行时类路径仍与以前相同。

##### [Java`META-INF`规范化](#Java`META-INF`规范化)

对于`META-INF`jar档案目录中的文件，由于其对运行时间的影响，并非总是能够完全忽略文件。

对清单和属性文件`META-INF`进行了标准化，以忽略注释，空格和顺序差异。清单属性名称不区分大小写进行比较。属性文件密钥不区分顺序。

例子42.忽略`META-INF`清单属性

`Groovy``Kotlin`

build.gradle

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreAttribute("Implementation-Version")
            }
        }
    }

build.gradle.kts

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreAttribute("Implementation-Version")
            }
        }
    }

例子43.忽略`META-INF`属性键

`Groovy``Kotlin`

build.gradle

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreProperty("app.version")
            }
        }
    }

build.gradle.kts

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreProperty("app.version")
            }
        }
    }
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreManifest()
            }
        }
    }
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreCompletely()
            }
        }
    }

例子44.忽略 `META-INF/MANIFEST.MF`

`Groovy``Kotlin`

build.gradle

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreManifest()
            }
        }
    }

build.gradle.kts

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreManifest()
            }
        }
    }
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreCompletely()
            }
        }
    }

例子45.忽略里面的所有文件和目录 `META-INF`

`Groovy``Kotlin`

build.gradle

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreCompletely()
            }
        }
    }

build.gradle.kts

    
    
    normalization {
        runtimeClasspath {
            metaInf {
                ignoreCompletely()
            }
        }
    }

### [旧任务输出](#旧任务输出)

当Gradle版本更改时，Gradle检测到需要删除使用旧版本Gradle运行的任务的输出，以确保任务的最新版本从已知的干净状态开始。

╔═════════════════════════════

仅针对源集的输出（Java / Groovy / Scala编译）实现了对陈旧的输出目录的自动清除。  
  
╚═════════════════════════════  
  
## [任务规则](#任务规则)

有时您想执行一个任务，该任务的行为取决于较大或无限数量的参数值范围。提供此类任务的一种非常好的表达方式是任务规则：

例子46.任务规则

`Groovy``Kotlin`

build.gradle

    
    
    tasks.addRule("Pattern: ping<ID>") { String taskName ->
        if (taskName.startsWith("ping")) {
            task(taskName) {
                doLast {
                    println "Pinging: " + (taskName - 'ping')
                }
            }
        }
    }

build.gradle.kts

    
    
    tasks.addRule("Pattern: ping<ID>") {
        val taskName = this
        if (startsWith("ping")) {
            task(taskName) {
                doLast {
                    println("Pinging: " + (taskName.replace("ping", "")))
                }
            }
        }
    }

输出 **`gradle -q pingServer1`**

    
    
    > gradle -q pingServer1
    Ping：Server1

String参数用作规则的描述，用表示`gradle tasks`。

规则不仅在从命令行调用任务时使用。您还可以在基于规则的任务上创建dependsOn关系：

例子47.对基于规则的任务的依赖

`Groovy``Kotlin`

build.gradle

    
    
    tasks.addRule("Pattern: ping<ID>") { String taskName ->
        if (taskName.startsWith("ping")) {
            task(taskName) {
                doLast {
                    println "Pinging: " + (taskName - 'ping')
                }
            }
        }
    }
    
    task groupPing {
        dependsOn pingServer1, pingServer2
    }

build.gradle.kts

    
    
    tasks.addRule("Pattern: ping<ID>") {
        val taskName = this
        if (startsWith("ping")) {
            task(taskName) {
                doLast {
                    println("Pinging: " + (taskName.replace("ping", "")))
                }
            }
        }
    }
    
    task("groupPing") {
        dependsOn("pingServer1", "pingServer2")
    }

输出 **`gradle -q groupPing`**

    
    
    > gradle -q groupPing
    Ping：Server1
    Ping：Server2

如果运行“ `gradle -q tasks`”，将找不到名为“ `pingServer1`”或“
`pingServer2`”的任务，但是此脚本正在根据运行这些任务的请求执行逻辑。

## [终结器任务](#终结器任务)

计划运行终结任务时，终结任务会自动添加到任务图中。

例子48.添加一个任务终结器

`Groovy``Kotlin`

build.gradle

    
    
    task taskX {
        doLast {
            println 'taskX'
        }
    }
    task taskY {
        doLast {
            println 'taskY'
        }
    }
    
    taskX.finalizedBy taskY

build.gradle.kts

    
    
    val taskX by tasks.registering {
        doLast {
            println("taskX")
        }
    }
    val taskY by tasks.registering {
        doLast {
            println("taskY")
        }
    }
    
    taskX { finalizedBy(taskY) }

输出 **`gradle -q taskX`**

    
    
    > gradle -q taskX
    TaskX
    TaskY

即使完成任务失败，也将执行终结器任务。

例子49.失败任务的任务终结器

`Groovy``Kotlin`

build.gradle

    
    
    task taskX {
        doLast {
            println 'taskX'
            throw new RuntimeException()
        }
    }
    task taskY {
        doLast {
            println 'taskY'
        }
    }
    
    taskX.finalizedBy taskY

build.gradle.kts

    
    
    val taskX by tasks.registering {
        doLast {
            println("taskX")
            throw RuntimeException()
        }
    }
    val taskY by tasks.registering {
        doLast {
            println("taskY")
        }
    }
    
    taskX { finalizedBy(taskY) }

输出 **`gradle -q taskX`**

    
    
    > gradle -q taskX
    taskX
    taskY
    
    FAILURE: Build failed with an exception.
    
    * Where:
    Build file '/home/user/gradle/samples/build.gradle' line: 4
    
    * What went wrong:
    Execution failed for task ':taskX'.
    > java.lang.RuntimeException (no error message)
    
    * Try:
    Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
    
    * Get more help at https://help.gradle.org
    
    BUILD FAILED in 0s

另一方面，如果已完成任务没有执行任何工作（例如，如果认为已完成任务或从属任务失败），则不会执行完成任务。

在构建创建无论构建失败还是成功都必须清除的资源的情况下，终结器任务很有用。这种资源的一个示例是一个Web容器，它在集成测试任务之前启动，并且即使某些测试失败，也应始终将其关闭。

要指定终结器任务，请使用[Task.finalizedBy（java.lang.Object
...）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy\(java.lang.Object\[\]\))方法。此方法接受Task实例，任务名称或[Task.dependsOn（java.lang.Object…）](https://docs.gradle.org/6.7.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn\(java.lang.Object\[\]\))接受的任何其他输入。

## [生命周期任务](#生命周期任务)

生命周期任务是无法自行工作的任务。他们通常没有任何任务动作。生命周期任务可以代表几个概念：

  * 工作流程步骤（例如，使用运行所有检查`check`）

  * 可构建的事物（例如，使用来为本机组件创建调试的32位可执行文件`debug32MainExecutable`）

  * 一个方便的任务，可以执行许多相同的逻辑任务（例如，使用运行所有编译任务`compileAll`）

底座插件定义了几个[标准的生命周期的任务](https://docs.gradle.org/6.7.1/userguide/base_plugin.html#sec:base_tasks)，如`build`，`assemble`和`check`。所有核心语言插件（例如[Java插件](https://docs.gradle.org/6.7.1/userguide/java_plugin.html#java_plugin)）均应用基本插件，因此具有相同的基本生命周期任务集。

除非生命周期任务具有操作，否则其[结果](#任务成果)取决于其任务依赖性。如果执行了这些依赖项中的任何一个，则将考虑生命周期任务`EXECUTED`。如果所有任务相关性都是最新的，已跳过或已从缓存中删除，则将考虑生命周期任务`UP-
TO-DATE`。

## [概要](#概要)

如果您来自Ant，那么增强的Gradle任务（例如 _Copy）_
似乎是Ant目标和Ant任务之间的交叉。尽管Ant的任务和目标实际上是不同的实体，但是Gradle将这些概念组合为一个实体。简单的Gradle任务就像Ant的目标一样，但是增强的Gradle任务也包括Ant任务的各个方面。Gradle的所有任务共享一个公共API，您可以在它们之间创建依赖关系。这些任务比Ant任务容易配置。它们充分利用了类型系统，更具表现力且易于维护。

* * *

[1](#_footnoteref_1)。您可能想知道为什么既没有导入，`StopExecutionException`也没有通过完全限定的名称访问它。原因是，Gradle向脚本中添加了一组默认导入（请参见[默认导入](/md/编写构建脚本.md#script-
default-imports)）。

