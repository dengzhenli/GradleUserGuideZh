

[ Gradle ](https://docs.gradle.org "Gradle Docs")

User Manual

  * Community Open Community Menu

[ Community Home ](https://gradle.org/)

[ Community Forums ](https://discuss.gradle.org/)

[ Community Plugins ](https://plugins.gradle.org)

  * [Training](https://gradle.com/training/)
  * News Open Community Menu

[ Newsletter ](https://newsletter.gradle.com)

[ Blog ](https://blog.gradle.org)

[ Twitter ](https://twitter.com/gradle)

  * [Enterprise](https://gradle.com)
  * [github](https://github.com/gradle/gradle "Gradle on GitHub")

  * [Docs Home](../userguide/userguide.html)
  * [Samples](../samples/index.html)
  * [Release Notes](../release-notes.html)
  * Gradle API
    * [Javadoc](../javadoc/index.html?overview-summary.html)
    * [Groovy DSL Reference](../dsl/index.html)
    * [Groovy DSL Primer](../userguide/groovy_build_script_primer.html)
    * [Kotlin DSL API](https://gradle.github.io/kotlin-dsl-docs/api/)
    * [Kotlin DSL Primer](../userguide/kotlin_dsl.html)

### User Manual

[ PDF ](../userguide/userguide.pdf)

  * [What is Gradle?](../userguide/what_is_gradle.html)
  * [Getting Started](../userguide/getting_started.html)
  * [Installing Gradle](../userguide/installation.html)
  * Upgrading Gradle...
    * [version 6.X to latest](../userguide/upgrading_version_6.html)
    * [version 5.X to 6.0](../userguide/upgrading_version_5.html)
    * [version 4.X to 5.0](../userguide/upgrading_version_4.html)
    * [Gradle's Feature Lifecycle](../userguide/feature_lifecycle.html)
  * Migrating to Gradle...
    * [from Maven](../userguide/migrating_from_maven.html)
    * [from Ant](../userguide/migrating_from_ant.html)
  * [Compatibility Notes](../userguide/compatibility.html)
  * [Troubleshooting Builds](../userguide/troubleshooting.html)

### Running Gradle Builds

  * Customizing Execution
    * [Configuring the Build Environment](../userguide/build_environment.html)
    * [Configuring the Gradle Daemon](../userguide/gradle_daemon.html)
    * [Using Initialization Scripts](../userguide/init_scripts.html)
  * [Executing Multi-Project Builds](../userguide/intro_multi_project_builds.html)
  * [Inspecting Gradle Builds](https://scans.gradle.com/)
  * Optimizing Build Times
    * [Build Performance Guide](https://guides.gradle.org/performance/)
    * [Enabling and Configuring the Build Cache](../userguide/build_cache.html)
    * [Using the Configuration Cache](../userguide/configuration_cache.html)

### Authoring Gradle Builds

  * Learning the Basics
    * [Introducing the Basics of Build Scripts](../userguide/tutorial_using_tasks.html)
    * [Working with Tasks](../userguide/more_about_tasks.html)
    * [Learning More About Build Scripts](../userguide/writing_build_scripts.html)
    * [Working with Files](../userguide/working_with_files.html)
    * [Using Gradle Plugins](../userguide/plugins.html)
    * [Understanding the Build Lifecycle](../userguide/build_lifecycle.html)
    * [Working with Logging](../userguide/logging.html)
    * [Avoiding Traps](../userguide/potential_traps.html)
  * Authoring Multi-Project Builds
    * [Creating a Basic Multi-Project Build](../userguide/multi_project_builds.html)
    * [Declaring Dependencies between Subprojects](../userguide/declaring_dependencies_between_subprojects.html)
    * [Sharing Build Logic between Subprojects](../userguide/sharing_build_logic_between_subprojects.html)
    * [Fine Tuning the Project Layout](../userguide/fine_tuning_project_layout.html)
    * [Understanding Configuration and Execution](../userguide/multi_project_configuration_and_execution.html)
  * Authoring Sustainable Builds
    * [Organizing Build Logic](../userguide/organizing_gradle_projects.html)
    * [Following Best Practices](../userguide/authoring_maintainable_build_scripts.html)
  * Advanced Techniques
    * [Developing Parallel Tasks](https://guides.gradle.org/using-the-worker-api/)
    * [Testing a Build with TestKit](../userguide/test_kit.html)
    * [Using Ant from Gradle](../userguide/ant.html)

### Authoring JVM Builds

  * [Building Java & JVM projects](../userguide/building_java_projects.html)
  * [Testing Java & JVM projects](../userguide/java_testing.html)
  * [Toolchains for Java projects](../userguide/toolchains.html)
  * [Managing Dependencies](../userguide/dependency_management_for_java_projects.html)
  * JVM Plugins
    * [Java Library Plugin](../userguide/java_library_plugin.html)
    * [Java Application Plugin](../userguide/application_plugin.html)
    * [Java Platform Plugin](../userguide/java_platform_plugin.html)
    * [Groovy Plugin](../userguide/groovy_plugin.html)
    * [Scala Plugin](../userguide/scala_plugin.html)

### Authoring C++/Swift Builds

  * [Building C++ projects](../userguide/building_cpp_projects.html)
  * [Testing C++ projects](../userguide/cpp_testing.html)
  * [Building Swift projects](../userguide/building_swift_projects.html)
  * [Testing Swift projects](../userguide/swift_testing.html)

### Working with Dependencies

  * Learning the Basics
    * [What is Dependency Management?](../userguide/core_dependency_management.html)
    * [Declaring Repositories](../userguide/declaring_repositories.html)
    * [Declaring Dependencies](../userguide/declaring_dependencies.html)
    * [Understanding Library and Application Differences](../userguide/library_vs_application.html)
    * [Viewing and Debugging Dependencies](../userguide/viewing_debugging_dependencies.html)
    * [Understanding Resolution](../userguide/dependency_resolution.html)
    * [Verifying dependencies](../userguide/dependency_verification.html)
  * Declaring Versions
    * [Declaring Versions and Ranges](../userguide/single_versions.html)
    * [Declaring Rich Versions](../userguide/rich_versions.html)
    * [Handling Changing Versions](../userguide/dynamic_versions.html)
    * [Locking Versions](../userguide/dependency_locking.html)
  * Controlling Transitives
    * [Upgrading Versions](../userguide/dependency_constraints.html)
    * [Downgrading and Excluding](../userguide/dependency_downgrade_and_exclude.html)
    * [Sharing Versions](../userguide/platforms.html)
    * [Aligning Dependencies](../userguide/dependency_version_alignment.html)
    * [Handling Mutually Exclusive Dependencies](../userguide/dependency_capability_conflict.html)
    * [Fixing Metadata](../userguide/component_metadata_rules.html)
    * [Customizing Resolution](../userguide/resolution_rules.html)
    * [Preventing accidental upgrades](../userguide/resolution_strategy_tuning.html)
  * Producing and Consuming Variants of Libraries
    * [Declaring Capabilities of a Library](../userguide/component_capabilities.html)
    * [Modeling Feature Variants and Optional Dependencies](../userguide/feature_variants.html)
    * [Understanding Variant Selection](../userguide/variant_model.html)
    * [Declaring Variant Attributes](../userguide/variant_attributes.html)
    * [Sharing Outputs of Projects](../userguide/cross_project_publications.html)
    * [Transforming Artifacts](../userguide/artifact_transforms.html)
  * Working in a Multi-repo Environment
    * [Composing Builds](../userguide/composite_builds.html)
  * Publishing Libraries
    * [Setting up Publishing](../userguide/publishing_setup.html)
    * [Understanding Gradle Module Metadata](../userguide/publishing_gradle_module_metadata.html)
    * [Signing Artifacts](../userguide/publishing_signing.html)
    * [Customizing Publishing](../userguide/publishing_customization.html)
    * [Maven Publish Plugin](../userguide/publishing_maven.html)
    * [Ivy Publish Plugin](../userguide/publishing_ivy.html)
  * [Terminology](../userguide/dependency_management_terminology.html)

### Extending Gradle

  * [Plugin Development Tutorials](https://gradle.org/guides/?q=Plugin%20Development)
  * [Writing Gradle Task Types](../userguide/custom_tasks.html)
  * [Writing Gradle Plugins](../userguide/custom_plugins.html)
  * [Writing Custom Gradle Types](../userguide/custom_gradle_types.html)
  * [Configuring Tasks Lazily](../userguide/lazy_configuration.html)
  * [Using Task Configuration Avoidance](../userguide/task_configuration_avoidance.html)

### Reference

  * [Core Plugins](../userguide/plugin_reference.html)
  * [Command-Line Interface](../userguide/command_line_interface.html)
  * [Gradle & Third-party Tools](../userguide/third_party_integration.html)
  * [The Gradle Wrapper](../userguide/gradle_wrapper.html)
  * [Gradle-managed Directories](../userguide/directory_layout.html)

# Transforming dependency artifacts on resolution

version 6.7.1

Contents

  * Artifact transform selection and execution
  * Implementing artifact transforms
  * Registering artifact transforms
  * Implementing incremental artifact transforms

As described in [different kinds of
configurations](declaring_dependencies.html#sec:resolvable-consumable-
configs), there may be different variants for the same dependency. For
example, an external Maven dependency has a variant which should be used when
compiling against the dependency (`java-api`), and a variant for running an
application which uses the dependency (`java-runtime`). A project dependency
has even more variants, for example the classes of the project which are used
for compilation are available as classes directories (`org.gradle.usage=java-
api, org.gradle.libraryelements=classes`) or as JARs (`org.gradle.usage=java-
api, org.gradle.libraryelements=jar`).

The variants of a dependency may differ in its transitive dependencies or in
the artifact itself. For example, the `java-api` and `java-runtime` variants
of a Maven dependency only differ in the transitive dependencies and both use
the same artifact — the JAR file. For a project dependency, the `java-
api,classes` and the `java-api,jars` variants have the same transitive
dependencies and different artifacts — the classes directories and the JAR
files respectively.

Gradle identifies a variant of a dependency uniquely by its set of
[attributes](variant_model.html#sec:abm_configuration_attributes). The `java-
api` variant of a dependency is the variant identified by the
`org.gradle.usage` attribute with value `java-api`.

When Gradle resolves a configuration, the
[attributes](variant_model.html#sec:abm_configuration_attributes) on the
resolved configuration determine the _requested attributes_. For all
dependencies in the configuration, the variant with the requested attributes
is selected when resolving the configuration. For example, when the
configuration requests `org.gradle.usage=java-api,
org.gradle.libraryelements=classes` on a project dependency, then the classes
directory is selected as the artifact.

When the dependency does not have a variant with the requested attributes,
resolving the configuration fails. Sometimes it is possible to transform the
artifact of the dependency into the requested variant without changing the
transitive dependencies. For example, unzipping a JAR transforms the artifact
of the `java-api,jars` variant into the `java-api,classes` variant. Such a
transformation is called _Artifact Transform_. Gradle allows registering
artifact transforms, and when the dependency does not have the requested
variant, then Gradle will try to find a chain of artifact transforms for
creating the variant.

## Artifact transform selection and execution

As described above, when Gradle resolves a configuration and a dependency in
the configuration does not have a variant with the requested attributes,
Gradle tries to find a chain of artifact transforms to create the variant. The
process of finding a matching chain of artifact transforms is called _artifact
transform selection_. Each registered transform converts from a set of
attributes to a set of attributes. For example, the unzip transform can
convert from `org.gradle.usage=java-api, org.gradle.libraryelements=jars` to
`org.gradle.usage=java-api, org.gradle.libraryelements=classes`.

In order to find a chain, Gradle starts with the requested attributes and then
considers all transforms which modify some of the requested attributes as
possible paths leading there. Going backwards, Gradle tries to obtain a path
to some existing variant using transforms.

For example, consider a `minified` attribute with two values: `true` and
`false`. The minified attribute represents a variant of a dependency with
unnecessary class files removed. There is an artifact transform registered,
which can transform `minified` from `false` to `true`. When `minified=true` is
requested for a dependency, and there are only variants with `minified=false`,
then Gradle selects the registered minify transform. The minify transform is
able to transform the artifact of the dependency with `minified=false` to the
artifact with `minified=true`.

Of all the found transform chains, Gradle tries to select the best one:

  * If there is only one transform chain, it is selected.

  * If there are two transform chains, and one is a suffix of the other one, it is selected.

  * If there is a shortest transform chain, then it is selected.

  * In all other cases, the selection fails and an error is reported.

__ |

Gradle does not try to select artifact transforms when there is already a
variant of the dependency matching the requested attributes.  
  
---|---  
  
__ |

The `artifactType` attribute is special, since it is only present on resolved
artifacts and not on dependencies. As a consequence, any transform which is
only mutating `artifactType` will never be selected when resolving a
configuration with only the `artifactType` as requested attribute. It will
only be considered when using an
[ArtifactView](../javadoc/org/gradle/api/artifacts/ArtifactView.html).  
  
---|---  
  
After selecting the required artifact transforms, Gradle resolves the variants
of the dependencies which are necessary for the initial transform in the
chain. As soon as Gradle finishes resolving the artifacts for the variant,
either by downloading an external dependency or executing a task producing the
artifact, Gradle starts transforming the artifacts of the variant with the
selected chain of artifact transforms. Gradle executes the transform chains in
parallel when possible.

Picking up the minify example above, consider a configuration with two
dependencies, the external `guava` dependency and a project dependency on the
`producer` project. The configuration has the attributes
`org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true`.
The external `guava` dependency has two variants:

  * `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false` and

  * `org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false`.

Using the minify transform, Gradle can convert the variant
`org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false`
of `guava` to `org.gradle.usage=java-
runtime,org.gradle.libraryelements=jar,minified=true`, which are the requested
attributes. The project dependency also has variants:

  * `org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false`,

  * `org.gradle.usage=java-runtime,org.gradle.libraryelements=classes,minified=false`,

  * `org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false`,

  * `org.gradle.usage=java-api,org.gradle.libraryelements=classes,minified=false`

  * and a few more.

Again, using the minify transform, Gradle can convert the variant
`org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false`
of the project `producer` to `org.gradle.usage=java-
runtime,org.gradle.libraryelements=jar,minified=true`, which are the requested
attributes.

When the configuration is resolved, Gradle needs to download the `guava` JAR
and minify it. Gradle also needs to execute the `producer:jar` task to
generate the JAR artifact of the project and then minify it. The downloading
and the minification of the `guava.jar` happens in parallel to the execution
of the `producer:jar` task and the minification of the resulting JAR.

Here is how to setup the `minified` attribute so that the above works. You
need to register the new attribute in the schema, add it to all JAR artifacts
and request it on all resolvable configurations.

Example 1. Artifact transform attribute setup

build.gradle

    
    
    def artifactType = Attribute.of('artifactType', String)
    def minified = Attribute.of('minified', Boolean)
    dependencies {
        attributesSchema {
            attribute(minified)                      __**(1)**
        }
        artifactTypes.getByName("jar") {
            attributes.attribute(minified, false)    __**(2)**
        }
    }
    
    configurations.all {
        afterEvaluate {
            if (canBeResolved) {
                attributes.attribute(minified, true) __**(3)**
            }
        }
    }
    
    dependencies {
        registerTransform(Minify) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
        }
    }
    
    dependencies {                                 __**(4)**
        implementation('com.google.guava:guava:27.1-jre')
        implementation(project(':producer'))
    }

build.gradle.kts

    
    
    val artifactType = Attribute.of("artifactType", String::class.java)
    val minified = Attribute.of("minified", Boolean::class.javaObjectType)
    dependencies {
        attributesSchema {
            attribute(minified)                      __**(1)**
        }
        artifactTypes.getByName("jar") {
            attributes.attribute(minified, false)    __**(2)**
        }
    }
    
    configurations.all {
        afterEvaluate {
            if (isCanBeResolved) {
                attributes.attribute(minified, true) __**(3)**
            }
        }
    }
    
    dependencies {
        registerTransform(Minify::class) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
        }
    }
    
    dependencies {                                 __**(4)**
        implementation("com.google.guava:guava:27.1-jre")
        implementation(project(":producer"))
    }

__**1** | Add the attribute to the schema  
---|---  
__**2** | All JAR files are not minified  
__**3** | Request `minified=true` on all resolvable configurations  
__**4** | Add the dependencies which will be transformed  
  
You can now see what happens when we run the `resolveRuntimeClasspath` task
which resolves the `runtimeClasspath` configuration. Observe that Gradle
transforms the project dependency before the `resolveRuntimeClasspath` task
starts. Gradle transforms the binary dependencies when it executes the
`resolveRuntimeClasspath` task.

Output when resolving the runtimeClasspath configuration

    
    
    > gradle resolveRuntimeClasspath
    
    > Task :producer:compileJava
    > Task :producer:processResources NO-SOURCE
    > Task :producer:classes
    > Task :producer:jar
    
    > Transform producer.jar (project :producer) with Minify
    Nothing to minify - using producer.jar unchanged
    
    > Task :resolveRuntimeClasspath
    Minifying guava-27.1-jre.jar
    Nothing to minify - using listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar unchanged
    Nothing to minify - using jsr305-3.0.2.jar unchanged
    Nothing to minify - using checker-qual-2.5.2.jar unchanged
    Nothing to minify - using error_prone_annotations-2.2.0.jar unchanged
    Nothing to minify - using j2objc-annotations-1.1.jar unchanged
    Nothing to minify - using animal-sniffer-annotations-1.17.jar unchanged
    Nothing to minify - using failureaccess-1.0.1.jar unchanged
    
    BUILD SUCCESSFUL in 0s
    3 actionable tasks: 3 executed

## Implementing artifact transforms

Similar to task types, an artifact transform consists of an action and some
parameters. The major difference to custom task types is that the action and
the parameters are implemented as two separate classes.

The implementation of the artifact transform action is a class implementing
[TransformAction](../dsl/org.gradle.api.artifacts.transform.TransformAction.html).
You need to implement the `transform()` method on the action, which converts
an input artifact into zero, one or multiple of output artifacts. Most
artifact transforms will be one-to-one, so the transform method will transform
the input artifact to exactly one output artifact.

The implementation of the artifact transform action needs to register each
output artifact by calling
[TransformOutputs.dir()](../dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:dir\(java.lang.Object\))
or
[TransformOutputs.file()](../dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:file\(java.lang.Object\)).

You can only supply two types of paths to the `dir` or `file` methods:

  * An absolute path to the input artifact or in the input artifact (for an input directory).

  * A relative path.

Gradle uses the absolute path as the location of the output artifact. For
example, if the input artifact is an exploded WAR, then the transform action
can call `TransformOutputs.file()` for all jar files in the `WEB-INF/lib`
directory. The output of the transform would then be the library JARs of the
web application.

For a relative path, the `dir()` or `file()` method returns a workspace to the
transform action. The implementation of the transform action needs to create
the transformed artifact at the location of the provided workspace.

The output artifacts replace the input artifact in the transformed variant in
the order they were registered. For example, if the configuration consists of
the artifacts `lib1.jar`, `lib2.jar`, `lib3.jar`, and the transform action
registers a minified output artifact `<artifact-name>-min.jar` for the input
artifact, then the transformed configuration consists of the artifacts
`lib1-min.jar`, `lib2-min.jar` and `lib3-min.jar`.

Here is the implementation of an `Unzip` transform which transforms a JAR file
into a classes directory by unzipping it. The `Unzip` transform does not
require any parameters. Note how the implementation uses `@InputArtifact` to
inject the artifact to transform into the action. It requests a directory for
the unzipped classes by using `TransformOutputs.dir()` and then unzips the JAR
file into this directory.

Example 2. Artifact transform without parameters

build.gradle

    
    
    abstract class Unzip implements TransformAction<TransformParameters.None> { __**(1)**
        @InputArtifact                                                          __**(2)**
        abstract Provider<FileSystemLocation> getInputArtifact()
    
        @Override
        void transform(TransformOutputs outputs) {
            def input = inputArtifact.get().asFile
            def unzipDir = outputs.dir(input.name)                              __**(3)**
            unzipTo(input, unzipDir)                                            __**(4)**
        }
    
        private static void unzipTo(File zipFile, File unzipDir) {
            // implementation...
        }
    }

build.gradle.kts

    
    
    abstract class Unzip : TransformAction<TransformParameters.None> {          __**(1)**
        @get:InputArtifact                                                      __**(2)**
        abstract val inputArtifact: Provider<FileSystemLocation>
    
        override
        fun transform(outputs: TransformOutputs) {
            val input = inputArtifact.get().asFile
            val unzipDir = outputs.dir(input.name)                              __**(3)**
            unzipTo(input, unzipDir)                                            __**(4)**
        }
    
        private fun unzipTo(zipFile: File, unzipDir: File) {
            // implementation...
        }
    }

__**1** | Use `TransformParameters.None` if the transform does not use
parameters  
---|---  
__**2** | Inject the input artifact  
__**3** | Request an output location for the unzipped files  
__**4** | Do the actual work of the transform  
  
An artifact transform may require parameters, like a `String` determining some
filter, or some file collection which is used for supporting the
transformation of the input artifact. In order to pass those parameters to the
transform action, you need to define a new type with the desired parameters.
The type needs to implement the marker interface
[TransformParameters](../javadoc/org/gradle/api/artifacts/transform/TransformParameters.html).
The parameters must be represented using [managed
properties](custom_gradle_types.html#managed_properties) and the parameters
type must be a [managed type](custom_gradle_types.html#managed_types). You can
use an interface or abstract class declaring the getters and Gradle will
generate the implementation. All getters need to have proper input
annotations, see the table in the section on [incremental
build](more_about_tasks.html#table:incremental_build_annotations).

You can find out more about implementing artifact transform parameters in
[Developing Custom Gradle
Types](custom_gradle_types.html#custom_gradle_types).

Here is the implementation of a `Minify` transform that makes JARs smaller by
only keeping certain classes in them. The `Minify` transform requires the
classes to keep as parameters. Observe how you can obtain the parameters by
`TransformAction.getParameters()` in the `transform()` method. The
implementation of the `transform()` method requests a location for the
minified JAR by using `TransformOutputs.file()` and then creates the minified
JAR at this location.

Example 3. Minify transform implementation

build.gradle

    
    
    abstract class Minify implements TransformAction<Parameters> { __**(1)**
        interface Parameters extends TransformParameters {         __**(2)**
            @Input
            Map<String, Set<String>> getKeepClassesByArtifact()
            void setKeepClassesByArtifact(Map<String, Set<String>> keepClasses)
        }
    
        @PathSensitive(PathSensitivity.NAME_ONLY)
        @InputArtifact
        abstract Provider<FileSystemLocation> getInputArtifact()
    
        @Override
        void transform(TransformOutputs outputs) {
            def fileName = inputArtifact.get().asFile.name
            for (entry in parameters.keepClassesByArtifact) {      __**(3)**
                if (fileName.startsWith(entry.key)) {
                    def nameWithoutExtension = fileName.substring(0, fileName.length() - 4)
                    minify(inputArtifact.get().asFile, entry.value, outputs.file("${nameWithoutExtension}-min.jar"))
                    return
                }
            }
            println "Nothing to minify - using ${fileName} unchanged"
            outputs.file(inputArtifact)                            __**(4)**
        }
    
        private void minify(File artifact, Set<String> keepClasses, File jarFile) {
            println "Minifying ${artifact.name}"
            // Implementation ...
        }
    }

build.gradle.kts

    
    
    abstract class Minify : TransformAction<Minify.Parameters> {   __**(1)**
        interface Parameters : TransformParameters {               __**(2)**
            @get:Input
            var keepClassesByArtifact: Map<String, Set<String>>
    
        }
    
        @get:PathSensitive(PathSensitivity.NAME_ONLY)
        @get:InputArtifact
        abstract val inputArtifact: Provider<FileSystemLocation>
    
        override
        fun transform(outputs: TransformOutputs) {
            val fileName = inputArtifact.get().asFile.name
            for (entry in parameters.keepClassesByArtifact) {      __**(3)**
                if (fileName.startsWith(entry.key)) {
                    val nameWithoutExtension = fileName.substring(0, fileName.length - 4)
                    minify(inputArtifact.get().asFile, entry.value, outputs.file("${nameWithoutExtension}-min.jar"))
                    return
                }
            }
            println("Nothing to minify - using ${fileName} unchanged")
            outputs.file(inputArtifact)                            __**(4)**
        }
    
        private fun minify(artifact: File, keepClasses: Set<String>, jarFile: File) {
            println("Minifying ${artifact.name}")
            // Implementation ...
        }
    }

__**1** | Declare the parameter type  
---|---  
__**2** | Interface for the transform parameters  
__**3** | Use the parameters  
__**4** | Use the unchanged input artifact when no minification is required  
  
Remember that the input artifact is a dependency, which may have its own
dependencies. If your artifact transform needs access to those transitive
dependencies, it can declare an abstract getter returning a `FileCollection`
and annotate it with
[@InputArtifactDependencies](../javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html).
When your transform runs, Gradle will inject the transitive dependencies into
that `FileCollection` property by implementing the getter. Note that using
input artifact dependencies in a transform has performance implications, only
inject them when you really need them.

Moreover, artifact transforms can make use of the [build
cache](build_cache.html#build_cache) for their outputs. To enable the build
cache for an artifact transform, add the
`@[CacheableTransform](../javadoc/org/gradle/api/artifacts/transform/CacheableTransform.html)`
annotation on the action class. For cacheable transforms, you must annotate
its
[@InputArtifact](../javadoc/org/gradle/api/artifacts/transform/InputArtifact.html)
property — and any property marked with
[@InputArtifactDependencies](../javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html)
— with normalization annotations such as
[@PathSensitive](../javadoc/org/gradle/api/tasks/PathSensitive.html).

The following example shows a more complicated transform. It moves some
selected classes of a JAR to a different package, rewriting the byte code of
the moved classes and all classes using the moved classes (class relocation).
In order to determine the classes to relocate, it looks at the packages of the
input artifact and the dependencies of the input artifact. It also does not
relocate packages contained in JAR files in an external classpath.

Example 4. Artifact transform for class relocation

build.gradle

    
    
    @CacheableTransform                                                          __**(1)**
    abstract class ClassRelocator implements TransformAction<Parameters> {
        interface Parameters extends TransformParameters {                       __**(2)**
            @CompileClasspath                                                    __**(3)**
            ConfigurableFileCollection getExternalClasspath()
            @Input
            Property<String> getExcludedPackage()
        }
    
        @Classpath                                                               __**(4)**
        @InputArtifact
        abstract Provider<FileSystemLocation> getPrimaryInput()
    
        @CompileClasspath
        @InputArtifactDependencies                                               __**(5)**
        abstract FileCollection getDependencies()
    
        @Override
        void transform(TransformOutputs outputs) {
            def primaryInputFile = primaryInput.get().asFile
            if (parameters.externalClasspath.contains(primaryInput)) {           __**(6)**
                outputs.file(primaryInput)
            } else {
                def baseName = primaryInputFile.name.substring(0, primaryInputFile.name.length - 4)
                relocateJar(outputs.file("$baseName-relocated.jar"))
            }
        }
    
        private relocateJar(File output) {
            // implementation...
            def relocatedPackages = (dependencies.collectMany { readPackages(it) } + readPackages(primaryInput.get().asFile)) as Set
            def nonRelocatedPackages = parameters.externalClasspath.collectMany { readPackages(it) }
            def relocations = (relocatedPackages - nonRelocatedPackages).collect { packageName ->
                def toPackage = "relocated.$packageName"
                println("$packageName -> $toPackage")
                new Relocation(packageName, toPackage)
            }
            new JarRelocator(primaryInput.get().asFile, output, relocations).run()
        }
    }

build.gradle.kts

    
    
    @CacheableTransform                                                          __**(1)**
    abstract class ClassRelocator : TransformAction<ClassRelocator.Parameters> {
        interface Parameters : TransformParameters {                             __**(2)**
            @get:CompileClasspath                                                __**(3)**
            val externalClasspath: ConfigurableFileCollection
            @get:Input
            val excludedPackage: Property<String>
        }
    
        @get:Classpath                                                           __**(4)**
        @get:InputArtifact
        abstract val primaryInput: Provider<FileSystemLocation>
    
        @get:CompileClasspath
        @get:InputArtifactDependencies                                           __**(5)**
        abstract val dependencies: FileCollection
    
        override
        fun transform(outputs: TransformOutputs) {
            val primaryInputFile = primaryInput.get().asFile
            if (parameters.externalClasspath.contains(primaryInputFile)) {       __**(6)**
                outputs.file(primaryInput)
            } else {
                val baseName = primaryInputFile.name.substring(0, primaryInputFile.name.length - 4)
                relocateJar(outputs.file("$baseName-relocated.jar"))
            }
        }
    
        private fun relocateJar(output: File) {
            // implementation...
            val relocatedPackages = (dependencies.flatMap { it.readPackages() } + primaryInput.get().asFile.readPackages()).toSet()
            val nonRelocatedPackages = parameters.externalClasspath.flatMap { it.readPackages() }
            val relocations = (relocatedPackages - nonRelocatedPackages).map { packageName ->
                val toPackage = "relocated.$packageName"
                println("$packageName -> $toPackage")
                Relocation(packageName, toPackage)
            }
            JarRelocator(primaryInput.get().asFile, output, relocations).run()
        }
    }

__**1** | Declare the transform cacheable  
---|---  
__**2** | Interface for the transform parameters  
__**3** | Declare input type for each parameter  
__**4** | Declare a normalization for the input artifact  
__**5** | Inject the input artifact dependencies  
__**6** | Use the parameters  
  
## Registering artifact transforms

You need to register the artifact transform actions, providing parameters if
necessary, so that they can be selected when resolving dependencies.

In order to register an artifact transform, you must use
[registerTransform()](../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:registerTransform\(java.lang.Class,%20org.gradle.api.Action\))
within the `dependencies {}` block.

There are a few points to consider when using `registerTransform()`:

  * The `from` and `to` attributes are required.

  * The transform action itself can have configuration options. You can configure them with the `parameters {}` block.

  * You must register the transform on the project that has the configuration that will be resolved.

  * You can supply any type implementing [TransformAction](../dsl/org.gradle.api.artifacts.transform.TransformAction.html) to the `registerTransform()` method.

For example, imagine you want to unpack some dependencies and put the unpacked
directories and files on the classpath. You can do so by registering an
artifact transform action of type `Unzip`, as shown here:

Example 5. Artifact transform registration without parameters

build.gradle

    
    
    def artifactType = Attribute.of('artifactType', String)
    
    dependencies {
        registerTransform(Unzip) {
            from.attribute(artifactType, 'jar')
            to.attribute(artifactType, 'java-classes-directory')
        }
    }

build.gradle.kts

    
    
    val artifactType = Attribute.of("artifactType", String::class.java)
    
    dependencies {
        registerTransform(Unzip::class) {
            from.attribute(artifactType, "jar")
            to.attribute(artifactType, "java-classes-directory")
        }
    }

Another example is that you want to minify JARs by only keeping some `class`
files from them. Note the use of the `parameters {}` block to provide the
classes to keep in the minified JARs to the `Minify` transform.

Example 6. Artifact transform registration with parameters

build.gradle

    
    
    def artifactType = Attribute.of('artifactType', String)
    def minified = Attribute.of('minified', Boolean)
    def keepPatterns = [
        "guava": [
            "com.google.common.base.Optional",
            "com.google.common.base.AbstractIterator"
        ] as Set
    ]
    
    
    dependencies {
        registerTransform(Minify) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
    
            parameters {
                keepClassesByArtifact = keepPatterns
            }
        }
    }

build.gradle.kts

    
    
    val artifactType = Attribute.of("artifactType", String::class.java)
    val minified = Attribute.of("minified", Boolean::class.javaObjectType)
    val keepPatterns = mapOf(
        "guava" to setOf(
            "com.google.common.base.Optional",
            "com.google.common.base.AbstractIterator"
        )
    )
    
    
    dependencies {
        registerTransform(Minify::class) {
            from.attribute(minified, false).attribute(artifactType, "jar")
            to.attribute(minified, true).attribute(artifactType, "jar")
    
            parameters {
                keepClassesByArtifact = keepPatterns
            }
        }
    }

## Implementing incremental artifact transforms

Similar to [incremental tasks](custom_tasks.html#incremental_tasks), artifact
transforms can avoid work by only processing changed files from the last
execution. This is done by using the
[InputChanges](../dsl/org.gradle.work.InputChanges.html) interface. For
artifact transforms, only the input artifact is an incremental input, and
therefore the transform can only query for changes there. In order to use
[InputChanges](../dsl/org.gradle.work.InputChanges.html) in the transform
action, inject it into the action. For more information on how to use
[InputChanges](../dsl/org.gradle.work.InputChanges.html), see the
corresponding documentation for [incremental
tasks](custom_tasks.html#incremental_tasks).

Here is an example of an incremental transform that counts the lines of code
in Java source files:

Example 7. Artifact transform for lines of code counting

build.gradle

    
    
    abstract class CountLoc implements TransformAction<TransformParameters.None> {
    
        @Inject                                                             __**(1)**
        abstract InputChanges getInputChanges()
    
        @PathSensitive(PathSensitivity.RELATIVE)
        @InputArtifact
        abstract Provider<FileSystemLocation> getInput()
    
        @Override
        void transform(TransformOutputs outputs) {
            def outputDir = outputs.dir("${input.get().asFile.name}.loc")
            println("Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.incremental}")
            inputChanges.getFileChanges(input).forEach { change ->          __**(2)**
                def changedFile = change.file
                if (change.fileType != FileType.FILE) {
                    return
                }
                def outputLocation = new File(outputDir, "${change.normalizedPath}.loc")
                switch (change.changeType) {
                    case ADDED:
                    case MODIFIED:
                        println("Processing file ${changedFile.name}")
                        outputLocation.parentFile.mkdirs()
    
                        outputLocation.text = changedFile.readLines().size()
    
                    case REMOVED:
                        println("Removing leftover output file ${outputLocation.name}")
                        outputLocation.delete()
    
                }
            }
        }
    }

build.gradle.kts

    
    
    abstract class CountLoc : TransformAction<TransformParameters.None> {
    
        @get:Inject                                                         __**(1)**
        abstract val inputChanges: InputChanges
    
        @get:PathSensitive(PathSensitivity.RELATIVE)
        @get:InputArtifact
        abstract val input: Provider<FileSystemLocation>
    
        override
        fun transform(outputs: TransformOutputs) {
            val outputDir = outputs.dir("${input.get().asFile.name}.loc")
            println("Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.isIncremental}")
            inputChanges.getFileChanges(input).forEach { change ->          __**(2)**
                val changedFile = change.file
                if (change.fileType != FileType.FILE) {
                    return@forEach
                }
                val outputLocation = outputDir.resolve("${change.normalizedPath}.loc")
                when (change.changeType) {
                    ChangeType.ADDED, ChangeType.MODIFIED -> {
    
                        println("Processing file ${changedFile.name}")
                        outputLocation.parentFile.mkdirs()
    
                        outputLocation.writeText(changedFile.readLines().size.toString())
                    }
                    ChangeType.REMOVED -> {
                        println("Removing leftover output file ${outputLocation.name}")
                        outputLocation.delete()
                    }
                }
            }
        }
    }

__**1** | Inject `InputChanges`  
---|---  
__**2** | Query for changes in the input artifact  
  
**Docs**

  * [User Manual](/userguide/userguide.html)
  * [DSL Reference](/dsl/)
  * [Release Notes](/release-notes.html)
  * [Javadoc](/javadoc/)

**News**

  * [Blog](https://blog.gradle.org/)
  * [Newsletter](https://newsletter.gradle.com/)
  * [Twitter](https://twitter.com/gradle)
  * [Status Page](https://status.gradle.com/)

**Products**

  * [Build Scans](https://gradle.com/build-scans/)
  * [Build Cache](https://gradle.com/build-cache/)
  * [Enterprise Docs](https://gradle.com/enterprise/resources/)

**Get Help**

  * [Forums](https://discuss.gradle.org/c/help-discuss)
  * [GitHub](https://github.com/gradle/)
  * [Training](https://gradle.com/training/)
  * [Services](https://gradle.org/services/)

##### Stay `UP-TO-DATE` on new features and news

By entering your email, you agree to our
[Terms](https://gradle.com/legal/terms-of-service/) and [Privacy
Policy](https://gradle.com/legal/privacy/), including receipt of emails. You
can unsubscribe at any time.

Subscribe

© [Gradle Inc.](https://gradle.com) 2020 All rights reserved.

[ gradle ](/)

[Careers](https://gradle.com/careers/) |
[Privacy](https://gradle.com/legal/privacy/) | [Terms of
Service](https://gradle.com/legal/terms-of-service/) |
[Contact](https://gradle.org/contact/)

