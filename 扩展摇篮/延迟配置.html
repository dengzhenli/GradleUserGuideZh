 无标题 <style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body { padding-left: 48px; padding-right: 48px;}</style><style id="wiz_code_style">.wiz-editor-body .wiz-code-container{position: relative; padding:8px 0; margin: 5px 0;text-indent:0; text-align:left;}.CodeMirror {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; color: black; font-size: 10.5pt; font-size: 0.875rem}.wiz-editor-body .wiz-code-container .CodeMirror div {margin-top: 0; margin-bottom: 0;}.CodeMirror-lines {padding: 4px 0;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {padding: 0 4px;}.CodeMirror pre.CodeMirror-line {min-height: 24px;}.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {background-color: white;}.CodeMirror-gutters {border-right: 1px solid #ddd; background-color: #f7f7f7; white-space: nowrap;}.CodeMirror-linenumbers {}.CodeMirror-linenumber {padding: 0 3px 0 5px; min-width: 20px; text-align: right; color: #999; white-space: nowrap;}.CodeMirror-guttermarker {color: black;}.CodeMirror-guttermarker-subtle {color: #999;}.CodeMirror-cursor {border-left: 1px solid black; border-right: none; width: 0;}.CodeMirror div.CodeMirror-secondarycursor {border-left: 1px solid silver;}.cm-fat-cursor .CodeMirror-cursor {width: auto; border: 0 !important; background: #7e7;}.cm-fat-cursor div.CodeMirror-cursors {z-index: 1;}.cm-fat-cursor-mark {background-color: rgba(20, 255, 20, 0.5);-webkit-animation: blink 1.06s steps(1) infinite;-moz-animation: blink 1.06s steps(1) infinite;animation: blink 1.06s steps(1) infinite;}.cm-animate-fat-cursor {width: auto; border: 0; -webkit-animation: blink 1.06s steps(1) infinite; -moz-animation: blink 1.06s steps(1) infinite; animation: blink 1.06s steps(1) infinite; background-color: #7e7;}@-moz-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@-webkit-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}.CodeMirror-overwrite .CodeMirror-cursor {}.cm-tab { display: inline-block; text-decoration: inherit; }.CodeMirror-rulers {position: absolute; left: 0; right: 0; top: -50px; bottom: -20px; overflow: hidden;}.CodeMirror-ruler {border-left: 1px solid #ccc; top: 0; bottom: 0; position: absolute;}.cm-s-default .cm-header {color: blue;}.cm-s-default .cm-quote {color: #090;}.cm-negative {color: #d44;}.cm-positive {color: #292;}.cm-header, .cm-strong {font-weight: bold;}.cm-em {font-style: italic;}.cm-link {text-decoration: underline;}.cm-strikethrough {text-decoration: line-through;}.cm-s-default .cm-keyword {color: #708;}.cm-s-default .cm-atom {color: #219;}.cm-s-default .cm-number {color: #164;}.cm-s-default .cm-def {color: #00f;}.cm-s-default .cm-variable,.cm-s-default .cm-punctuation,.cm-s-default .cm-property,.cm-s-default .cm-operator {}.cm-s-default .cm-variable-2 {color: #05a;}.cm-s-default .cm-variable-3 {color: #085;}.cm-s-default .cm-comment {color: #a50;}.cm-s-default .cm-string {color: #a11;}.cm-s-default .cm-string-2 {color: #f50;}.cm-s-default .cm-meta {color: #555;}.cm-s-default .cm-qualifier {color: #555;}.cm-s-default .cm-builtin {color: #30a;}.cm-s-default .cm-bracket {color: #997;}.cm-s-default .cm-tag {color: #170;}.cm-s-default .cm-attribute {color: #00c;}.cm-s-default .cm-hr {color: #999;}.cm-s-default .cm-link {color: #00c;}.cm-s-default .cm-error {color: #f00;}.cm-invalidchar {color: #f00;}.CodeMirror-composing { border-bottom: 2px solid; }div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }.CodeMirror-activeline-background {background: #e8f2ff;}.CodeMirror {position: relative; background: #f5f5f5;}.CodeMirror-scroll {overflow: hidden !important; margin-bottom: 0; margin-right: -30px; padding: 16px 30px 16px 0; outline: none; position: relative;}.CodeMirror-sizer {position: relative; border-right: 30px solid transparent;}.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {position: absolute; z-index: 6; display: none;}.CodeMirror-vscrollbar {right: 0; top: 0; overflow-x: hidden; overflow-y: scroll;}.CodeMirror-hscrollbar {bottom: 0; left: 0 !important; overflow-y: hidden; overflow-x: scroll;pointer-events: auto !important;outline: none;}.CodeMirror-scrollbar-filler {right: 0; bottom: 0;}.CodeMirror-gutter-filler {left: 0; bottom: 0;}.CodeMirror-gutters {position: absolute; left: 0; top: 0; min-height: 100%; z-index: 3;}.CodeMirror-gutter {white-space: normal; height: 100%; display: inline-block; vertical-align: top; margin-bottom: -30px;}.CodeMirror-gutter-wrapper {position: absolute; z-index: 4; background: none !important; border: none !important;}.CodeMirror-gutter-background {position: absolute; top: 0; bottom: 0; z-index: 4;}.CodeMirror-gutter-elt {position: absolute; cursor: default; z-index: 4;}.CodeMirror-gutter-wrapper ::selection { background-color: transparent }.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }.CodeMirror-lines {cursor: text; min-height: 1px;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {-moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0; border-width: 0; background: transparent; font-family: inherit; font-size: inherit; margin: 0; white-space: pre; word-wrap: normal; line-height: inherit; color: inherit; z-index: 2; position: relative; overflow: visible; -webkit-tap-highlight-color: transparent; -webkit-font-variant-ligatures: contextual; font-variant-ligatures: contextual;}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like {word-wrap: break-word; white-space: pre-wrap; word-break: normal;}.CodeMirror-linebackground {position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;}.CodeMirror-linewidget {position: relative; z-index: 2; padding: 0.1px;}.CodeMirror-widget {}.CodeMirror-rtl pre { direction: rtl; }.CodeMirror-code {outline: none;}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {-moz-box-sizing: content-box; box-sizing: content-box;}.CodeMirror-measure {position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;}.CodeMirror-cursor {position: absolute; pointer-events: none;}.CodeMirror-measure pre { position: static; }div.CodeMirror-cursors {visibility: hidden; position: relative; z-index: 3;}div.CodeMirror-dragcursors {visibility: visible;}.CodeMirror-focused div.CodeMirror-cursors {visibility: visible;}.CodeMirror-selected { background: #d9d9d9; }.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }.CodeMirror-crosshair { cursor: crosshair; }.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }.cm-searching {background: #ffa; background: rgba(255, 255, 0, .4);}.cm-force-border { padding-right: .1px; }@media print { .CodeMirror div.CodeMirror-cursors {visibility: hidden;}}.cm-tab-wrap-hack:after { content: ""; }span.CodeMirror-selectedtext { background: none; }.CodeMirror-activeline-background, .CodeMirror-selected {transition: visibility 0ms 100ms;}.CodeMirror-blur .CodeMirror-activeline-background, .CodeMirror-blur .CodeMirror-selected {visibility:hidden;}.CodeMirror-blur .CodeMirror-matchingbracket {color:inherit !important;outline:none !important;text-decoration:none !important;}.CodeMirror-sizer {min-height:auto !important;}</style>

# 延迟配置

内容

* [懒惰的属性](#lazy_properties)
* [创建属性或提供程序实例](#creating_property_provider)
* [将属性连接在一起](#connecting_properties_together)
* [处理文件](#working_with_files_in_lazy_properties)
* [使用任务输入和输出](#working_with_task_dependencies_in_lazy_properties)
* [使用收藏](#working_with_collections)
* [使用地图](#working_with_maps)
* [将约定应用于属性](#applying_conventions)
* [使财产不可修改](#unmodifiable_property)
* [指导方针](#lazy_configuration_faqs)
* [未来发展](#lazy_configuration_roadmap)
* [提供程序文件API参考](#lazy_configuration_reference)
* [属性文件API参考](#property_files_api_reference)
* [惰性集合API参考](#lazy_collections_api_reference)
* [惰性对象API参考](#lazy_objects_api_reference)

随着构建复杂性的增加，知道何时何地配置特定值可能变得难以推理。Gradle提供了几种使用_惰性配置_来管理这种复杂性的方法。

## [](#lazy_properties)[懒惰的属性](#lazy_properties)

Gradle提供了惰性属性，这延迟了对属性值的计算，直到真正需要它为止。这些为构建脚本和插件作者提供了三个主要好处：

1.  构建作者可以将Gradle模型关联在一起，而不必担心何时知道特定属性的值。例如，您可能想基于扩展的源目录属性来设置任务的输入源文件，但是直到构建脚本或某些其他插件对其进行配置之前，扩展属性值才是未知的。
2.  构建作者可以将任务的输出属性连接到其他任务的输入属性，Gradle会基于此连接自动确定任务依赖性。属性实例携带有关哪个任务（如果有）产生其值的信息。构建作者无需担心使任务依赖项与配置更改保持同步。
3.  构建作者可以避免在配置阶段花费大量资源，这可能会对构建性能产生重大影响。例如，当配置值来自解析文件但仅在运行功能测试时使用时，使用属性实例捕获这意味着仅在运行功能测试时才解析文件，例如，`clean`运行。

Gradle通过两个接口表示惰性属性：

* [提供者]()表示只能查询而不能更改的值。  

  * 这些类型的属性是只读的。
  * 方法[Provider.get（）]()返回属性的当前值。
  * 阿`Provider`可以从另一个被创建`Provider`使用[Provider.map（变压器）]()。
  * 许多其他类型`Provider`可以扩展，并且可以在需要使用a的任何地方`Provider`使用。
* [属性]()表示可以查询和更改的值。  

  * 这些类型的属性是可配置的。
  * `Property`扩展`Provider`接口。
  * 方法[Property.set（T）]()为属性指定一个值，覆盖可能存在的任何值。
  * [Property.set（Provider）]()方法为[属性]()`Provider`的值指定一个，覆盖可能存在的任何值。这使您可以在配置值之前将实例`Provider`和`Property`实例连接在一起。
  * 阿`Property`可通过工厂方法创建[ObjectFactory.property（类）]()。

惰性属性旨在传递，并且仅在需要时才查询。通常，这将在执行阶段发生。有关Gradle构建阶段的更多信息，请参见[构建生命周期]()。

以下内容演示了一个任务，该任务具有可配置的`greeting`属性和`message`从中派生的只读属性：

示例1.使用只读和可配置属性

`Groovy``Kotlin`

build.gradle

// A task that displays a greeting class Greeting extends DefaultTask \{ // A configurable greeting \@Input final Property\<String> greeting = project.objects.property\(String\) // Read-only property calculated from the greeting \@Internal final Provider\<String> message = greeting.map \{ it + ' from Gradle' \} \@TaskAction void printMessage\(\) \{ logger.quiet\(message.get\(\)\) \} \} task greeting\(type: Greeting\) \{ // Configure the greeting greeting.set\('Hi'\) // Note that an assignment statement can be used instead of calling Property.set\(\) greeting = 'Hi' \}

 

1

// A task that displays a greeting

2

class Greeting extends DefaultTask \{

3

 // A configurable greeting

4

 \@Input

5

 final Property\<String\> greeting \= project.objects.property\(String\)

6

7

 // Read-only property calculated from the greeting

8

 \@Internal

9

 final Provider\<String\> message \= greeting.map \{ it + ' from Gradle' \}

10

11

 \@TaskAction

12

 void printMessage\(\) \{

13

 logger.quiet\(message.get\(\)\)

14

 \}

15

\}

16

17

task greeting\(type: Greeting\) \{

18

 // Configure the greeting

19

 greeting.set\('Hi'\)

20

21

 // Note that an assignment statement can be used instead of calling Property.set\(\)

22

 greeting \= 'Hi'

23

\}

输出**`gradle greeting`**

\$ gradle问候
 >任务：问候 来自Gradle的大家好
 在0秒内成功建立 1个可执行的任务：1个已执行

该`Greeting`任务的类型属性`Property<String>`代表可配置的问候语，并且类型属性`Provider<String>`代表计算的只读消息。消息`Provider`是`Property`使用`map()`方法从问候语创建的，因此，随着greeting属性值的更改，其值将保持最新。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>请注意，Gradle Groovy DSL为</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">Property</code><font><font>任务实现中的</font><font>每个</font><font>类型的属性</font><font>生成设置方法</font><font>。</font><font>这些设置方法使您可以</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">=</code><font><font>方便地</font><font>使用Assignment（</font><font>）运算符</font><font>配置属性</font><font>。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>Kotlin DSL便利性将在将来的版本中添加。</font></font></p></div></td></tr></tbody></table>

## [](#creating_property_provider)[创建属性或提供程序实例](#creating_property_provider)

既不打算由构建脚本也`Provider`不能由其子类型`Property`或插件作者来实现。Gradle提供了工厂方法来创建这些类型的实例。有关所有类型和工厂的信息，请参阅[快速参考](#lazy_configuration_reference)。在前面的示例中，我们看到了两种工厂方法：

* [ObjectFactory.property（Class）]()创建一个新`Property`实例。可以从[Project.getObjects（）]()或通过构造函数或方法注入来引用[ObjectFactory]()的实例。`ObjectFactory`
* [Provider.map（变压器）]()创建一个新的`Provider`从现有`Provider`或`Property`实例。

甲`Provider`也可以由工厂方法创建[ProviderFactory.provider（可赎回）]()。您应该宁愿使用它`map()`，因为它有一些有用的好处，我们将在后面看到。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>没有使用的特定方法来创建提供程序</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">groovy.lang.Closure</code><font><font>。</font><font>用Groovy编写插件或构建脚本时，可以将</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">map(Transformer)</code><font><font>方法与闭包一起使用，Groovy将负责将闭包转换为</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">Transformer</code><font><font>。</font><font>您可以在前面的示例中看到这一点。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>同样，当使用Kotlin编写插件或构建脚本时，Kotlin编译器将负责将Kotlin函数转换为</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">Transformer</code><font><font>。</font></font></p></div></td></tr></tbody></table>

## [](#connecting_properties_together)[将属性连接在一起](#connecting_properties_together)

惰性属性的一个重要特征是它们可以连接在一起，从而对一个属性的更改会自动反映在其他属性中。这是一个将任务的属性连接到项目扩展的属性的示例：

示例2.将属性连接在一起

`Groovy``Kotlin`

build.gradle

// A project extension class MessageExtension \{ // A configurable greeting final Property\<String> greeting \@javax.inject.Inject MessageExtension\(ObjectFactory objects\) \{ greeting = objects.property\(String\) \} \} // A task that displays a greeting class Greeting extends DefaultTask \{ // A configurable greeting \@Input final Property\<String> greeting = project.objects.property\(String\) // Read-only property calculated from the greeting \@Internal final Provider\<String> message = greeting.map \{ it + ' from Gradle' \} \@TaskAction void printMessage\(\) \{ logger.quiet\(message.get\(\)\) \} \} // Create the project extension project.extensions.create\('messages', MessageExtension\) // Create the greeting task task greeting\(type: Greeting\) \{ // Attach the greeting from the project extension // Note that the values of the project extension have not been configured yet greeting.set\(project.messages.greeting\) // Note that an assignment statement can be used instead of calling Property.set\(\) greeting = project.messages.greeting \} messages \{ // Configure the greeting on the extension // Note that there is no need to reconfigure the task's \`greeting\` property. This is automatically updated as the extension property changes greeting = 'Hi' \}

 

1

// A project extension

2

class MessageExtension \{

3

 // A configurable greeting

4

 final Property\<String\> greeting

5

6

 \@javax.inject.Inject

7

 MessageExtension\(ObjectFactory objects\) \{

8

 greeting \= objects.property\(String\)

9

 \}

10

\}

11

12

// A task that displays a greeting

13

class Greeting extends DefaultTask \{

14

 // A configurable greeting

15

 \@Input

16

 final Property\<String\> greeting \= project.objects.property\(String\)

17

18

 // Read-only property calculated from the greeting

19

 \@Internal

20

 final Provider\<String\> message \= greeting.map \{ it + ' from Gradle' \}

21

22

 \@TaskAction

23

 void printMessage\(\) \{

24

 logger.quiet\(message.get\(\)\)

25

 \}

26

\}

27

28

// Create the project extension

29

project.extensions.create\('messages', MessageExtension\)

30

31

// Create the greeting task

32

task greeting\(type: Greeting\) \{

33

 // Attach the greeting from the project extension

34

 // Note that the values of the project extension have not been configured yet

35

 greeting.set\(project.messages.greeting\)

36

37

 // Note that an assignment statement can be used instead of calling Property.set\(\)

38

 greeting \= project.messages.greeting

39

\}

40

41

messages \{

42

 // Configure the greeting on the extension

43

 // Note that there is no need to reconfigure the task's \`greeting\` property. This is automatically updated as the extension property changes

44

 greeting \= 'Hi'

45

\}

输出**`gradle greeting`**

\$ gradle问候
 >任务：问候 来自Gradle的大家好
 在0秒内成功建立 1个可执行的任务：1个已执行

本示例调用[Property.set（Provider）]()方法将a附加`Provider`到a，`Property`以提供属性的值。在这种情况下，`Provider`碰巧也是一种情况`Property`，但是您可以连接任何`Provider`实现，例如使用`Provider.map()`

## [](#working_with_files_in_lazy_properties)[处理文件](#working_with_files_in_lazy_properties)

在[“使用文件”中]()，我们为`File`类对象引入了四种收集类型：

表1.文件概要回顾
| 只读类型 | 可配置类型 |
| --- | --- |
| 
[文件集]()

 | 

[ConfigurableFileCollection]()

 |
| 

[文件树]()

 | 

[可配置文件树]()

 |

所有这些类型也被认为是惰性类型。

在本节中，我们将介绍更强类型的模型类型来表示文件系统的元素：[Directory]()和[RegularFile]()。这些类型不应与标准Java[File](https://docs.oracle.com/javase/8/docs/api/java/io/File.html)类型混淆，因为它们用于告诉Gradle和其他人您期望更具体的值，例如目录或非目录常规文件。

Gradle提供了两个专门的`Property`子类型来处理这些类型的值：[RegularFileProperty]()和[DirectoryProperty]()。[ObjectFactory]()具有创建这些方法的方法：[ObjectFactory.fileProperty（）]()和[ObjectFactory.directoryProperty（）]()。

A`DirectoryProperty`也可以分别通过[DirectoryProperty.dir（String）]()和[DirectoryProperty.file（String）]()来创建`Provider`对`Directory`和的延迟评估。这些方法创建提供程序，其值是根据创建它们的位置计算的。从这些提供程序返回的值将反映对的更改。`RegularFile``DirectoryProperty``DirectoryProperty`

例子3.使用文件和目录属性

`Groovy``Kotlin`

build.gradle

// A task that generates a source file and writes the result to an output directory class GenerateSource extends DefaultTask \{ // The configuration file to use to generate the source file \@InputFile final RegularFileProperty configFile = project.objects.fileProperty\(\) // The directory to write source files to \@OutputDirectory final DirectoryProperty outputDir = project.objects.directoryProperty\(\) \@TaskAction def compile\(\) \{ def inFile = configFile.get\(\).asFile logger.quiet\("configuration file = \$inFile"\) def dir = outputDir.get\(\).asFile logger.quiet\("output dir = \$dir"\) def className = inFile.text.trim\(\) def srcFile = new File\(dir, "\$\{className\}.java"\) srcFile.text = "public class \$\{className\} \{ ... \}" \} \} // Create the source generation task task generate\(type: GenerateSource\) \{ // Configure the locations, relative to the project and build directories configFile = project.layout.projectDirectory.file\('src/main/config.txt'\) outputDir = project.layout.buildDirectory.dir\('generated-source'\) // Note that a \`File\` instance can be used as a convenience to set a location configFile = file\('src/config.txt'\) \} // Change the build directory // Don't need to reconfigure the task properties. These are automatically updated as the build directory changes buildDir = 'output'

 

1

// A task that generates a source file and writes the result to an output directory

2

class GenerateSource extends DefaultTask \{

3

 // The configuration file to use to generate the source file

4

 \@InputFile

5

 final RegularFileProperty configFile \= project.objects.fileProperty\(\)

6

7

 // The directory to write source files to

8

 \@OutputDirectory

9

 final DirectoryProperty outputDir \= project.objects.directoryProperty\(\)

10

11

 \@TaskAction

12

 def compile\(\) \{

13

 def inFile \= configFile.get\(\).asFile

14

 logger.quiet\("configuration file = \$inFile"\)

15

 def dir \= outputDir.get\(\).asFile

16

 logger.quiet\("output dir = \$dir"\)

17

 def className \= inFile.text.trim\(\)

18

 def srcFile \= new File\(dir, "\$\{className\}.java"\)

19

 srcFile.text \= "public class \$\{className\} \{ ... \}"

20

 \}

21

\}

22

23

// Create the source generation task

24

task generate\(type: GenerateSource\) \{

25

 // Configure the locations, relative to the project and build directories

26

 configFile \= project.layout.projectDirectory.file\('src/main/config.txt'\)

27

 outputDir \= project.layout.buildDirectory.dir\('generated-source'\)

28

29

 // Note that a \`File\` instance can be used as a convenience to set a location

30

 configFile \= file\('src/config.txt'\)

31

\}

32

33

// Change the build directory

34

// Don't need to reconfigure the task properties. These are automatically updated as the build directory changes

35

buildDir \= 'output'

输出**`gradle print`**

\$ gradle打印
 >任务：生成 配置文件= /home/user/gradle/samples/src/config.txt 输出目录= / home / user / gradle / samples / output / generated-source
 在0秒内成功建立 1个可执行的任务：1个已执行

本示例创建表示项目位置的提供程序，并通过[Project.getLayout（）]()和[ProjectLayout.getBuildDirectory（）]()和[ProjectLayout.getProjectDirectory（）]()构建目录。

要关闭循环，请注意，可以将a`DirectoryProperty`或一个简单的`Directory`转换为a`FileTree`，以允许使用[DirectoryProperty.getAsFileTree（）]()或[Directory.getAsFileTree（）]()查询目录中包含的文件和目录。此外，还可以通过[DirectoryProperty.files（Object ...）]()或[Directory.files（Object ...）]()从`DirectoryProperty`或中`Directory`创建`FileCollection`实例，该实例包含目录中包含的一组文件。

## [](#working_with_task_dependencies_in_lazy_properties)[使用任务输入和输出](#working_with_task_dependencies_in_lazy_properties)

许多内部版本将多个任务连接在一起，其中一个任务使用另一个任务的输出作为输入。为了使这项工作有效，我们将需要配置每个任务以知道在哪里寻找其输入并放置其输出，确保将生产和使用任务配置在相同的位置，并在任务之间附加任务依赖性。如果这些值中的任何一个可由用户配置或由多个插件配置，那么这将很麻烦且脆弱，因为需要按正确的顺序配置任务属性，并且随着值的更改，任务的位置和任务相关性必须保持同步。

该`Property`API使这种通过跟踪不只是价值的财产，这是我们已经看到的更容易，但也产生了价值，让您不必将其指定为好任务。例如，考虑以下带有生产者和消费者任务的插件，它们相互连接在一起：

例子4.隐式任务输入文件的依赖性

`Groovy``Kotlin`

build.gradle

class Producer extends DefaultTask \{ \@OutputFile final RegularFileProperty outputFile = project.objects.fileProperty\(\) \@TaskAction void produce\(\) \{ String message = 'Hello, World\!' def output = outputFile.get\(\).asFile output.text = message logger.quiet\("Wrote '\$\{message\}' to \$\{output\}"\) \} \} class Consumer extends DefaultTask \{ \@InputFile final RegularFileProperty inputFile = project.objects.fileProperty\(\) \@TaskAction void consume\(\) \{ def input = inputFile.get\(\).asFile def message = input.text logger.quiet\("Read '\$\{message\}' from \$\{input\}"\) \} \} def producer = tasks.register\("producer", Producer\) def consumer = tasks.register\("consumer", Consumer\) // Connect the producer task output to the consumer task input // Don't need to add a task dependency to the consumer task. This is automatically added consumer.configure \{ inputFile = producer.flatMap \{ it.outputFile \} \} // Set values for the producer lazily // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes producer.configure \{ outputFile = layout.buildDirectory.file\('file.txt'\) \} // Change the build directory. // Don't need to update producer.outputFile and consumer.inputFile. These are automatically updated as the build directory changes buildDir = 'output'

 

1

class Producer extends DefaultTask \{

2

 \@OutputFile

3

 final RegularFileProperty outputFile \= project.objects.fileProperty\(\)

4

5

 \@TaskAction

6

 void produce\(\) \{

7

 String message \= 'Hello, World\!'

8

 def output \= outputFile.get\(\).asFile

9

 output.text \= message

10

 logger.quiet\("Wrote '\$\{message\}' to \$\{output\}"\)

11

 \}

12

\}

13

14

class Consumer extends DefaultTask \{

15

 \@InputFile

16

 final RegularFileProperty inputFile \= project.objects.fileProperty\(\)

17

18

 \@TaskAction

19

 void consume\(\) \{

20

 def input \= inputFile.get\(\).asFile

21

 def message \= input.text

22

 logger.quiet\("Read '\$\{message\}' from \$\{input\}"\)

23

 \}

24

\}

25

26

def producer \= tasks.register\("producer", Producer\)

27

def consumer \= tasks.register\("consumer", Consumer\)

28

29

// Connect the producer task output to the consumer task input

30

// Don't need to add a task dependency to the consumer task. This is automatically added

31

consumer.configure \{

32

 inputFile \= producer.flatMap \{ it.outputFile \}

33

\}

34

35

// Set values for the producer lazily

36

// Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes

37

producer.configure \{

38

 outputFile \= layout.buildDirectory.file\('file.txt'\)

39

\}

40

41

// Change the build directory.

42

// Don't need to update producer.outputFile and consumer.inputFile. These are automatically updated as the build directory changes

43

buildDir \= 'output'

输出**`gradle consumer`**

\$ gradle消费者
 >任务：生产者 写了“你好，世界！” 到/home/user/gradle/samples/output/file.txt
 >任务：消费者 阅读“你好，世界！” 来自/home/user/gradle/samples/output/file.txt
 在0秒内成功建立 2个可执行任务：2个已执行

在上面的示例中，在定义任何位置之前已连接任务输出和输入。可以在执行任务之前的任何时间调用设置器，更改将自动影响所有相关的输入和输出属性。

在此示例中要注意的另一件重要事情是，没有任何明确的任务依赖性。通过`Providers`跟踪哪个任务产生其值来表示的任务输出，并将它们用作任务输入将隐式添加正确的任务依赖性。

隐式任务依赖项也适用于不是文件的输入属性。

例子5.隐式任务输入依赖

`Groovy``Kotlin`

build.gradle

class Producer extends DefaultTask \{ \@OutputFile final RegularFileProperty outputFile = project.objects.fileProperty\(\) \@TaskAction void produce\(\) \{ String message = 'Hello, World\!' def output = outputFile.get\(\).asFile output.text = message logger.quiet\("Wrote '\$\{message\}' to \$\{output\}"\) \} \} class Consumer extends DefaultTask \{ \@Input final Property\<String> message = project.objects.property\(String\) \@TaskAction void consume\(\) \{ logger.quiet\(message.get\(\)\) \} \} task producer\(type: Producer\) task consumer\(type: Consumer\) // Connect the producer task output to the consumer task input // Don't need to add a task dependency to the consumer task. This is automatically added consumer.message = producer.outputFile.map \{ it.asFile.text \} // Set values for the producer lazily producer.outputFile = layout.buildDirectory.file\('file.txt'\)

 

1

class Producer extends DefaultTask \{

2

 \@OutputFile

3

 final RegularFileProperty outputFile \= project.objects.fileProperty\(\)

4

5

 \@TaskAction

6

 void produce\(\) \{

7

 String message \= 'Hello, World\!'

8

 def output \= outputFile.get\(\).asFile

9

 output.text \= message

10

 logger.quiet\("Wrote '\$\{message\}' to \$\{output\}"\)

11

 \}

12

\}

13

14

class Consumer extends DefaultTask \{

15

 \@Input

16

 final Property\<String\> message \= project.objects.property\(String\)

17

18

 \@TaskAction

19

 void consume\(\) \{

20

 logger.quiet\(message.get\(\)\)

21

 \}

22

\}

23

24

task producer\(type: Producer\)

25

task consumer\(type: Consumer\)

26

27

// Connect the producer task output to the consumer task input

28

// Don't need to add a task dependency to the consumer task. This is automatically added

29

consumer.message \= producer.outputFile.map \{ it.asFile.text \}

30

31

// Set values for the producer lazily

32

producer.outputFile \= layout.buildDirectory.file\('file.txt'\)

输出**`gradle consumer`**

\$ gradle消费者
 >任务：生产者 写了“你好，世界！” 到/home/user/gradle/samples/build/file.txt
 >任务：消费者 你好，世界！
 在0秒内成功建立 2个可执行任务：2个已执行

## [](#working_with_collections)[使用收藏](#working_with_collections)

Gradle提供了两种惰性属性来帮助配置`Collection`属性。这些文件的工作原理与其他任何`Provider`文件一样，并且与文件提供程序一样，它们具有其他建模功能：

* 对于`List`值，该接口称为[ListProperty]()。您可以`ListProperty`使用[ObjectFactory.listProperty（Class）]()并指定元素类型来创建新的。
* 对于`Set`值，该接口称为[SetProperty]()。您可以`SetProperty`使用[ObjectFactory.setProperty（Class）]()并指定元素类型来创建新的。

这种类型的属性使您可以使用[HasMultipleValues.set（Iterable）]()和[HasMultipleValues.set（Provider）]()覆盖整个集合值，或通过各种`add`方法添加新元素：

* [HasMultipleValues.add（T）]()：将单个元素添加到集合中
* [HasMultipleValues.add（Provider）]()：将延迟计算的元素添加到集合中
* [HasMultipleValues.addAll（Provider）]()：将延迟计算的元素集合添加到列表中

就像every一样`Provider`，在调用[Provider.get（）]()时计算集合。以下示例显示了运行中的[ListProperty]()：

例子6.列表属性

`Groovy``Kotlin`

build.gradle

class Producer extends DefaultTask \{ \@OutputFile final RegularFileProperty outputFile = project.objects.fileProperty\(\) \@TaskAction void produce\(\) \{ String message = 'Hello, World\!' def output = outputFile.get\(\).asFile output.text = message logger.quiet\("Wrote '\$\{message\}' to \$\{output\}"\) \} \} class Consumer extends DefaultTask \{ \@InputFiles final ListProperty\<RegularFile> inputFiles = project.objects.listProperty\(RegularFile\) \@TaskAction void consume\(\) \{ inputFiles.get\(\).each \{ inputFile -> def input = inputFile.asFile def message = input.text logger.quiet\("Read '\$\{message\}' from \$\{input\}"\) \} \} \} task producerOne\(type: Producer\) task producerTwo\(type: Producer\) task consumer\(type: Consumer\) // Connect the producer task outputs to the consumer task input // Don't need to add task dependencies to the consumer task. These are automatically added consumer.inputFiles.add\(producerOne.outputFile\) consumer.inputFiles.add\(producerTwo.outputFile\) // Set values for the producer tasks lazily // Don't need to update the consumer.inputFiles property. This is automatically updated as producer.outputFile changes producerOne.outputFile = layout.buildDirectory.file\('one.txt'\) producerTwo.outputFile = layout.buildDirectory.file\('two.txt'\) // Change the build directory. // Don't need to update the task properties. These are automatically updated as the build directory changes buildDir = 'output'

 

1

class Producer extends DefaultTask \{

2

 \@OutputFile

3

 final RegularFileProperty outputFile \= project.objects.fileProperty\(\)

4

5

 \@TaskAction

6

 void produce\(\) \{

7

 String message \= 'Hello, World\!'

8

 def output \= outputFile.get\(\).asFile

9

 output.text \= message

10

 logger.quiet\("Wrote '\$\{message\}' to \$\{output\}"\)

11

 \}

12

\}

13

14

class Consumer extends DefaultTask \{

15

 \@InputFiles

16

 final ListProperty\<RegularFile\> inputFiles \= project.objects.listProperty\(RegularFile\)

17

18

 \@TaskAction

19

 void consume\(\) \{

20

 inputFiles.get\(\).each \{ inputFile \->

21

 def input \= inputFile.asFile

22

 def message \= input.text

23

 logger.quiet\("Read '\$\{message\}' from \$\{input\}"\)

24

 \}

25

 \}

26

\}

27

28

task producerOne\(type: Producer\)

29

task producerTwo\(type: Producer\)

30

task consumer\(type: Consumer\)

31

32

// Connect the producer task outputs to the consumer task input

33

// Don't need to add task dependencies to the consumer task. These are automatically added

34

consumer.inputFiles.add\(producerOne.outputFile\)

35

consumer.inputFiles.add\(producerTwo.outputFile\)

36

37

// Set values for the producer tasks lazily

38

// Don't need to update the consumer.inputFiles property. This is automatically updated as producer.outputFile changes

39

producerOne.outputFile \= layout.buildDirectory.file\('one.txt'\)

40

producerTwo.outputFile \= layout.buildDirectory.file\('two.txt'\)

41

42

// Change the build directory.

43

// Don't need to update the task properties. These are automatically updated as the build directory changes

44

buildDir \= 'output'

输出**`gradle consumer`**

\$ gradle消费者
 >任务：生产者一个 写了“你好，世界！” 到/home/user/gradle/samples/output/one.txt
 >任务：生产者2 写了“你好，世界！” 到/home/user/gradle/samples/output/two.txt
 >任务：消费者 阅读“你好，世界！” 来自/home/user/gradle/samples/output/one.txt 阅读“你好，世界！” 来自/home/user/gradle/samples/output/two.txt
 在0秒内成功建立 3个可执行的任务：3个已执行

## [](#working_with_maps)[使用地图](#working_with_maps)

Gradle提供了一个惰性[MapProperty]()类型，以允许`Map`配置值。您可以`MapProperty`使用[ObjectFactory.mapProperty（Class，Class）]()创建一个实例。

与其他属性类型相似，一个`MapProperty`具有[set（）]()方法，可用于指定该属性的值。还有一些其他方法可以将具有惰性值的条目添加到映射中。

例子7.地图属性

`Groovy``Kotlin`

build.gradle

class Generator extends DefaultTask \{ \@Input final MapProperty\<String, Integer> properties = project.objects.mapProperty\(String, Integer\) \@TaskAction void generate\(\) \{ properties.get\(\).each \{ key, value -> logger.quiet\("\$\{key\} = \$\{value\}"\) \} \} \} // Some values to be configured later def b = 0 def c = 0 task generate\(type: Generator\) \{ properties.put\("a", 1\) // Values have not been configured yet properties.put\("b", providers.provider \{ b \}\) properties.putAll\(providers.provider \{ \[c: c, d: c + 1\] \}\) \} // Configure the values. There is no need to reconfigure the task b = 2 c = 3

 

1

class Generator extends DefaultTask \{

2

 \@Input

3

 final MapProperty\<String, Integer\> properties \= project.objects.mapProperty\(String, Integer\)

4

5

 \@TaskAction

6

 void generate\(\) \{

7

 properties.get\(\).each \{ key, value \->

8

 logger.quiet\("\$\{key\} = \$\{value\}"\)

9

 \}

10

 \}

11

\}

12

13

// Some values to be configured later

14

def b \= 0

15

def c \= 0

16

17

task generate\(type: Generator\) \{

18

 properties.put\("a", 1\)

19

 // Values have not been configured yet

20

 properties.put\("b", providers.provider \{ b \}\)

21

 properties.putAll\(providers.provider \{ \[c: c, d: c + 1\] \}\)

22

\}

23

24

// Configure the values. There is no need to reconfigure the task

25

b \= 2

26

c \= 3

输出**`gradle consumer`**

\$ gradle生成
 >任务：生成 a = 1 b = 2 c = 3 d = 4
 在0秒内成功建立 1个可执行的任务：1个已执行

## [](#applying_conventions)[将约定应用于属性](#applying_conventions)

如果尚未为该属性配置任何值，通常您希望将某些_约定_或默认值应用于该属性。您可以`convention()`为此使用方法。此方法接受一个值或a`Provider`，它将被用作该值，直到配置了其他值。

例子8.属性约定

`Groovy``Kotlin`

build.gradle

task show \{ doLast \{ def property = objects.property\(String\) // Set a convention property.convention\("convention 1"\) println\("value = " + property.get\(\)\) // Can replace the convention property.convention\("convention 2"\) println\("value = " + property.get\(\)\) property.set\("value"\) // Once a value is set, the convention is ignored property.convention\("ignored convention"\) println\("value = " + property.get\(\)\) \} \}

 

1

task show \{

2

 doLast \{

3

 def property \= objects.property\(String\)

4

5

 // Set a convention

6

 property.convention\("convention 1"\)

7

 println\("value = " + property.get\(\)\)

8

9

 // Can replace the convention

10

 property.convention\("convention 2"\)

11

 println\("value = " + property.get\(\)\)

12

13

 property.set\("value"\)

14

15

 // Once a value is set, the convention is ignored

16

 property.convention\("ignored convention"\)

17

 println\("value = " + property.get\(\)\)

18

 \}

19

\}

输出**`gradle show`**

\$ gradle显示
 >任务：显示 值=约定1 值=约定2 值=值
 在0秒内成功建立 1个可执行的任务：1个已执行

## [](#unmodifiable_property)[使财产不可修改](#unmodifiable_property)

任务或项目的大多数属性旨在由插件或构建脚本配置，然后将所得的值用于做有用的事情。例如，为编译任务指定输出目录的属性可以从插件指定的值开始，然后构建脚本可能将其更改为某个自定义位置，然后任务在运行时使用该值。但是，一旦任务开始运行，我们希望防止对该属性进行任何进一步的更改。这样，我们可以避免使用不同属性的值来避免由不同使用者产生的错误，例如任务操作或Gradle的最新检查或构建缓存或其他任务。

惰性属性提供了几种方法，您可以在配置值后禁止更改其值。所述[finalizeValue（）]()方法计算_最终_的属性值，并且防止到属性进一步的修改。当属性的值来自时`Provider`，将查询提供程序的当前值，结果将成为属性的最终值。此最终值将替换提供者，并且该属性不再跟踪提供者的值。调用此方法还会使属性实例不可修改，并且任何进一步尝试更改属性值的尝试都会失败。当任务开始执行时，Gradle会自动使任务的属性最终化。

所述[finalizeValueOnRead（）]()方法是类似的，不同之处在于，不计算该属性的最终值，直到属性的值被查询。换句话说，该方法根据需要延迟计算最终值，而`finalizeValue()`急切地计算最终值。当值的计算成本可能很高或尚未进行配置时，可以使用此方法，但是您还想确保该属性的所有使用者在查询该值时都看到相同的值。

## [](#lazy_configuration_faqs)[指导方针](#lazy_configuration_faqs)

本节将介绍成功使用Provider API的准则。要查看这些指导原则，请查看[gradle-site-plugin](https://github.com/gradle/gradle-site-plugin)，这是一个Gradle插件，展示了已建立的插件开发技术和实践。

* 该[物业]()和[供应商]()类型有所有你需要查询或配置的值重载。因此，您应该遵循以下准则：  

  * 对于可配置的属性，直接通过单个getter公开该[Property]()。
  * 对于不可配置的属性，请直接通过单个getter公开[提供程序]()。
* 避免简化，例如来电`obj.getProperty().get()`，并`obj.getProperty().set(T)`在你的代码通过引入额外的getter和setter。
* 在将插件迁移为使用提供程序时，请遵循以下准则：  

  * 如果是新属性，请使用单个getter将其公开为[Property]()或[Provider]()。
  * 如果正在孵化，请将其更改为使用单个吸气剂使用[属性]()或[提供程序]()。
  * 如果它是稳定的属性，请添加新的[属性]()或[提供者，]()并弃用旧的[属性]()或[提供者]()。您应将旧的吸气剂/装料器适当地连接到新的属性中。

## [](#lazy_configuration_roadmap)[未来发展](#lazy_configuration_roadmap)

展望未来，新属性将使用提供者API。Groovy Gradle DSL添加了便捷方法，以使在构建脚本中对提供程序的使用几乎是透明的。现有任务将根据需要并以向后兼容的方式将其现有的“原始”属性替换为提供程序。新任务将使用提供程序API设计。

## [](#lazy_configuration_reference)[提供程序文件API参考](#lazy_configuration_reference)

将这些类型用于_只读_值：

[提供者]()\<[RegularFile]()\>

磁盘上的文件

工厂工厂

* [Provider.map（Transformer）]()。
* [Provider.flatMap（Transformer）]()。
* [DirectoryProperty.file（String）]()

[提供者]()\<[目录]()\>

磁盘上的目录

工厂工厂

* [Provider.map（Transformer）]()。
* [Provider.flatMap（Transformer）]()。
* [DirectoryProperty.dir（字符串）]()

[文件集]()

非结构化文件集合

工厂工厂

* [Project.files（Object \[\]）]()
* [ProjectLayout.files（Object ...）]()
* [DirectoryProperty.files（Object ...）]()

[文件树]()

文件层次结构

工厂工厂

* [Project.fileTree（Object）]()将产生[ConfigurableFileTree]()，或者您可以使用[Project.zipTree（Object）]()和[Project.tarTree（Object）]()
* [DirectoryProperty.getAsFileTree（）]()

## [](#property_files_api_reference)[属性文件API参考](#property_files_api_reference)

将这些类型用于_可变_值：

[RegularFileProperty]()

磁盘上的文件

工厂工厂

* [ObjectFactory.fileProperty（）]()

[目录属性]()

磁盘上的目录

工厂工厂

* [ObjectFactory.directoryProperty（）]()

[ConfigurableFileCollection]()

非结构化文件集合

工厂工厂

* [ObjectFactory.fileCollection（）]()

[可配置文件树]()

文件层次结构

工厂工厂

* [ObjectFactory.fileTree（）]()

[SourceDirectorySet]()

源目录的层次结构

工厂工厂

* [ObjectFactory.sourceDirectorySet（String，String）]()

## [](#lazy_collections_api_reference)[惰性集合API参考](#lazy_collections_api_reference)

将这些类型用于_可变_值：

[ListProperty \<T>]()

属性值为`List<T>`

工厂工厂

* [ObjectFactory.listProperty（Class）]()

[SetProperty \<T>]()

属性值为`Set<T>`

工厂工厂

* [ObjectFactory.setProperty（Class）]()

## [](#lazy_objects_api_reference)[惰性对象API参考](#lazy_objects_api_reference)

将这些类型用于_只读_值：

[提供者\<T>]()

属性的值是的一个实例`T`

工厂工厂

* [Provider.map（Transformer）]()。
* [Provider.flatMap（Transformer）]()。
* [ProviderFactory.provider（Callable）]()。总是比其他方法更喜欢其他工厂方法之一。

将这些类型用于_可变_值：

[属性\<T>]()

属性的值是的一个实例`T`

工厂工厂

* [ObjectFactory.property（Class）]()