 无标题 <style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body { padding-left: 48px; padding-right: 48px;}</style><style id="wiz_code_style">.wiz-editor-body .wiz-code-container{position: relative; padding:8px 0; margin: 5px 0;text-indent:0; text-align:left;}.CodeMirror {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; color: black; font-size: 10.5pt; font-size: 0.875rem}.wiz-editor-body .wiz-code-container .CodeMirror div {margin-top: 0; margin-bottom: 0;}.CodeMirror-lines {padding: 4px 0;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {padding: 0 4px;}.CodeMirror pre.CodeMirror-line {min-height: 24px;}.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {background-color: white;}.CodeMirror-gutters {border-right: 1px solid #ddd; background-color: #f7f7f7; white-space: nowrap;}.CodeMirror-linenumbers {}.CodeMirror-linenumber {padding: 0 3px 0 5px; min-width: 20px; text-align: right; color: #999; white-space: nowrap;}.CodeMirror-guttermarker {color: black;}.CodeMirror-guttermarker-subtle {color: #999;}.CodeMirror-cursor {border-left: 1px solid black; border-right: none; width: 0;}.CodeMirror div.CodeMirror-secondarycursor {border-left: 1px solid silver;}.cm-fat-cursor .CodeMirror-cursor {width: auto; border: 0 !important; background: #7e7;}.cm-fat-cursor div.CodeMirror-cursors {z-index: 1;}.cm-fat-cursor-mark {background-color: rgba(20, 255, 20, 0.5);-webkit-animation: blink 1.06s steps(1) infinite;-moz-animation: blink 1.06s steps(1) infinite;animation: blink 1.06s steps(1) infinite;}.cm-animate-fat-cursor {width: auto; border: 0; -webkit-animation: blink 1.06s steps(1) infinite; -moz-animation: blink 1.06s steps(1) infinite; animation: blink 1.06s steps(1) infinite; background-color: #7e7;}@-moz-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@-webkit-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}.CodeMirror-overwrite .CodeMirror-cursor {}.cm-tab { display: inline-block; text-decoration: inherit; }.CodeMirror-rulers {position: absolute; left: 0; right: 0; top: -50px; bottom: -20px; overflow: hidden;}.CodeMirror-ruler {border-left: 1px solid #ccc; top: 0; bottom: 0; position: absolute;}.cm-s-default .cm-header {color: blue;}.cm-s-default .cm-quote {color: #090;}.cm-negative {color: #d44;}.cm-positive {color: #292;}.cm-header, .cm-strong {font-weight: bold;}.cm-em {font-style: italic;}.cm-link {text-decoration: underline;}.cm-strikethrough {text-decoration: line-through;}.cm-s-default .cm-keyword {color: #708;}.cm-s-default .cm-atom {color: #219;}.cm-s-default .cm-number {color: #164;}.cm-s-default .cm-def {color: #00f;}.cm-s-default .cm-variable,.cm-s-default .cm-punctuation,.cm-s-default .cm-property,.cm-s-default .cm-operator {}.cm-s-default .cm-variable-2 {color: #05a;}.cm-s-default .cm-variable-3 {color: #085;}.cm-s-default .cm-comment {color: #a50;}.cm-s-default .cm-string {color: #a11;}.cm-s-default .cm-string-2 {color: #f50;}.cm-s-default .cm-meta {color: #555;}.cm-s-default .cm-qualifier {color: #555;}.cm-s-default .cm-builtin {color: #30a;}.cm-s-default .cm-bracket {color: #997;}.cm-s-default .cm-tag {color: #170;}.cm-s-default .cm-attribute {color: #00c;}.cm-s-default .cm-hr {color: #999;}.cm-s-default .cm-link {color: #00c;}.cm-s-default .cm-error {color: #f00;}.cm-invalidchar {color: #f00;}.CodeMirror-composing { border-bottom: 2px solid; }div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }.CodeMirror-activeline-background {background: #e8f2ff;}.CodeMirror {position: relative; background: #f5f5f5;}.CodeMirror-scroll {overflow: hidden !important; margin-bottom: 0; margin-right: -30px; padding: 16px 30px 16px 0; outline: none; position: relative;}.CodeMirror-sizer {position: relative; border-right: 30px solid transparent;}.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {position: absolute; z-index: 6; display: none;}.CodeMirror-vscrollbar {right: 0; top: 0; overflow-x: hidden; overflow-y: scroll;}.CodeMirror-hscrollbar {bottom: 0; left: 0 !important; overflow-y: hidden; overflow-x: scroll;pointer-events: auto !important;outline: none;}.CodeMirror-scrollbar-filler {right: 0; bottom: 0;}.CodeMirror-gutter-filler {left: 0; bottom: 0;}.CodeMirror-gutters {position: absolute; left: 0; top: 0; min-height: 100%; z-index: 3;}.CodeMirror-gutter {white-space: normal; height: 100%; display: inline-block; vertical-align: top; margin-bottom: -30px;}.CodeMirror-gutter-wrapper {position: absolute; z-index: 4; background: none !important; border: none !important;}.CodeMirror-gutter-background {position: absolute; top: 0; bottom: 0; z-index: 4;}.CodeMirror-gutter-elt {position: absolute; cursor: default; z-index: 4;}.CodeMirror-gutter-wrapper ::selection { background-color: transparent }.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }.CodeMirror-lines {cursor: text; min-height: 1px;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {-moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0; border-width: 0; background: transparent; font-family: inherit; font-size: inherit; margin: 0; white-space: pre; word-wrap: normal; line-height: inherit; color: inherit; z-index: 2; position: relative; overflow: visible; -webkit-tap-highlight-color: transparent; -webkit-font-variant-ligatures: contextual; font-variant-ligatures: contextual;}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like {word-wrap: break-word; white-space: pre-wrap; word-break: normal;}.CodeMirror-linebackground {position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;}.CodeMirror-linewidget {position: relative; z-index: 2; padding: 0.1px;}.CodeMirror-widget {}.CodeMirror-rtl pre { direction: rtl; }.CodeMirror-code {outline: none;}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {-moz-box-sizing: content-box; box-sizing: content-box;}.CodeMirror-measure {position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;}.CodeMirror-cursor {position: absolute; pointer-events: none;}.CodeMirror-measure pre { position: static; }div.CodeMirror-cursors {visibility: hidden; position: relative; z-index: 3;}div.CodeMirror-dragcursors {visibility: visible;}.CodeMirror-focused div.CodeMirror-cursors {visibility: visible;}.CodeMirror-selected { background: #d9d9d9; }.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }.CodeMirror-crosshair { cursor: crosshair; }.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }.cm-searching {background: #ffa; background: rgba(255, 255, 0, .4);}.cm-force-border { padding-right: .1px; }@media print { .CodeMirror div.CodeMirror-cursors {visibility: hidden;}}.cm-tab-wrap-hack:after { content: ""; }span.CodeMirror-selectedtext { background: none; }.CodeMirror-activeline-background, .CodeMirror-selected {transition: visibility 0ms 100ms;}.CodeMirror-blur .CodeMirror-activeline-background, .CodeMirror-blur .CodeMirror-selected {visibility:hidden;}.CodeMirror-blur .CodeMirror-matchingbracket {color:inherit !important;outline:none !important;text-decoration:none !important;}.CodeMirror-sizer {min-height:auto !important;}</style>

# 验证依赖关系

内容

* [启用依赖性验证](#sub:enabling-verification)
* [验证依赖项校验和](#sec:checksum-verification)
* [验证依赖项签名](#sec:signature-verification)
* [了解签名验证](#sec:understanding-signature-verification)
* [对依赖性验证进行故障排除](#sec:troubleshooting-verification)
* [仅对某些配置禁用依赖性验证](#sub:disabling-specific-verification)

使用外部依赖关系和第三方存储库上发布的插件会使您的构建面临风险。特别是，您需要知道哪些二进制文件是传递的，以及它们是否合法。为了减轻安全风险并避免在项目中集成受损的依赖关系，Gradle支持_依赖关系验证_。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-important"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>本质上，依赖关系验证是一个使用不便的功能。</font><font>这意味着，每当您要更新依赖项时，构建都可能会失败。</font><font>这意味着合并分支将变得更加困难，因为每个分支可以具有不同的依赖关系。</font><font>这意味着您很想将其关闭。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>那你为什么要打扰？</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>依赖关系验证是关于</font></font><strong><font><font>对</font></font></strong><font><font>所获得和所</font><font>交付产品的</font><strong><font>信任</font></strong><font>。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>如果没有依赖关系验证，攻击者很容易破坏您的供应链。</font><font>现实世界中有许多通过添加恶意依赖关系而受到破坏的工具的示例。</font><font>依赖性验证旨在通过迫使您确保构建中包含的构件与您期望的构件相同，从而保护自己免受那些攻击。</font><font>但是，这并不意味着阻止您包括</font></font><em style="font-style:italic;"><font><font>易受攻击的</font></font></em><font><font>依赖项。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>很难在安全性和便利性之间找到适当的平衡，但是Gradle会尝试让您为您选择“正确的级别”。</font></font></p></div></td></tr></tbody></table>

依赖性验证包含两个不同的互补操作：

* _校验和验证_，允许断言依赖项的完整性
* _签名验证_，可以断言依赖项的来源

Gradle开箱即用支持校验和和签名验证，但默认情况下不执行任何依赖关系验证。本节将指导您根据需要正确配置依赖项验证。

此功能可用于：

* 检测受损的依赖关系
* 检测被入侵的插件
* 在本地依赖项缓存中检测被篡改的依赖项

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>依赖性验证是一个孵化功能：详细信息可能会更改。</font></font></p></div></td></tr></tbody></table>

## [](#sub:enabling-verification)[启用依赖性验证](#sub:enabling-verification)

### [](#sub:verification-metadata)[验证元数据文件](#sub:verification-metadata)

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>当前，依赖关系验证元数据的唯一来源是此XML配置文件。</font><font>Gradle的未来版本可能包括其他来源（例如，通过外部服务）。</font></font></p></div></td></tr></tbody></table>

一旦发现用于依赖性验证的配置文件，就会自动启用依赖性验证。此配置文件位于`$PROJECT_ROOT/gradle/verification-metadata.xml`。该文件至少包含以下内容：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<verify-metadata>true\</verify-metadata> \<verify-signatures>false\</verify-signatures> \</configuration> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<verify-metadata\>true\</verify-metadata\>

5

 \<verify-signatures\>false\</verify-signatures\>

6

 \</configuration\>

7

\</verification-metadata\>

这样做，Gradle将使用[校验和](#sec:checksum-verification)验证所有工件，但不会验证[签名](#sec:signature-verification)。Gradle将验证使用其依赖项管理引擎下载的任何工件，包括但不限于：

* 构建期间使用的工件文件（例如jar文件，zip等）
* 元数据工件（POM文件，Ivy描述符，Gradle模块元数据）
* 插件（项目和设置插件）
* 使用高级依赖关系解析API解析的工件

Gradle_不会_验证变化的依赖关系（尤其是`SNAPSHOT`依赖关系），也_不会_验证本地产生的工件（通常是在构建本身过程中产生的jar），因为它们的校验和和签名本质上总是会变化的。

使用这种最小的配置文件，使用_任何_外部依赖项或插件的项目将立即开始失败，因为它不包含任何校验和。

依赖性验证配置是_全局的_：单个文件用于配置整个构建的验证。特别是，（子）项目和都使用相同的文件`buildSrc`。

因此，一种简单的入门方法是为现有构建生成最小的配置。

### [](#sec:verification-console-output)[配置控制台输出](#sec:verification-console-output)

默认情况下，如果依赖项验证失败，则Gradle将生成有关验证失败的小摘要以及包含有关失败的完整信息的HTML报告。如果您的环境阻止您读取此HTML报告文件（例如，如果您在CI上运行构建并且获取远程工件并不容易），则Gradle提供了一种选择加入详细控制台报告的方法。为此，您需要将此Gradle属性添加到`gradle.properties`文件中：

org.gradle.dependency.verification.console =详细

### [](#sec:bootstrapping-verification)[自举依赖性验证](#sec:bootstrapping-verification)

值得一提的是，虽然Gradle可以为您生成依赖项验证文件，但是您应该始终检查为您生成的Gradle，因为您的构建可能_已经_包含受损的依赖项，而您对此一无所知。请参阅相应的[校验和验证](#sec:checksum-verification)或[签名验证](#sec:signature-verification)部分以获取更多信息。

如果您打算使用[签名验证](#sec:signature-verification)，请另外阅读文档的[相应部分](#sec:bootstrapping-signature-verification)。

引导程序既可以用来从头开始创建文件，也可以使用新信息来_更新_现有文件。因此，建议您在启动引导程序后始终使用相同的参数。

可以使用以下CLI指令来生成依赖关系验证文件：

gradle --write-verification-metadata sha256帮助

该`write-verification-metadata`标志要求您要生成或用于[签名](#sec:signature-verification)的[校验和](#sec:checksum-verification)的列表。`pgp`[](#sec:signature-verification)

执行此命令行将使Gradle执行以下操作：

* 解决所有[可解决的配置]()，包括：  

  * 根项目中的配置
  * 所有子项目的配置
  * 来自的配置`buildSrc`
  * 包含的构建配置
  * 插件使用的配置
* 下载在解析过程中发现的所有工件
* 计算请求的校验和，并可能根据您的要求验证签名
* 在构建结束时，生成配置文件，其中将包含推断的_验证元数据_

因此，该`verification-metadata.xml`文件将在后续构建中用于验证依赖性。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>Gradle</font></font><em style="font-style:italic;"><font><font>无法通过</font></font></em><font><font>这种方式发现</font><font>某些依赖项</font><font>。</font><font>特别是，您会注意到上面的CLI使用该</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">help</code><font><font>任务。</font><font>如果您不指定任何任务，Gradle也会自动运行默认任务并在构建结束时生成配置文件。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>不同之处在于Gradle</font></font><em style="font-style:italic;"><font><font>可能会</font></font></em><font><font>发现更多依赖项和工件，具体取决于您执行的任务。</font><font>实际上，Gradle无法自动发现</font></font><em style="font-style:italic;"><font><font>分离的配置</font></font></em><font><font>，这些</font><em style="font-style:italic;"><font>分离的配置</font></em><font>基本上是作为任务执行的内部实现细节解析的依赖关系图：由于它们有效地依赖于它们，因此不特别声明为任务的输入。执行时任务的配置。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>一个很好的开始方法是使用最简单的任务，</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">help</code><font><font>该</font><font>任务</font><font>将尽可能多地发现，并且如果后续构建因验证错误而失败，则可以使用适当的任务重新执行生成，以“发现”更多的依赖性。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>Gradle不会验证使用自己的HTTP客户端的插件的校验和或签名。</font><font>只有使用Gradle提供的基础结构来执行请求的插件才能看到其请求已验证。</font></font></p></div></td></tr></tbody></table>

如果使用包含的版本：

* _当前_版本的配置文件用于验证
* 因此，如果包含的内部版本本身使用验证，则会忽略其配置，而使用当前版本
* 这意味着包含构建的工作方式与升级依赖项相似：它可能需要您更新当前的验证元数据

### [](#sec:verification-dry-mode)[使用干燥模式](#sec:verification-dry-mode)

默认情况下，引导是增量的，这意味着如果您多次运行它，信息会_添加_到文件中，尤其是您可以依靠VCS来检查差异。在某些情况下，您只想_查看_生成的验证元数据文件的外观，而无需实际更改现有的覆盖或覆盖它。

为此，您可以添加`--dry-run`：

gradle --write-verification-metadata sha256帮助--dry-run

然后`verification-metadata.xml`，将生成一个名为的_新_文件，而不是生成文件`verification-metadata.dryrun.xml`。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>由于</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">--dry-run</code><font><font>不执行任务，因此速度更快，但是会错过任务执行时发生的任何解决方案。</font></font></p></div></td></tr></tbody></table>

### [](#sec:disabling-metadata-verification)[禁用元数据验证](#sec:disabling-metadata-verification)

默认情况下，Gradle不仅会验证工件（罐子，...），还会验证与这些工件关联的元数据（通常是POM文件）。验证这一点可以确保最大程度的安全性：元数据文件通常会告诉您将包括哪些传递性依赖项，因此受损的元数据文件可能会导致在图形中引入不希望的依赖项。但是，由于所有工件都经过验证，因此您通常很容易发现这些工件，因为它们会导致校验和验证失败（校验和会从验证元数据中_丢失_）。因为元数据验证会大大增加配置文件的大小，所以您可能要禁用元数据验证。如果您了解这样做的风险，请将`<verify-metadata>`标志设置为`false`在配置文件中：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<verify-metadata>false\</verify-metadata> \<verify-signatures>false\</verify-signatures> \</configuration> \<\!-- the rest of this file doesn't need to declare anything about metadata files --> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<verify-metadata\>false\</verify-metadata\>

5

 \<verify-signatures\>false\</verify-signatures\>

6

 \</configuration\>

7

 \<\!-- the rest of this file doesn't need to declare anything about metadata files -->

8

\</verification-metadata\>

## [](#sec:checksum-verification)[验证依赖项校验和](#sec:checksum-verification)

校验和验证使您可以确保工件的完整性。这是Gradle可以确保您使用的工件不受篡改的最简单的操作。

Gradle支持MD5，SHA1，SHA-256和SHA-512校验和。但是，如今仅SHA-256和SHA-512校验和被认为是安全的。

### [](#adding_the_checksum_for_an_artifact)[添加工件的校验和](#adding_the_checksum_for_an_artifact)

外部组件由GAV坐标标识，然后由每个工件的文件名标识。要声明工件的校验和，您需要在验证元数据文件中添加相应的部分。例如，声明[Apache PDFBox](https://pdfbox.apache.org)的校验和。GAV坐标为：

* 组`org.apache.pdfbox`
* 名称`pdfbox`
* 版`2.0.17`

使用此依赖项将触发2个不同文件的下载：

* `pdfbox-2.0.17.jar`这是主要的神器
* `pdfbox-2.0.17.pom`这是与此工件关联的元数据文件

因此，您需要声明它们的校验和（除非[禁用了元数据验证](#sec:disabling-metadata-verification)）：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<verify-metadata>true\</verify-metadata> \<verify-signatures>false\</verify-signatures> \</configuration> \<components> \<component group="org.apache.pdfbox" name="pdfbox" version="2.0.17"> \<artifact name="pdfbox-2.0.17.jar"> \<sha512 value="7e11e54a21c395d461e59552e88b0de0ebaf1bf9d9bcacadf17b240d9bbc29bf6beb8e36896c186fe405d287f5d517b02c89381aa0fcc5e0aa5814e44f0ab331" origin="PDFBox Official site \(https://pdfbox.apache.org/download.cgi\)"/> \</artifact> \<artifact name="pdfbox-2.0.17.pom"> \<sha512 value="82de436b38faf6121d8d2e71dda06e79296fc0f7bc7aba0766728c8d306fd1b0684b5379c18808ca724bf91707277eba81eb4fe19518e99e8f2a56459b79742f" origin="Generated by Gradle"/> \</artifact> \</component> \</components> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<verify-metadata\>true\</verify-metadata\>

5

 \<verify-signatures\>false\</verify-signatures\>

6

 \</configuration\>

7

 \<components\>

8

 \<component group\="org.apache.pdfbox" name\="pdfbox" version\="2.0.17"\>

9

 \<artifact name\="pdfbox-2.0.17.jar"\>

10

 \<sha512 value\="7e11e54a21c395d461e59552e88b0de0ebaf1bf9d9bcacadf17b240d9bbc29bf6beb8e36896c186fe405d287f5d517b02c89381aa0fcc5e0aa5814e44f0ab331" origin\="PDFBox Official site \(https://pdfbox.apache.org/download.cgi\)"/>

11

 \</artifact\>

12

 \<artifact name\="pdfbox-2.0.17.pom"\>

13

 \<sha512 value\="82de436b38faf6121d8d2e71dda06e79296fc0f7bc7aba0766728c8d306fd1b0684b5379c18808ca724bf91707277eba81eb4fe19518e99e8f2a56459b79742f" origin\="Generated by Gradle"/>

14

 \</artifact\>

15

 \</component\>

16

 \</components\>

17

\</verification-metadata\>

### [](#where_to_get_checksums_from)[从哪里获得校验和？](#where_to_get_checksums_from)

通常，校验和与工件一起在公共存储库中发布。但是，如果某个依赖关系在存储库中遭到破坏，则其校验和可能也会受到影响，因此，从另一个位置（通常是库本身的网站）获取校验和是一个好习惯。

实际上，在与托管工件本身的服务器_不同的服务器_上发布工件的校验和是一种很好的安全实践：很难破坏存储库_和_官方网站上的库。

在上面的示例中，校验和在网站上发布了JAR，但未发布POM文件。这就是为什么[让Gradle生成校验](#sec:bootstrapping-verification)和并通过仔细检查生成的文件进行验证通常更容易的原因。

在这个例子中，不仅可以，我们检查校验是正确的，但我们也能找到它的官方网站，这就是为什么我们改变的标签上`origin`，从`Generated by Gradle`到`PDFBox Official site`。更改可以`origin`使用户了解您的构建的可信度。

有趣的是，使用`pdfbox`所需的资源_远_不止这两个工件，因为它还会带来可传递的依赖关系。如果依赖性验证文件仅包含您使用的主要工件的校验和，则构建将失败，并显示如下错误：

任务'：compileJava'的执行失败。 >配置'：compileClasspath'的依赖关系验证失败： -在存储库“ MavenRepo”中的工件commons-logging-1.2.jar（commons-logging：commons-logging：1.2）上：验证元数据中缺少校验和。 -在存储库“ MavenRepo”中的工件commons-logging-1.2.pom（commons-logging：commons-logging：1.2）上：验证元数据中缺少校验和。

这表明`commons-logging`执行时需要构建`compileJava`，但是验证文件没有足够的信息供Gradle验证依赖关系的完整性，这意味着您需要将所需信息添加到验证元数据文件中。

请参阅[对依赖性验证](#sec:troubleshooting-verification)进行[故障诊断](#sec:troubleshooting-verification)，以获取有关在这种情况下的处理方法的更多信息。

### [](#what_checksums_are_verified)[哪些校验和被验证？](#what_checksums_are_verified)

如果依赖性验证元数据文件声明了一个依赖性的多个校验和，则Gradle将验证_所有_校验和，如果其中_任何一个失败_，则Gradle将_失败_。例如，以下配置将同时检查`md5`和和`sha256`校验和：

\<component group="org.apache.pdfbox" name="pdfbox" version="2.0.17"> \<artifact name="pdfbox-2.0.17.jar"> \<md5 value="c713a8e252d0add65e9282b151adf6b4" origin="official site"/> \<sha1 value="b5c8dff799bd967c70ccae75e6972327ae640d35" origin="official site"/> \</artifact> \</component>

 

1

\<component group\="org.apache.pdfbox" name\="pdfbox" version\="2.0.17"\>

2

 \<artifact name\="pdfbox-2.0.17.jar"\>

3

 \<md5 value\="c713a8e252d0add65e9282b151adf6b4" origin\="official site"/>

4

 \<sha1 value\="b5c8dff799bd967c70ccae75e6972327ae640d35" origin\="official site"/>

5

 \</artifact\>

6

\</component\>

您要这样做的原因有多种：

1.  官方站点不会发布_安全_校验和（SHA-256，SHA-512），但会发布多个不安全的校验和（MD5，SHA1）。虽然伪造MD5校验和很容易，但伪造SHA1校验和可能很困难，但为相同的工件伪造这两个伪装则比较困难。
2.  您可能想将生成的校验和添加到上面的列表中
3.  当_更新_更安全的校验依赖验证文件，你不希望意外擦除校验

## [](#sec:signature-verification)[验证依赖项签名](#sec:signature-verification)

除了[校验和之外](#sec:checksum-verification)，Gradle还支持签名验证。签名用于评估依赖项的_来源_（它告诉谁签署了工件，通常对应于谁生成了该工件）。

由于启用签名验证通常意味着更高的安全级别，因此您可能希望将签名和校验替换为校验和验证。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>签名</font></font><em style="font-style:italic;"><font><font>可以</font></font></em><font><font>还可以用来评估类似的依赖于校验和的完整性。</font><font>签名是</font><font>人工产物</font></font><em style="font-style:italic;"><font><font>哈希</font></font></em><font><font>的</font><font>签名</font><font>，而不是人工产物本身。</font><font>这意味着，如果签名是在</font></font><em style="font-style:italic;"><font><font>不安全的哈希值</font></font></em><font><font>（甚至是SHA1）上完成的，那么您将无法正确评估</font><font>文件</font><font>的</font></font><em style="font-style:italic;"><font><font>完整性</font></font></em><font><font>。</font><font>因此，如果您同时关心两者，则需要将签名</font></font><em style="font-style:italic;"><font><font>和</font></font></em><font><font>校验和</font><font>都添加</font><font>到验证元数据中。</font></font></p></div></td></tr></tbody></table>

然而：

* Gradle仅支持验证以ASCII装甲的PGP文件形式发布在远程存储库上的签名
* 并非所有工件都带有签名发布
* 好的签名并不意味着签名人是合法的

因此，签名验证通常会与校验和验证一起使用。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="title" style="color:rgb(85, 85, 85);font-size:1.25rem;"><font><font>关于过期密钥</font></font></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>找到用过期密钥签名的工件非常普遍。</font><font>这不是</font></font><em style="font-style:italic;"><font><font>验证</font></font></em><font><font>问题</font><font>：密钥有效期通常用于避免使用被盗的密钥进行签名。</font><font>如果工件在到期之前已签名，则它仍然有效。</font></font></p></div></td></tr></tbody></table>

### [](#enabling_signature_verification)[启用签名验证](#enabling_signature_verification)

由于验证签名的成本更高（包括I / O和CPU），并且难以手动检查，因此默认情况下未启用它。

启用它需要您更改`verification-metadata.xml`文件中的配置选项：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<verify-signatures>true\</verify-signatures> \</configuration> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<verify-signatures\>true\</verify-signatures\>

5

 \</configuration\>

6

\</verification-metadata\>

## [](#sec:understanding-signature-verification)[了解签名验证](#sec:understanding-signature-verification)

启用签名验证后，对于每个工件，Gradle将：

* 尝试下载相应的`.asc`文件
* 如果存在  

  * 自动下载执行签名验证所需的密钥
  * 使用下载的公共密钥验证工件
  * 如果签名验证通过，则执行其他请求的校验和验证
* 如果不存在，则退回到校验和验证

也就是说，如果启用了签名验证，则Gradle验证机制要比仅使用校验和验证强得多。尤其是：

* 如果工件使用多个密钥签名，则所有密钥都必须通过验证，否则构建将失败
* 如果工件通过验证，_则还将检查_为工件配置的任何其他校验和

但是，这不是因为工件通过了可以信任的签名验证：您需要_信任密钥_。

实际上，这意味着您需要列出每个工件所信任的密钥，这可以通过添加`pgp`条目而不是`sha1`例如来完成：

\<component group="com.github.javaparser" name="javaparser-core" version="3.6.11"> \<artifact name="javaparser-core-3.6.11.jar"> \<pgp value="8756c4f765c9ac3cb6b85d62379ce192d401ab61"/> \</artifact> \</component>

 

1

\<component group\="com.github.javaparser" name\="javaparser-core" version\="3.6.11"\>

2

 \<artifact name\="javaparser-core-3.6.11.jar"\>

3

 \<pgp value\="8756c4f765c9ac3cb6b85d62379ce192d401ab61"/>

4

 \</artifact\>

5

\</component\>

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-tip"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>摇篮支持全指纹IDS或长（64位）的密钥ID<span>&nbsp;</span></font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">pgp</code><font><font>，</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">trusted-key</code><font><font>和</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">ignore-key</code><font><font>元件。</font><font>为了获得最大的安全性，您应该使用完整的指纹，因为长密钥ID可能会发生冲突。</font></font></p></div></td></tr></tbody></table>

这实际上意味着您信任`com.github.javaparser:javaparser-core:3.6.11`是否已使用密钥签名`8756c4f765c9ac3cb6b85d62379ce192d401ab61`。

否则，构建将因以下错误而失败：

\>配置'：compileClasspath'的依赖关系验证失败： -在存储库'MavenRepo'中的工件javaparser-core-3.6.11.jar（com.github.javaparser：javaparser-core：3.6.11）上：工件已用密钥'8756c4f765c9ac3cb6b85d62379ce192d401ab61'（Bintray（由JFrog提供）\<\*\* \*\*>）并通过了验证，但该密钥不在您的受信任密钥列表中。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>Gradle在错误消息中显示的密钥ID是它试图验证的签名文件中找到的密钥ID。</font><font>这并不意味着它一定是您应该信任的密钥。</font><font>特别是，如果签名是正确的但是由恶意实体完成的，则Gradle不会告诉您。</font></font></p></div></td></tr></tbody></table>

### [](#sec:trusting-keys-globally)[全球信任密钥](#sec:trusting-keys-globally)

签名验证的优势在于，不必显式列出仅用于校验和验证的所有工件，就可以使依赖关系验证的配置更加容易。实际上，通常可以使用同一密钥对多个工件进行签名。在这种情况下，可以将可信密钥从工件级别移至全局配置块：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<verify-metadata>true\</verify-metadata> \<verify-signatures>true\</verify-signatures> \<trusted-keys> \<trusted-key id="379ce192d401ab61" group="com.github.javaparser"/> \</trusted-keys> \</configuration> \<components/> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<verify-metadata\>true\</verify-metadata\>

5

 \<verify-signatures\>true\</verify-signatures\>

6

 \<trusted-keys\>

7

 \<trusted-key id\="379ce192d401ab61" group\="com.github.javaparser"/>

8

 \</trusted-keys\>

9

 \</configuration\>

10

 \<components/>

11

\</verification-metadata\>

上面的配置意味着，对于属于该组的任何工件`com.github.javaparser`，如果使用签名，则我们相信它`379ce192d401ab61`。

该`trusted-key`元素的工作方式与[trusted-artifact](#sec:trusting-artifacts)元素类似：

* `group`，要信任的工件组
* `name`，要信任的工件的名称
* `version`，要信任的工件的版本
* `file`，要信任的工件_文件_的名称
* `regex`，一个布尔说如果`group`，`name`，`version`并且`file`需要被解释为正则表达式（默认属性`false`）

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>全局信任密钥时应该小心：尝试将其限制为适当的组或工件：</font></font></p></div><div class="ulist"><ul style="font-size:1rem;"><li><span><font><font>有效的密钥可能已用于签署</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">A</code><font><font>您信任的</font><font>工件</font></font></span></li><li><span><font><font>以后，密钥被盗并用于对工件进行签名<span>&nbsp;</span></font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">B</code></span></li></ul></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>这意味着您可以信任</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">A</code><font><font>第一个工件</font><font>的密钥</font><font>，可能仅</font><font>信任</font><font>密钥被盗之前的发行版本，而不能</font><font>信任</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">B</code><font><font>。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>请记住，任何人在生成PGP密钥时都可以输入任意名称，因此永远不要仅基于密钥名称来信任密钥。</font><font>验证密钥是否在官方站点上列出。</font><font>例如，Apache项目通常提供您可以信任的KEYS.txt文件。</font></font></p></div></td></tr></tbody></table>

### [](#sec:ignoring-keys)[指定密钥服务器并忽略密钥](#sec:ignoring-keys)

Gradle将自动下载验证签名所需的公钥。为此，它使用了一系列知名且受信任的密钥服务器（该列表可能会在Gradle版本之间发生变化，请参考实现以了解默认情况下使用的服务器）。

您可以通过将它们添加到配置中来显式设置要使用的密钥服务器的列表：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<verify-metadata>true\</verify-metadata> \<verify-signatures>true\</verify-signatures> \<key-servers> \<key-server uri="hkp://my-key-server.org"/> \<key-server uri="https://my-other-key-server.org"/> \</key-servers> \</configuration> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<verify-metadata\>true\</verify-metadata\>

5

 \<verify-signatures\>true\</verify-signatures\>

6

 \<key-servers\>

7

 \<key-server uri\="hkp://my-key-server.org"/>

8

 \<key-server uri\="https://my-other-key-server.org"/>

9

 \</key-servers\>

10

 \</configuration\>

11

\</verification-metadata\>

尽管如此，密钥仍然可能不可用：

* 因为它没有发布到公钥服务器
* 因为它丢失了

在这种情况下，您可以忽略配置块中的键：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<verify-metadata>true\</verify-metadata> \<verify-signatures>true\</verify-signatures> \<ignored-keys> \<ignored-key id="abcdef1234567890" reason="Key is not available in any key server"/> \</ignored-keys> \</configuration> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<verify-metadata\>true\</verify-metadata\>

5

 \<verify-signatures\>true\</verify-signatures\>

6

 \<ignored-keys\>

7

 \<ignored-key id\="abcdef1234567890" reason\="Key is not available in any key server"/>

8

 \</ignored-keys\>

9

 \</configuration\>

10

\</verification-metadata\>

一旦密钥被忽略，即使签名文件中提到了密钥，也不会将其用于验证。但是，如果不能使用至少一个其他密钥来验证签名，则Gradle将要求您提供校验和。

### [](#sec:local-keyring)[导出密钥以加快验证速度](#sec:local-keyring)

Gradle自动下载所需的密钥，但是此操作可能会很慢，并且需要每个人都下载密钥。为了避免这种情况，Gradle提供了使用包含所需公共密钥的本地密钥环文件的功能。

如果`gradle/verification-keyring.gpg`文件存在，Gradle将优先搜索那里的密钥。

您可以使用GPG生成此文件，例如发出以下命令（语法可能取决于您使用的工具）：

\$ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 379ce192d401ab61 gpg: keybox 'gradle/verification-keyring.gpg' created gpg: key 379CE192D401AB61: public key "Bintray \(by JFrog\) \<\*\*\*\*>" imported gpg: Total number processed: 1 gpg: imported: 1 \$ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 6a0975f8b1127b83 gpg: key 0729A0AFF8999A87: public key "Kotlin Release \<\*\*\*\*>" imported gpg: Total number processed: 1 gpg: imported: 1

 

1

\$ gpg \--no\-default\-keyring \--keyring gradle/verification\-keyring.gpg \--recv\-keys 379ce192d401ab61

2

3

gpg: keybox 'gradle/verification-keyring.gpg' created

4

gpg: key 379CE192D401AB61: public key "Bintray \(by JFrog\) \<\*\*\*\*>" imported

5

gpg: Total number processed: 1

6

gpg:               imported: 1

7

8

\$ gpg \--no\-default\-keyring \--keyring gradle/verification\-keyring.gpg \--recv\-keys 6a0975f8b1127b83

9

10

gpg: key 0729A0AFF8999A87: public key "Kotlin Release \<\*\*\*\*>" imported

11

gpg: Total number processed: 1

12

gpg:               imported: 1

或者，您也可以_要求Gradle_在引导过程_中将用于验证此版本的所有密钥导出到密钥环_：

./gradlew --write-verification-metadata pgp，sha256 --export-keys

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>将这个文件提交到VCS是一个好主意（只要您信任自己的VCS）。</font><font>如果使用git，请通过将其添加到</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">.gitattributes</code><font><font>文件中</font><font>来确保将其视为二进制</font><font>文件：</font></font></p></div><div class="listingblock"><div class="content"><pre style="font-family:Inconsolata, monospace;font-size:1rem;color:rgba(0, 0, 0, 0.9);background:rgb(247, 247, 248);"><font><font>* .gpg二进制</font></font></pre></div></div></td></tr></tbody></table>

### [](#sec:bootstrapping-signature-verification)[引导和签名验证](#sec:bootstrapping-signature-verification)

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>签名验证自举采取了</font></font><em style="font-style:italic;"><font><font>乐观的观点</font></font></em><font><font>，即签名验证就</font></font><em style="font-style:italic;"><font><font>足够了</font></font></em><font><font>。</font><font>因此，如果您还关心</font></font><em style="font-style:italic;"><font><font>完整性</font></font></em><font><font>，则</font></font><strong><font><font>必须</font></font></strong><font><font>首先使用校验和验证进行引导，</font></font><em style="font-style:italic;"><font><font>然后</font></font></em><font><font>使用签名验证进行</font><font>引导</font><font>。</font></font></p></div></td></tr></tbody></table>

与引导校验和类似，Gradle提供了一种在启用签名验证的情况下引导配置文件的便利。为此，只需将`pgp`选项添加到要生成的验证列表即可。但是，由于可能存在验证失败，密钥丢失或签名文件丢失的情况，因此您**必须**提供后备校验和验证算法：

./gradlew --write-verification-metadata pgp，sha256

这意味着Gradle将在出现问题时验证签名并回退到SHA-256校验和。

引导时，Gradle会进行_乐观验证_，因此会假定构建环境合理。因此，它将：

* 验证通过后立即自动添加可信密钥
* 自动为无法从公共密钥服务器下载的密钥添加忽略的密钥
* 自动为没有签名或忽略键的工件生成校验和

如果由于某种原因在生成过程中验证失败，Gradle将自动生成一个忽略的密钥条目，但警告您必须绝对检查会发生什么。

如[本节](#sec:trusting-several-checksums)所述，[这种](#sec:trusting-several-checksums)情况很常见：一种典型情况是，一个依赖项的POM文件在一个存储库与另一个存储库之间有所不同（通常是无意义的）。

另外，Gradle会尝试自动对密钥进行分组并生成`trusted-keys`块，从而尽可能减小配置文件的大小。

## [](#sec:troubleshooting-verification)[对依赖性验证进行故障排除](#sec:troubleshooting-verification)

### [](#sec:dealing-verification-failure)[处理验证失败](#sec:dealing-verification-failure)

依赖性验证可能会以不同的方式失败，本节说明了如何处理各种情况。

#### [](#missing_verification_metadata)[缺少验证元数据](#missing_verification_metadata)

您可能遇到的最简单的故障是，依赖关系验证文件中缺少验证元数据。例如，如果您使用[校验和验证](#sec:checksum-verification)，更新了依赖项并且引入了新版本的依赖项（以及潜在的可传递依赖项），就是这种情况。

Gradle会告诉您缺少哪些元数据：

任务'：compileJava'的执行失败。 >配置'：compileClasspath'的依赖关系验证失败： -在存储库“ MavenRepo”中的工件commons-logging-1.2.jar（commons-logging：commons-logging：1.2）上：验证元数据中缺少校验和。

* 缺少的模块组是`commons-logging`，其工件名称为`commons-logging`，其版本为`1.2`。相应的工件是，`commons-logging-1.2.jar`因此您需要在验证文件中添加以下条目：

\<component group="commons-logging" name="commons-logging" version="1.2"> \<artifact name="commons-logging-1.2.jar"> \<sha256 value="daddea1ea0be0f56978ab3006b8ac92834afeefbd9b7e4e6316fca57df0fa636" origin="official distribution"/> \</artifact> \</component>

 

1

\<component group\="commons-logging" name\="commons-logging" version\="1.2"\>

2

 \<artifact name\="commons-logging-1.2.jar"\>

3

 \<sha256 value\="daddea1ea0be0f56978ab3006b8ac92834afeefbd9b7e4e6316fca57df0fa636" origin\="official distribution"/>

4

 \</artifact\>

5

\</component\>

或者，您可以要求Gradle通过使用[引导机制](#sec:bootstrapping-verification)来生成丢失的信息：元数据文件中的现有信息将被保留，Gradle将仅添加丢失的验证元数据。

#### [](#incorrect_checksums)[校验和不正确](#incorrect_checksums)

另一个问题是实际校验和验证失败时：

任务'：compileJava'的执行失败。 >配置'：compileClasspath'的依赖关系验证失败： - 在神器共享记录-1.2.jar（共享记录：共享记录：1.2）在库“MavenRepo”：预期“SHA256”校验“91f7a33096ea69bac2cbaf6d01feb934cac002c48d8c8cfa9c240b40f1ec21df”，但被“daddea1ea0be0f56978ab3006b8ac92834afeefbd9b7e4e6316fca57df0fa636”

这次，Gradle告诉您什么依赖项有问题，期望的校验和是什么（您在验证元数据文件中声明的校验和）以及在验证期间实际计算的校验和。

这样的失败表明**依赖关系可能已经被破坏**。在此阶段，您**必须**执行手动验证并检查会发生什么。可能会发生几件事：

* Gradle的本地依赖项缓存中的依赖项被篡改。这通常是无害的：从缓存中删除文件，Gradle将重新下载依赖项。
* 依赖关系在二进制格式略有不同的多个源中可用（附加空白，…）  

  * 请通知图书馆的维护者他们有这样的问题
  * 您可以[`also-trust`](#sec:trusting-several-checksums)用来接受额外的校验和
* 依赖性受到损害  

  * 立即通知图书馆的维护者
  * 通知存储库维护者受损的库

请注意，一个受损库的变化往往是_名蹲_，当黑客使用的GAV坐标_看起来合法的_，但实际上是不同的一个字符，或_仓库阴影_，与官方的GAV坐标的依赖发表在恶意贮藏库首先在您的构建中。

#### [](#untrusted_signatures)[不受信任的签名](#untrusted_signatures)

如果启用了签名验证，则Gradle将执行签名验证，但不会自动信任它们：

\>配置'：compileClasspath'的依赖关系验证失败： -在存储库\`\`MavenRepo''中的工件javaparser-core-3.6.11.jar（com.github.javaparser：javaparser-core：3.6.11）上：工件已用密钥\`\`379ce192d401ab61''（Bintray（由JFrog开发））签名了\*\*>）并通过了验证，但该密钥不在您的受信任密钥列表中。

在这种情况下，这意味着您需要检查自己是否可以信任用于验证（因此是签名）的密钥，在这种情况下，请参考[文档的本部分](#sec:understanding-signature-verification)以了解如何声明可信密钥。

#### [](#failed_signature_verification)[签名验证失败](#failed_signature_verification)

如果Gradle无法验证签名，则您将需要采取措施并手动验证工件，因为这**可能表示依赖关系已损坏**。

如果发生这种情况，Gradle将失败并显示：

\>配置'：compileClasspath'的依赖关系验证失败： -在存储库\`\`MavenRepo''中的工件javaparser-core-3.6.11.jar（com.github.javaparser：javaparser-core：3.6.11）上：工件已用密钥\`\`379ce192d401ab61''（Bintray（由JFrog开发））签名了\*\*>），但签名不匹配

有几种选择：

1.  首先，签名是错误的，这种错误经常发生[在不同存储库中发布的依赖项中](#sec:trusting-several-checksums)。
2.  签名是正确的，但是工件已被破坏（在本地依赖项缓存中或在远程）

正确的方法是访问依赖项的官方站点，并查看它们是否发布其工件的签名。如果是这样，请验证Gradle下载的签名与发布的签名匹配。

如果[检查了依赖性_没有_受到损害，](#sec:manual-checking-dependency)并且签名只是“错误的”签名，则应该声明_工件级别的密钥排除_：

\<components> \<component group="com.github.javaparser" name="javaparser-core" version="3.6.11"> \<artifact name="javaparser-core-3.6.11.pom"> \<ignored-keys> \<ignored-key id="379ce192d401ab61" reason="internal repo has corrupted POM"/> \</ignored-keys> \</artifact> \</component> \</components>

 

1

 \<components\>

2

 \<component group\="com.github.javaparser" name\="javaparser-core" version\="3.6.11"\>

3

 \<artifact name\="javaparser-core-3.6.11.pom"\>

4

 \<ignored-keys\>

5

 \<ignored-key id\="379ce192d401ab61" reason\="internal repo has corrupted POM"/>

6

 \</ignored-keys\>

7

 \</artifact\>

8

 \</component\>

9

 \</components\>

但是，如果仅这样做，则Gradle仍然会失败，因为此工件的所有键都将被忽略，并且您未提供校验和：

\<components> \<component group="com.github.javaparser" name="javaparser-core" version="3.6.11"> \<artifact name="javaparser-core-3.6.11.pom"> \<ignored-keys> \<ignored-key id="379ce192d401ab61" reason="internal repo has corrupted POM"/> \</ignored-keys> \<sha256 value="a2023504cfd611332177f96358b6f6db26e43d96e8ef4cff59b0f5a2bee3c1e1"/> \</artifact> \</component> \</components>

 

1

 \<components\>

2

 \<component group\="com.github.javaparser" name\="javaparser-core" version\="3.6.11"\>

3

 \<artifact name\="javaparser-core-3.6.11.pom"\>

4

 \<ignored-keys\>

5

 \<ignored-key id\="379ce192d401ab61" reason\="internal repo has corrupted POM"/>

6

 \</ignored-keys\>

7

 \<sha256 value\="a2023504cfd611332177f96358b6f6db26e43d96e8ef4cff59b0f5a2bee3c1e1"/>

8

 \</artifact\>

9

 \</component\>

10

 \</components\>

#### [](#sec:manual-checking-dependency)[手动验证依赖项](#sec:manual-checking-dependency)

您可能会遇到依赖性验证失败（校验和验证或签名验证），并且需要确定依赖性是否受到破坏。

在本节中，我们举_一个示例，_说明如何手动检查依赖项是否受到破坏。

为此，我们将以失败为例：

\>配置'：compileClasspath'的依赖关系验证失败： -在“ MyCompany Mirror”存储库中的工件j2objc-annotations-1.1.jar（com.google.j2objc：j2objc-annotations：1.1）上：工件已用密钥“ 29579f18fa8fd93b”签名，但签名不匹配

此错误消息为我们提供了有问题的依赖项的GAV坐标，并指出了从何处获取了依赖项。在这里，依赖项来自`MyCompany Mirror`，这是在我们的构建中声明的存储库。

因此，要做的第一件事是从镜像手动下载工件及其签名：

\$ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar-输出j2objc-annotations-1.1.jar \$ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar.asc --output j2objc-annotations-1.1.jar.asc

然后，我们可以使用错误消息中提供的密钥信息在本地导入密钥：

\$ gpg --recv-keys 29579f18fa8fd93b

并执行验证：

\$ gpg-验证j2objc-annotations-1.1.jar.asc gpg：假设在'j2objc-annotations-1.1.jar'中已签名的数据 gpg：签名于2017年1月19日星期四CET发出 gpg：使用RSA密钥29579F18FA8FD93B gpg：“ Tom Ball \<\*\*\*\*>”中的错误签名\[未知\]

这说明问题_不在_本地计算机上：存储库_已经包含错误的签名_。

下一步是通过下载Maven Central上实际的内容来执行相同的操作：

\$ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar --output central-j2objc-annotations-1.1.jar \$ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1/1/j2objc-annotations-1.1.jar.asc --output central-j2objc-annotations-1.1。 jar.asc

现在我们可以再次检查签名：

\$ gpg --verify central-j2objc-annotations-1.1.jar.asc
 gpg：假设在“ central-j2objc-annotations-1.1.jar”中已签名的数据 gpg：签名于2017年1月19日星期四CET发出 gpg：使用RSA密钥29579F18FA8FD93B gpg：“汤姆·鲍尔\<\*\*\*\*>”的好签名\[未知\] gpg：警告：此密钥未通过可信签名的认证！ gpg：没有迹象表明签名属于所有者。 主键指纹：B801 E2F8 EF03 5068 EC11 39CC 2957 9F18 FA8F D93B

这表明该依赖关系在Maven Central上_有效_。在此阶段，我们已经知道问题出在镜像中，它_可能_已经被妥协，但是我们需要进行验证。

一个好主意是比较这两个工件，您可以使用[衍射](https://try.diffoscope.org/)仪之类的工具来[完成](https://try.diffoscope.org/)。

然后，我们发现该意图不是恶意的，而是某种程度上某个版本已被较新的版本覆盖（Central中的版本比我们存储库中的版本新）。

在这种情况下，您可以决定：

* 忽略此工件的签名，并信任不同的可能校验和（旧工件和新版本均适用）
* 或清理您的镜像，使其包含与Maven Central中相同的版本

值得注意的是，如果您选择从存储库中删除版本，则_还_需要将其从本地Gradle缓存中删除。

错误消息告诉您文件所在的位置，这很容易实现：

\>配置'：compileClasspath'的依赖关系验证失败： -在“ MyCompany Mirror”存储库中的工件j2objc-annotations-1.1.jar（com.google.j2objc：j2objc-annotations：1.1）上：工件已用密钥“ 29579f18fa8fd93b”签名，但签名不匹配
 这可以表明依赖项已被破坏。请仔细核实签名和校验和。
 供您参考，以下是验证失败的文件的路径： -GRADLE\_USER\_HOME / caches / modules-2 / files-2.1 / com.google.j2objc / j2objc-annotations / 1.1 / 976d8d30bebc251db406f2bdb3eb01962b5685b3 / j2objc-annotations-1.1.jar（签名：GRADLE\_USER\_HOME / caches / 2.1s / files-2.1 .google.j2objc / j2objc-annotations / 1.1 / 82e922e14f57d522de465fd144ec26eb7da44501 / j2objc-annotations-1.1.jar.asc）
 GRADLE\_USER\_HOME = /home/jiraya/.gradle

您可以安全地删除工件文件，因为Gradle会自动重新下载它：

rm -rf〜/ .gradle / caches / modules-2 / files-2.1 / com.google.j2objc / j2objc-annotations / 1.1

### [](#sec:disabling-verification)[禁用验证或使其宽松](#sec:disabling-verification)

依赖关系验证可能会很昂贵，或者有时会妨碍日常开发（例如，由于频繁的依赖关系升级）。

或者，您可能要在CI服务器上启用验证，但在本地计算机上不启用。

Gradle实际上提供了3种不同的验证模式：

* `strict`，这是默认值。验证会_尽早_失败，以避免在构建过程中使用受损的依赖项。
* `lenient`，即使有验证失败，它也会运行构建。验证错误将在构建过程中显示，而不会导致构建失败。
* `off`当验证被完全忽略时。

可以使用该`--dependency-verification`标志在CLI上激活所有这些模式，例如：

./gradlew-依赖性验证宽容构建

或者，您可以`org.gradle.dependency.verification`在CLI上设置系统属性：

./gradlew -Dorg.gradle.dependency.verification =宽松的构建

或在`gradle.properties`文件中：

org.gradle.dependency.verification =宽松

### [](#sec:trusting-artifacts)[信任一些特定的工件](#sec:trusting-artifacts)

您可能要比其他人更信任某些工件。例如，认为公司生产并在内部存储库中找到的工件只是安全的，这是合理的，但是您想检查每个外部组件。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>这是典型的</font></font><em style="font-style:italic;"><font><font>公司政策</font></font></em><font><font>。</font><font>在实践中，</font></font><strong><font><font>没有什么</font></font></strong><font><font>可以防止您的内部存储库遭到破坏，因此最好检查一下内部构件！</font></font></p></div></td></tr></tbody></table>

为此，Gradle提供了一种自动信任某些工件的方法。您可以通过将其添加到配置中来信任组中的所有工件：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<trusted-artifacts> \<trust group="com.mycompany"/> \</trusted-artifacts> \</configuration> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<trusted-artifacts\>

5

 \<trust group\="com.mycompany"/>

6

 \</trusted-artifacts\>

7

 \</configuration\>

8

\</verification-metadata\>

这意味着`com.mycompany`将自动信任该组中的所有组件。信任意味着Gradle不会执行任何验证。

所述`trust`元件接受的那些属性：

* `group`，要信任的工件组
* `name`，要信任的工件的名称
* `version`，要信任的工件的版本
* `file`，要信任的工件_文件_的名称
* `regex`，一个布尔说如果`group`，`name`，`version`并且`file`需要被解释为正则表达式（默认属性`false`）

在上面的示例中，这意味着可信工件将是中的工件，`com.mycompany`但不是`com.mycompany.other`。要信任所有`com.mycompany`子集中的子项目和所有子组，可以使用：

\<\?xml version="1.0" encoding="UTF-8"\?> \<verification-metadata> \<configuration> \<trusted-artifacts> \<trust group="\^com\[.\]mycompany\(\$|\(\[.\].\*\)\)" regex="true"/> \</trusted-artifacts> \</configuration> \</verification-metadata>

 

1

\<\?xml version="1.0" encoding="UTF-8"\?>

2

\<verification-metadata\>

3

 \<configuration\>

4

 \<trusted-artifacts\>

5

 \<trust group\="\^com\[.\]mycompany\(\$|\(\[.\].\*\)\)" regex\="true"/>

6

 \</trusted-artifacts\>

7

 \</configuration\>

8

\</verification-metadata\>

### [](#sec:trusting-several-checksums)[信任工件的多个校验和](#sec:trusting-several-checksums)

在野外_对同一工件_有_不同的校验和_是很常见的。那怎么可能？尽管取得了进步，但开发人员经常会使用不同的版本分别发布到Maven Central和JCenter，例如。通常，这不是问题，但是有时这意味着元数据文件会有所不同（不同的时间戳，其他空格等）。除此之外，您的构建可能会使用多个存储库或存储库镜像，这很可能使单个构建可以“看到”同一组件的不同元数据文件！通常，它不是恶意的（但是您**必须**验证工件是正确的），因此Gradle允许您声明其他工件校验和。例如：

\<component group="org.apache" name="apache" version="13"> \<artifact name="apache-13.pom"> \<sha256 value="2fafa38abefe1b40283016f506ba9e844bfcf18713497284264166a5dbf4b95e"> \<also-trust value="ff513db0361fd41237bef4784968bc15aae478d4ec0a9496f811072ccaf3841d"/> \</sha256> \</artifact> \</component>

 

1

 \<component group\="org.apache" name\="apache" version\="13"\>

2

 \<artifact name\="apache-13.pom"\>

3

 \<sha256 value\="2fafa38abefe1b40283016f506ba9e844bfcf18713497284264166a5dbf4b95e"\>

4

 \<also-trust value\="ff513db0361fd41237bef4784968bc15aae478d4ec0a9496f811072ccaf3841d"/>

5

 \</sha256\>

6

 \</artifact\>

7

 \</component\>

您可以`also-trust`根据需要输入任意数量的条目，但通常不应超过2个条目。

### [](#sec:skipping-javadocs)[跳过Javadocs和源代码](#sec:skipping-javadocs)

默认情况下，Gradle将验证_所有_下载的工件，包括Javadocs和源。通常，这不是问题，但您可能会遇到IDE的问题，这些IDE在导入期间会自动尝试下载它们：如果您也没有为这些IDE设置校验和，则导入将失败。

为了避免这种情况，您可以将Gradle配置为自动信任所有javadocs / sources：

\<trusted-artifacts> \<trust file=".\*-javadoc\[.\]jar" regex="true"/> \<trust file=".\*-sources\[.\]jar" regex="true"/> \</trusted-artifacts>

 

1

\<trusted-artifacts\>

2

 \<trust file\=".\*-javadoc\[.\]jar" regex\="true"/>

3

 \<trust file\=".\*-sources\[.\]jar" regex\="true"/>

4

\</trusted-artifacts\>

### [](#sec:verification-metadata-hygiene)[清理验证文件](#sec:verification-metadata-hygiene)

如果不执行任何操作，则依赖关系验证元数据会随着时间的增长而增加新的依赖关系或更改版本：Gradle不会自动从此文件中删除_未使用的_条目。原因是Gradle无法预先知道在构建过程中是否会有效使用依赖项。

结果，添加依赖项或更改依赖项版本可以轻松导致文件中的更多条目，同时将不必要的条目留在那里。

清理文件的一种方法是将现有`verification-metadata.xml`文件移动到其他位置，并使用以下[`--dry-run`方式](#sec:verification-dry-mode)调用Gradle：虽然不完善（它不会注意到依赖项仅在配置时解决），但它会生成_一个新文件_，您可以将其与现有的。

我们需要移动现有文件，因为引导模式和空运行模式都是增量的：它们会复制现有元数据验证文件中的信息（特别是可信密钥）。

### [](#sec:refreshing-missing-keys)[刷新丢失的键](#sec:refreshing-missing-keys)

Gradle将丢失的密钥缓存24小时，这意味着它在失败后的24小时内不会尝试重新下载丢失的密钥。

如果要立即重试，可以使用`--refresh-keys`CLI标志运行：

./gradlew建立--refresh-keys

## [](#sub:disabling-specific-verification)[仅对某些配置禁用依赖性验证](#sub:disabling-specific-verification)

为了提供可能的最强安全级别，全局启用依赖项验证。例如，这将确保您信任所使用的所有插件。但是，插件本身可能需要解决其他依赖性，要求用户接受是没有意义的。为此，Gradle提供了一个API，该API允许_禁用某些特定配置上的依赖关系验证_。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>如果您关心安全性，则禁用依赖关系验证不是一个好主意。</font><font>该API主要用于检查依赖项没有意义的情况。</font><font>但是，为了安全起见，每当禁用特定配置的验证时，Gradle都会系统地打印警告。</font></font></p></div></td></tr></tbody></table>

例如，一个插件可能要检查是否有可用的_较新_版本的库并列出这些版本。在这种情况下，要求用户放入较新版本的POM文件的校验和是没有意义的，因为根据定义，他们不知道它们。因此，该插件可能需要_独立于依赖项验证配置_来运行其代码。

为此，您需要调用`ResolutionStrategy#disableDependencyVerification`方法：

示例1.禁用依赖性验证

`Groovy``Kotlin`

build.gradle

configurations \{ myPluginClasspath \{ resolutionStrategy \{ disableDependencyVerification\(\) \} \} \}

 

1

configurations \{

2

 myPluginClasspath \{

3

 resolutionStrategy \{

4

 disableDependencyVerification\(\)

5

 \}

6

 \}

7

\}

也可以禁用对分离配置的验证，如以下示例所示：

示例2.禁用依赖性验证

`Groovy``Kotlin`

build.gradle

tasks.register\("checkDetachedDependencies"\) \{ doLast \{ def detachedConf = configurations.detachedConfiguration\(dependencies.create\("org.apache.commons:commons-lang3:3.3.1"\)\) detachedConf.resolutionStrategy.disableDependencyVerification\(\) println\(detachedConf.files\) \} \}

 

1

tasks.register\("checkDetachedDependencies"\) \{

2

 doLast \{

3

 def detachedConf \= configurations.detachedConfiguration\(dependencies.create\("org.apache.commons:commons-lang3:3.3.1"\)\)

4

 detachedConf.resolutionStrategy.disableDependencyVerification\(\)

5

 println\(detachedConf.files\)

6

 \}

7

\}