 无标题 <style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body { padding-left: 48px; padding-right: 48px;}</style><style id="wiz_code_style">.wiz-editor-body .wiz-code-container{position: relative; padding:8px 0; margin: 5px 0;text-indent:0; text-align:left;}.CodeMirror {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; color: black; font-size: 10.5pt; font-size: 0.875rem}.wiz-editor-body .wiz-code-container .CodeMirror div {margin-top: 0; margin-bottom: 0;}.CodeMirror-lines {padding: 4px 0;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {padding: 0 4px;}.CodeMirror pre.CodeMirror-line {min-height: 24px;}.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {background-color: white;}.CodeMirror-gutters {border-right: 1px solid #ddd; background-color: #f7f7f7; white-space: nowrap;}.CodeMirror-linenumbers {}.CodeMirror-linenumber {padding: 0 3px 0 5px; min-width: 20px; text-align: right; color: #999; white-space: nowrap;}.CodeMirror-guttermarker {color: black;}.CodeMirror-guttermarker-subtle {color: #999;}.CodeMirror-cursor {border-left: 1px solid black; border-right: none; width: 0;}.CodeMirror div.CodeMirror-secondarycursor {border-left: 1px solid silver;}.cm-fat-cursor .CodeMirror-cursor {width: auto; border: 0 !important; background: #7e7;}.cm-fat-cursor div.CodeMirror-cursors {z-index: 1;}.cm-fat-cursor-mark {background-color: rgba(20, 255, 20, 0.5);-webkit-animation: blink 1.06s steps(1) infinite;-moz-animation: blink 1.06s steps(1) infinite;animation: blink 1.06s steps(1) infinite;}.cm-animate-fat-cursor {width: auto; border: 0; -webkit-animation: blink 1.06s steps(1) infinite; -moz-animation: blink 1.06s steps(1) infinite; animation: blink 1.06s steps(1) infinite; background-color: #7e7;}@-moz-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@-webkit-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}.CodeMirror-overwrite .CodeMirror-cursor {}.cm-tab { display: inline-block; text-decoration: inherit; }.CodeMirror-rulers {position: absolute; left: 0; right: 0; top: -50px; bottom: -20px; overflow: hidden;}.CodeMirror-ruler {border-left: 1px solid #ccc; top: 0; bottom: 0; position: absolute;}.cm-s-default .cm-header {color: blue;}.cm-s-default .cm-quote {color: #090;}.cm-negative {color: #d44;}.cm-positive {color: #292;}.cm-header, .cm-strong {font-weight: bold;}.cm-em {font-style: italic;}.cm-link {text-decoration: underline;}.cm-strikethrough {text-decoration: line-through;}.cm-s-default .cm-keyword {color: #708;}.cm-s-default .cm-atom {color: #219;}.cm-s-default .cm-number {color: #164;}.cm-s-default .cm-def {color: #00f;}.cm-s-default .cm-variable,.cm-s-default .cm-punctuation,.cm-s-default .cm-property,.cm-s-default .cm-operator {}.cm-s-default .cm-variable-2 {color: #05a;}.cm-s-default .cm-variable-3 {color: #085;}.cm-s-default .cm-comment {color: #a50;}.cm-s-default .cm-string {color: #a11;}.cm-s-default .cm-string-2 {color: #f50;}.cm-s-default .cm-meta {color: #555;}.cm-s-default .cm-qualifier {color: #555;}.cm-s-default .cm-builtin {color: #30a;}.cm-s-default .cm-bracket {color: #997;}.cm-s-default .cm-tag {color: #170;}.cm-s-default .cm-attribute {color: #00c;}.cm-s-default .cm-hr {color: #999;}.cm-s-default .cm-link {color: #00c;}.cm-s-default .cm-error {color: #f00;}.cm-invalidchar {color: #f00;}.CodeMirror-composing { border-bottom: 2px solid; }div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }.CodeMirror-activeline-background {background: #e8f2ff;}.CodeMirror {position: relative; background: #f5f5f5;}.CodeMirror-scroll {overflow: hidden !important; margin-bottom: 0; margin-right: -30px; padding: 16px 30px 16px 0; outline: none; position: relative;}.CodeMirror-sizer {position: relative; border-right: 30px solid transparent;}.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {position: absolute; z-index: 6; display: none;}.CodeMirror-vscrollbar {right: 0; top: 0; overflow-x: hidden; overflow-y: scroll;}.CodeMirror-hscrollbar {bottom: 0; left: 0 !important; overflow-y: hidden; overflow-x: scroll;pointer-events: auto !important;outline: none;}.CodeMirror-scrollbar-filler {right: 0; bottom: 0;}.CodeMirror-gutter-filler {left: 0; bottom: 0;}.CodeMirror-gutters {position: absolute; left: 0; top: 0; min-height: 100%; z-index: 3;}.CodeMirror-gutter {white-space: normal; height: 100%; display: inline-block; vertical-align: top; margin-bottom: -30px;}.CodeMirror-gutter-wrapper {position: absolute; z-index: 4; background: none !important; border: none !important;}.CodeMirror-gutter-background {position: absolute; top: 0; bottom: 0; z-index: 4;}.CodeMirror-gutter-elt {position: absolute; cursor: default; z-index: 4;}.CodeMirror-gutter-wrapper ::selection { background-color: transparent }.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }.CodeMirror-lines {cursor: text; min-height: 1px;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {-moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0; border-width: 0; background: transparent; font-family: inherit; font-size: inherit; margin: 0; white-space: pre; word-wrap: normal; line-height: inherit; color: inherit; z-index: 2; position: relative; overflow: visible; -webkit-tap-highlight-color: transparent; -webkit-font-variant-ligatures: contextual; font-variant-ligatures: contextual;}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like {word-wrap: break-word; white-space: pre-wrap; word-break: normal;}.CodeMirror-linebackground {position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;}.CodeMirror-linewidget {position: relative; z-index: 2; padding: 0.1px;}.CodeMirror-widget {}.CodeMirror-rtl pre { direction: rtl; }.CodeMirror-code {outline: none;}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {-moz-box-sizing: content-box; box-sizing: content-box;}.CodeMirror-measure {position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;}.CodeMirror-cursor {position: absolute; pointer-events: none;}.CodeMirror-measure pre { position: static; }div.CodeMirror-cursors {visibility: hidden; position: relative; z-index: 3;}div.CodeMirror-dragcursors {visibility: visible;}.CodeMirror-focused div.CodeMirror-cursors {visibility: visible;}.CodeMirror-selected { background: #d9d9d9; }.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }.CodeMirror-crosshair { cursor: crosshair; }.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }.cm-searching {background: #ffa; background: rgba(255, 255, 0, .4);}.cm-force-border { padding-right: .1px; }@media print { .CodeMirror div.CodeMirror-cursors {visibility: hidden;}}.cm-tab-wrap-hack:after { content: ""; }span.CodeMirror-selectedtext { background: none; }.CodeMirror-activeline-background, .CodeMirror-selected {transition: visibility 0ms 100ms;}.CodeMirror-blur .CodeMirror-activeline-background, .CodeMirror-blur .CodeMirror-selected {visibility:hidden;}.CodeMirror-blur .CodeMirror-matchingbracket {color:inherit !important;outline:none !important;text-decoration:none !important;}.CodeMirror-sizer {min-height:auto !important;}</style>

# 声明依赖

内容

* [什么是依赖项配置](#sec:what-are-dependency-configurations)
* [可解析和消耗性配置](#sec:resolvable-consumable-configs)
* [为依赖项选择正确的配置](#sec:choosing-configuration)
* [定义自定义配置](#sec:defining-custom-configurations)
* [不同种类的依赖](#sec:dependency-types)
* [记录依赖性](#sec:documenting-dependencies)
* [通过模块依赖性解决特定工件](#sec:resolve_specific_artifacts_from_dependency)
* [支持的元数据格式](#sec:supported-metadata-formats)

在查看依赖项声明本身之前，需要定义_依赖项配置_的概念。

## [](#sec:what-are-dependency-configurations)[什么是依赖项配置](#sec:what-are-dependency-configurations)

为Gradle项目声明的每个依赖项都适用于特定范围。例如，应使用某些依赖项来编译源代码，而其他依赖项仅需要在运行时可用。Gradle在[Configuration]()的帮助下表示依赖项的范围。每个配置都可以通过唯一的名称来标识。

许多Gradle插件会向您的项目添加预定义的配置。例如，Java插件添加了配置，以表示其用于源代码编译，执行测试等所需的各种类路径。有关示例，请参见[Java插件章节]()。

图1.配置将声明的依赖项用于特定目的

有关使用配置导航，检查和后处理分配的依赖项的元数据和工件的更多示例，请查看[解析结果API]()。

### [](#sub:config-inheritance-composition)[配置继承和组合](#sub:config-inheritance-composition)

一个配置可以扩展其他配置以形成继承层次结构。子配置继承为其任何超配置声明的整个依赖项集。

Gradle核心插件（如[Java插件]()）大量使用配置继承。例如，`testImplementation`配置扩展了`implementation`配置。配置层次结构有一个实际目的：编译测试需要在编写测试类所需的依赖之上加上被测源代码的依赖。如果将其类导入到生产源代码中，则使用JUnit编写和执行测试代码的Java项目也需要Guava。

图2. Java插件提供的配置继承

通过调用[Configuration.extendsFrom（org.gradle.api.artifacts.Configuration \[\]）]()方法，在`testImplementation`和`implementation`配置的基础上形成继承层次结构。配置可以扩展任何其他配置，无论其在构建脚本或插件中的定义如何。

假设您想编写一套烟雾测试。每个冒烟测试都会进行HTTP调用以验证Web服务端点。作为基础测试框架，该项目已使用JUnit。您可以定义一个名为的新配置`smokeTest`，该`testImplementation`配置从配置扩展为重用现有的测试框架依赖性。

示例1.从另一个配置扩展一个配置

`Groovy``Kotlin`

build.gradle

configurations \{ smokeTest.extendsFrom testImplementation \} dependencies \{ testImplementation 'junit:junit:4.13' smokeTest 'org.apache.httpcomponents:httpclient:4.5.5' \}

 

1

configurations \{

2

 smokeTest.extendsFrom testImplementation

3

\}

4

5

dependencies \{

6

 testImplementation 'junit:junit:4.13'

7

 smokeTest 'org.apache.httpcomponents:httpclient:4.5.5'

8

\}

## [](#sec:resolvable-consumable-configs)[可解析和消耗性配置](#sec:resolvable-consumable-configs)

配置是Gradle中依赖关系解析的基本部分。在依赖关系解析的上下文中，区分_消费者_和_生产者_非常有用。按照这些原则，配置至少具有3个不同的角色：

1.  声明依赖
2.  作为_使用者_，解决对文件的一组依赖关系
3.  作为_生产者_，将工件及其依赖项公开以供其他项目使用（此类_消耗性_配置通常表示生产者向其消费者提供的[变体]()）

例如，要表达一个应用程序`app`_依赖_library`lib`，_至少_需要一种配置：

例子2.配置用来声明依赖

`Groovy``Kotlin`

build.gradle

configurations \{ // declare a "configuration" named "someConfiguration" someConfiguration \} dependencies \{ // add a project dependency to the "someConfiguration" configuration someConfiguration project\(":lib"\) \}

 

1

configurations \{

2

 // declare a "configuration" named "someConfiguration"

3

 someConfiguration

4

\}

5

dependencies \{

6

 // add a project dependency to the "someConfiguration" configuration

7

 someConfiguration project\(":lib"\)

8

\}

配置可以通过扩展从其他配置继承依赖关系。现在，请注意，上面的代码没有告诉我们有关此配置的目标_使用者_的任何信息。特别是，它并没有告诉我们该配置是如何_使用的_。假设这`lib`是一个Java库：它可能会公开不同的内容，例如其API，实现或测试装置。可能有必要`app`根据我们正在执行的任务来改变我们解决依赖关系的方式（针对的API进行编译`lib`，执行应用程序，编译测试等）。为了解决这个问题，您经常会找到伴随的配置，这些配置旨在明确声明其用法：

例子3.代表具体依赖图的配置

`Groovy``Kotlin`

build.gradle

configurations \{ // declare a configuration that is going to resolve the compile classpath of the application compileClasspath.extendsFrom\(someConfiguration\) // declare a configuration that is going to resolve the runtime classpath of the application runtimeClasspath.extendsFrom\(someConfiguration\) \}

 

1

configurations \{

2

 // declare a configuration that is going to resolve the compile classpath of the application

3

 compileClasspath.extendsFrom\(someConfiguration\)

4

5

 // declare a configuration that is going to resolve the runtime classpath of the application

6

 runtimeClasspath.extendsFrom\(someConfiguration\)

7

\}

在这一点上，我们有3种具有不同角色的不同配置：

* `someConfiguration`声明我的应用程序的依赖关系。它只是一个可以存储依赖项列表的存储桶。
* `compileClasspath`并且`runtimeClasspath`是_要解析的_配置：解析后，它们应分别包含应用程序的编译类路径和运行时类路径。

这种区别由类型中的`canBeResolved`标志表示`Configuration`。是的配置_可以解决_是我们可以计算一个依赖关系图，因为它包含了所有分辨率发生的必要信息的配置。也就是说，我们将计算一个依赖图，解析图中的组件，并最终获得工件。`canBeResolved`设置为的配置`false`并不意味着要解决。这样的配置_仅用于声明依赖项_。原因是根据使用情况（编译类路径，运行时类路径），它_可以_解析为不同的图。尝试解决已`canBeResolved`设置为的配置是错误的`false`。在某种程度上，这类似于不应实例化的_抽象类_（`canBeResolved`\= false），以及扩展抽象类（`canBeResolved`\= true）的具体类。可解析的配置将扩展至少一个不可解析的配置（并且可能会扩展多个）。

另一方面，在图书馆项目方面（_生产者_），我们还使用配置来表示可以消耗的东西。例如，该库可能会公开一个API或运行时，并且我们会将工件附加到一个或多个。通常，要针对进行编译`lib`，我们需要的API`lib`，但不需要其运行时依赖项。因此，该`lib`项目将公开一个`apiElements`配置，该配置针对正在寻找其API的消费者。这样的配置是消耗性的，但并不意味着必须解决。这通过a的_canBeConsumed_标志表示`Configuration`：

示例4.设置配置

`Groovy``Kotlin`

build.gradle

configurations \{ // A configuration meant for consumers that need the API of this component exposedApi \{ // This configuration is an "outgoing" configuration, it's not meant to be resolved canBeResolved = false // As an outgoing configuration, explain that consumers may want to consume it canBeConsumed = true \} // A configuration meant for consumers that need the implementation of this component exposedRuntime \{ canBeResolved = false canBeConsumed = true \} \}

 

1

configurations \{

2

 // A configuration meant for consumers that need the API of this component

3

 exposedApi \{

4

 // This configuration is an "outgoing" configuration, it's not meant to be resolved

5

 canBeResolved \= false

6

 // As an outgoing configuration, explain that consumers may want to consume it

7

 canBeConsumed \= true

8

 \}

9

 // A configuration meant for consumers that need the implementation of this component

10

 exposedRuntime \{

11

 canBeResolved \= false

12

 canBeConsumed \= true

13

 \}

14

\}

简而言之，配置的角色由`canBeResolved`和`canBeConsumed`标志组合确定：

<table class="tableblock frame-all grid-all stretch" style="background:white;"><caption class="title" style="font-style: italic;"><font><font>表1.配置角色</font></font></caption><colgroup><col><col><col></colgroup><tbody><tr><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>配置角色</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>可以解决</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>可以食用</font></font></p></td></tr><tr style="background:rgb(248, 248, 247);"><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>依赖桶</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>假</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>假</font></font></p></td></tr><tr><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>解决某些用途</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>真正</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>假</font></font></p></td></tr><tr style="background:rgb(248, 248, 247);"><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>暴露给消费者</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>假</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>真正</font></font></p></td></tr><tr><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>旧版，请勿使用</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>真正</font></font></p></td><td class="tableblock halign-left valign-top" style="color:rgba(0, 0, 0, 0.8);"><p class="tableblock" style="color: rgb(2, 48, 58);"><font><font>真正</font></font></p></td></tr></tbody></table>

为了向后兼容，两个标志的默认值均为`true`，但是作为插件作者，您应始终为这些标志确定正确的值，否则可能会意外引入解析错误。

## [](#sec:choosing-configuration)[为依赖项选择正确的配置](#sec:choosing-configuration)

声明依赖项的配置的选择很重要。但是，没有固定的规则必须将依赖项放入哪个配置中。它主要取决于配置的组织方式，这通常是所应用插件的属性。

例如，在`java`插件中，创建的配置已[记录在案，]()并应根据其在代码中的作用，作为确定在哪里声明依赖项的基础。

作为建议，插件应明确记录其配置链接在一起的方式，并应尽最大努力隔离其[角色](#sec:resolvable-consumable-configs)。

## [](#sec:defining-custom-configurations)[定义自定义配置](#sec:defining-custom-configurations)

您可以自己定义配置，即所谓的_自定义配置_。定制配置对于分离专用目的所需的依赖项范围很有用。

比方说，你想声明的依赖[碧玉Ant任务](https://tomcat.apache.org/tomcat-9.0-doc/jasper-howto.html)为应预编译JSP文件的目的_不是_在classpath最终编译源代码。通过引入自定义配置并在任务中使用它来实现该目标相当简单。

例子5.声明和使用定制配置

`Groovy``Kotlin`

build.gradle

configurations \{ jasper \} repositories \{ mavenCentral\(\) \} dependencies \{ jasper 'org.apache.tomcat.embed:tomcat-embed-jasper:9.0.2' \} task preCompileJsps \{ doLast \{ ant.taskdef\(classname: 'org.apache.jasper.JspC', name: 'jasper', classpath: configurations.jasper.asPath\) ant.jasper\(validateXml: false, uriroot: file\('src/main/webapp'\), outputDir: file\("\$buildDir/compiled-jsps"\)\) \} \}

 

1

configurations \{

2

 jasper

3

\}

4

5

repositories \{

6

 mavenCentral\(\)

7

\}

8

9

dependencies \{

10

 jasper 'org.apache.tomcat.embed:tomcat-embed-jasper:9.0.2'

11

\}

12

13

task preCompileJsps \{

14

 doLast \{

15

 ant.taskdef\(classname: 'org.apache.jasper.JspC',

16

 name: 'jasper',

17

 classpath: configurations.jasper.asPath\)

18

 ant.jasper\(validateXml: false,

19

 uriroot: file\('src/main/webapp'\),

20

 outputDir: file\("\$buildDir/compiled-jsps"\)\)

21

 \}

22

\}

项目的配置由`configurations`对象管理。配置具有名称，并且可以相互扩展。要了解有关此API的更多信息，请查看[ConfigurationContainer]()。

## [](#sec:dependency-types)[不同种类的依赖](#sec:dependency-types)

### [](#sub:module_dependencies)[模块依赖](#sub:module_dependencies)

模块依赖性是最常见的依赖性。它们引用存储库中的模块。

例子6.模块依赖

`Groovy``Kotlin`

build.gradle

dependencies \{ runtimeOnly group: 'org.springframework', name: 'spring-core', version: '2.5' runtimeOnly 'org.springframework:spring-core:2.5', 'org.springframework:spring-aop:2.5' runtimeOnly\( \[group: 'org.springframework', name: 'spring-core', version: '2.5'\], \[group: 'org.springframework', name: 'spring-aop', version: '2.5'\] \) runtimeOnly\('org.hibernate:hibernate:3.0.5'\) \{ transitive = true \} runtimeOnly group: 'org.hibernate', name: 'hibernate', version: '3.0.5', transitive: true runtimeOnly\(group: 'org.hibernate', name: 'hibernate', version: '3.0.5'\) \{ transitive = true \} \}

 

1

dependencies \{

2

 runtimeOnly group: 'org.springframework', name: 'spring-core', version: '2.5'

3

 runtimeOnly 'org.springframework:spring-core:2.5',

4

 'org.springframework:spring-aop:2.5'

5

 runtimeOnly\(

6

 \[group: 'org.springframework', name: 'spring-core', version: '2.5'\],

7

 \[group: 'org.springframework', name: 'spring-aop', version: '2.5'\]

8

 \)

9

 runtimeOnly\('org.hibernate:hibernate:3.0.5'\) \{

10

 transitive \= true

11

 \}

12

 runtimeOnly group: 'org.hibernate', name: 'hibernate', version: '3.0.5', transitive: true

13

 runtimeOnly\(group: 'org.hibernate', name: 'hibernate', version: '3.0.5'\) \{

14

 transitive \= true

15

 \}

16

\}

有关更多示例和完整参考，请参阅API文档中的[DependencyHandler]()类。

Gradle为模块依赖性提供了不同的表示法。有一个字符串符号和一个映射符号。模块依赖性具有允许进一步配置的API。看一看[ExternalModuleDependency，]()以了解有关API的全部信息。该API提供了属性和配置方法。通过字符串符号，您可以定义属性的子集。使用地图符号可以定义所有属性。要使用映射或字符串表示法访问完整的API，可以将单个依赖项与闭包一起分配给配置。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>如果要声明模块依赖，摇篮查找模块元数据文件（</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">.module</code><font><font>，</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">.pom</code><font><font>或</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">ivy.xml</code><font><font>）的存储库。</font><font>如果存在这样的模块元数据文件，则对其进行解析，并下载该模块的工件（例如</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">hibernate-3.0.5.jar</code><font><font>）及其依赖项（例如</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">cglib</code><font><font>）。</font><font>如果不存在这样的模块元数据文件，那么从Gradle 6.0开始，您需要配置</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>元数据源定义</font></font></a><font><font>以查找</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">hibernate-3.0.5.jar</code><font><font>直接</font><font>调用的工件文件</font><font>。</font></font></p></div></td></tr></tbody></table>

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>在Maven中，一个模块只能有一个工件。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>在Gradle和Ivy中，一个模块可以具有多个工件。</font><font>每个工件可以具有不同的依赖关系集。</font></font></p></div></td></tr></tbody></table>

### [](#sub:file_dependencies)[文件依赖](#sub:file_dependencies)

项目有时不依赖于二进制存储库产品（例如JFrog Artifactory或Sonatype Nexus）来托管和解决外部依赖项。通常的做法是将这些依赖项托管在共享驱动器上，或者将其与项目源代码一起放入版本控制中。这些依赖关系称为_文件依赖关系_，原因是它们表示文件没有附加任何[元数据]()（例如有关传递依赖关系，源或其作者的信息）。

图3.解决本地文件系统和共享驱动器中的文件依赖性

以下示例解析文件从目录的依赖`ant`，`libs`和`tools`。

例子7.声明多个文件依赖

`Groovy``Kotlin`

build.gradle

configurations \{ antContrib externalLibs deploymentTools \} dependencies \{ antContrib files\('ant/antcontrib.jar'\) externalLibs files\('libs/commons-lang.jar', 'libs/log4j.jar'\) deploymentTools\(fileTree\('tools'\) \{ include '\*.exe' \}\) \}

 

1

configurations \{

2

 antContrib

3

 externalLibs

4

 deploymentTools

5

\}

6

7

dependencies \{

8

 antContrib files\('ant/antcontrib.jar'\)

9

 externalLibs files\('libs/commons-lang.jar', 'libs/log4j.jar'\)

10

 deploymentTools\(fileTree\('tools'\) \{ include '\*.exe' \}\)

11

\}

在代码示例中可以看到，每个依赖项都必须定义其在文件系统中的确切位置。创建文件引用最突出的方法是[Project.files（java.lang.Object中...）]()，[ProjectLayout.files（java.lang.Object中...）]()和[Project.fileTree（java.lang.Object中）]()或者，您也可以还以[平面目录存储库]()的形式定义一个或多个文件依赖项的源目录。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>中的文件顺序</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">FileTree</code><font><font>不稳定，即使在一台计算机上也是如此。</font><font>这意味着以这种结构作为种子的依赖项配置可能会产生具有不同顺序的解析结果，可能会影响使用结果作为输入的任务的可缓存性。</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">files</code><font><font>建议尽可能</font><font>使用更简单的方法</font><font>。</font></font></p></div></td></tr></tbody></table>

文件依赖性使您可以直接将一组文件添加到配置中，而无需先将它们添加到存储库中。如果您不能或不想将某些文件放在存储库中，这将很有用。或者，如果您根本不想使用任何存储库来存储依赖项。

要将某些文件添加为配置的依赖项，只需将[文件集合]()作为依赖项传递：

例子8.文件依赖

`Groovy``Kotlin`

build.gradle

dependencies \{ runtimeOnly files\('libs/a.jar', 'libs/b.jar'\) runtimeOnly fileTree\('libs'\) \{ include '\*.jar' \} \}

 

1

dependencies \{

2

 runtimeOnly files\('libs/a.jar', 'libs/b.jar'\)

3

 runtimeOnly fileTree\('libs'\) \{ include '\*.jar' \}

4

\}

文件依赖项不包含在项目的已发布依赖项描述符中。但是，文件依赖关系包含在同一构建中的可传递项目依赖关系中。这意味着它们不能在当前版本之外使用，但可以在同一版本内使用。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>中的文件顺序</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">FileTree</code><font><font>不稳定，即使在一台计算机上也是如此。</font><font>这意味着以这种结构作为种子的依赖项配置可能会产生具有不同顺序的解析结果，可能会影响使用结果作为输入的任务的可缓存性。</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">files</code><font><font>建议尽可能</font><font>使用更简单的方法</font><font>。</font></font></p></div></td></tr></tbody></table>

您可以声明产生文件依赖性的任务。例如，当文件由构建生成时，您可以执行此操作。

例子9.生成的文件依赖性

`Groovy``Kotlin`

build.gradle

dependencies \{ implementation files\("\$buildDir/classes"\) \{ builtBy 'compile' \} \} task compile \{ doLast \{ println 'compiling classes' \} \} task list\(dependsOn: configurations.compileClasspath\) \{ doLast \{ println "classpath = \$\{configurations.compileClasspath.collect \{ File file -> file.name \}\}" \} \}

 

1

dependencies \{

2

 implementation files\("\$buildDir/classes"\) \{

3

 builtBy 'compile'

4

 \}

5

\}

6

7

task compile \{

8

 doLast \{

9

 println 'compiling classes'

10

 \}

11

\}

12

13

task list\(dependsOn: configurations.compileClasspath\) \{

14

 doLast \{

15

 println "classpath = \$\{configurations.compileClasspath.collect \{ File file -> file.name \}\}"

16

 \}

17

\}

\$ gradle -q列表 编译类 classpath = \[类\]

#### [](#sec:versioning_file_dependencies)[文件依赖的版本控制](#sec:versioning_file_dependencies)

建议明确表达其意图和文件依赖性的具体版本。Gradle的[版本冲突解决方案]()不考虑文件依赖性。因此，为文件名分配一个版本以指示其附带的不同更改集是非常重要的。例如，`commons-beanutils-1.3.jar`让您通过发行说明跟踪库的更改。

因此，项目的依存关系更易于维护和组织。通过分配的版本发现潜在的API不兼容要容易得多。

### [](#sub:project_dependencies)[项目依赖](#sub:project_dependencies)

软件项目通常将软件组件分解为模块，以提高可维护性并防止强耦合。模块可以定义彼此之间的依赖关系，以在同一项目中重用代码。

图4.项目之间的依赖关系

Gradle可以对模块之间的依赖关系进行建模。这些依赖关系称为_项目依赖关系，_因为每个模块均由Gradle项目表示。

例子10.项目依赖

`Groovy``Kotlin`

build.gradle

dependencies \{ implementation project\(':shared'\) \}

 

1

dependencies \{

2

 implementation project\(':shared'\)

3

\}

在运行时，该构建会自动确保以正确的顺序构建项目依赖项，并将其添加到类路径中以进行编译。“[创作多项目构建]()”一章讨论了如何更详细地设置和配置多项目构建。

有关更多信息，请参见[ProjectDependency]()的API文档。

以下示例从项目中声明对`utils`and`api`项目的依赖关系`web-service`。方法[Project.project（java.lang.String）]()通过路径创建对特定子项目的引用。

例子11.声明项目依赖

`Groovy``Kotlin`

网络服务/build.gradle

dependencies \{ implementation project\(':utils'\) implementation project\(':api'\) \}

 

1

dependencies \{

2

 implementation project\(':utils'\)

3

 implementation project\(':api'\)

4

\}

### [](#local_forks_of_module_dependencies)[模块依赖性的本地分支](#local_forks_of_module_dependencies)

如果模块本身是使用Gradle构建的，则模块依赖性可以由对该模块源的本地fork的依赖性替代。这可以通过使用[复合构建]()来完成。例如，这允许您通过使用并构建本地修补版本而不是已发布的二进制版本来修复在应用程序中使用的库中的问题。有关此内容的详细信息，请参见[组合构建]()部分。

### [](#sub:gradle_distribution_dependencies)[Gradle特定于发行版的依赖性](#sub:gradle_distribution_dependencies)

#### [](#sub:api_dependencies)[Gradle API依赖性](#sub:api_dependencies)

您可以使用[DependencyHandler.gradleApi（）]()方法声明对当前版本的Gradle API的[依赖关系]()。在开发自定义Gradle任务或插件时，这很有用。

例子12. Gradle API的依赖

`Groovy``Kotlin`

build.gradle

dependencies \{ implementation gradleApi\(\) \}

 

1

dependencies \{

2

 implementation gradleApi\(\)

3

\}

#### [](#sub:testkit_dependencies)[Gradle TestKit依赖性](#sub:testkit_dependencies)

您可以使用[DependencyHandler.gradleTestKit（）]()方法声明对当前版本的Gradle的TestKit API的[依赖关系]()。这对于为Gradle插件和构建脚本编写和执行功能测试很有用。

例子13. Gradle TestKit的依赖

`Groovy``Kotlin`

build.gradle

dependencies \{ testImplementation gradleTestKit\(\) \}

 

1

dependencies \{

2

 testImplementation gradleTestKit\(\)

3

\}

[TestKit一章]()通过示例解释了TestKit的用法。

#### [](#sub:groovy_dependencies)[本地Groovy依赖](#sub:groovy_dependencies)

您可以使用[DependencyHandler.localGroovy（）]()方法声明与Gradle一起分发的Groovy的[依赖关系]()。在Groovy中开发自定义Gradle任务或插件时，这很有用。

例子14. Gradle的Groovy依赖

`Groovy``Kotlin`

build.gradle

dependencies \{ implementation localGroovy\(\) \}

 

1

dependencies \{

2

 implementation localGroovy\(\)

3

\}

## [](#sec:documenting-dependencies)[记录依赖性](#sec:documenting-dependencies)

声明依赖项或[依赖项约束时]()，可以提供声明的自定义原因。这使构建脚本中的依赖项声明和[依赖项见解报告]()更易于解释。

例子15.给出在依赖声明中选择某个模块版本的原因

`Groovy``Kotlin`

build.gradle

plugins \{ id 'java-library' \} repositories \{ jcenter\(\) \} dependencies \{ implementation\('org.ow2.asm:asm:7.1'\) \{ because 'we require a JDK 9 compatible bytecode generator' \} \}

 

1

plugins \{

2

 id 'java-library'

3

\}

4

5

repositories \{

6

 jcenter\(\)

7

\}

8

9

dependencies \{

10

 implementation\('org.ow2.asm:asm:7.1'\) \{

11

 because 'we require a JDK 9 compatible bytecode generator'

12

 \}

13

\}

### [](#example_using_the_dependency_insight_report_with_custom_reasons)[示例：以自定义原因使用依赖关系洞察报告](#example_using_the_dependency_insight_report_with_custom_reasons)

输出**`gradle -q dependencyInsight --dependency asm`**

\> gradle -qdependencyInsight-依赖关系asm org.ow2.asm：asm：7.1 变体“编译” \[ org.gradle.status =发布（不要求） org.gradle.usage = java-api org.gradle.libraryelements = jar（与以下类兼容） org.gradle.category =库
 在所选变体中找不到请求的属性： org.gradle.dependency.bundling =外部 org.gradle.jvm.version = 11 \] 选择理由： -被要求：我们需要兼容JDK 9的字节码生成器
 org.ow2.asm：asm：7.1 \\-编译类路径
 通过添加--scan选项，可以使用基于Web的可搜索依赖项报告。

## [](#sec:resolve_specific_artifacts_from_dependency)[通过模块依赖性解决特定工件](#sec:resolve_specific_artifacts_from_dependency)

每当Gradle尝试从Maven或Ivy存储库解析模块时，它都会查找元数据文件和默认工件文件JAR。如果这些工件文件都无法解析，则构建将失败。在某些情况下，您可能需要调整Gradle解决依赖关系工件的方式。

* 依赖项仅提供非标准工件，没有任何元数据（例如ZIP文件）。
* 模块元数据声明了多个工件，例如，作为常春藤依赖描述符的一部分。
* 您只想下载特定的工件，而无需在元数据中声明任何传递依赖项。

Gradle是一个多语言构建工具，不仅限于解析Java库。假设您想使用JavaScript作为客户端技术来构建Web应用程序。大多数项目将外部JavaScript库检入版本控制。外部JavaScript库与可重用Java库没有什么不同，那么为什么不从存储库中下载它呢？

[Google托管库](https://developers.google.com/speed/libraries/)是一个流行的开源JavaScript库的分发平台。借助仅工件的符号，您可以下载JavaScript库文件，例如JQuery。该`@`字符将依赖项的坐标与工件的文件扩展名分开。

例子16.为一个声明的依赖关系解析一个JavaScript工件

`Groovy``Kotlin`

build.gradle

repositories \{ ivy \{ url 'https://ajax.googleapis.com/ajax/libs' patternLayout \{ artifact '\[organization\]/\[revision\]/\[module\].\[ext\]' \} metadataSources \{ artifact\(\) \} \} \} configurations \{ js \} dependencies \{ js 'jquery:jquery:3.2.1\@js' \}

 

1

repositories \{

2

 ivy \{

3

 url 'https://ajax.googleapis.com/ajax/libs'

4

 patternLayout \{

5

 artifact '\[organization\]/\[revision\]/\[module\].\[ext\]'

6

 \}

7

 metadataSources \{

8

 artifact\(\)

9

 \}

10

 \}

11

\}

12

13

configurations \{

14

 js

15

\}

16

17

dependencies \{

18

 js 'jquery:jquery:3.2.1\@js'

19

\}

某些模块提供了相同工件的不同“风味”，或者它们发布了属于特定模块版本但目的不同的多个工件。Java库通常会发布带有已编译类文件的工件，另一个库中仅包含源代码，而第三个库中包含Javadocs。

在JavaScript中，库可能以未压缩或缩小的工件形式存在。在Gradle中，特定的工件标识符称为_分类器_，该术语通常在Maven和Ivy依赖管理中使用。

假设我们要下载JQuery库的精简构件，而不是未压缩的文件。您可以`min`在依赖项声明中提供分类器。

例子17.用分类器解析一个JavaScript工件以获得一个声明的依赖关系

`Groovy``Kotlin`

build.gradle

repositories \{ ivy \{ url 'https://ajax.googleapis.com/ajax/libs' patternLayout \{ artifact '\[organization\]/\[revision\]/\[module\]\(.\[classifier\]\).\[ext\]' \} metadataSources \{ artifact\(\) \} \} \} configurations \{ js \} dependencies \{ js 'jquery:jquery:3.2.1:min\@js' \}

 

1

repositories \{

2

 ivy \{

3

 url 'https://ajax.googleapis.com/ajax/libs'

4

 patternLayout \{

5

 artifact '\[organization\]/\[revision\]/\[module\]\(.\[classifier\]\).\[ext\]'

6

 \}

7

 metadataSources \{

8

 artifact\(\)

9

 \}

10

 \}

11

\}

12

13

configurations \{

14

 js

15

\}

16

17

dependencies \{

18

 js 'jquery:jquery:3.2.1:min\@js'

19

\}

## [](#sec:supported-metadata-formats)[支持的元数据格式](#sec:supported-metadata-formats)

外部模块依赖关系需要模块元数据（因此，Gradle通常可以确定模块的传递依赖关系）。为此，Gradle支持不同的元数据格式。

您还可以调整将在[存储库定义中]()查找哪种格式。

### [](#sub:supported-md-gradle)[Gradle模块元数据文件](#sub:supported-md-gradle)

Gradle模块元数据经过专门设计，可支持Gradle依赖性管理模型的所有功能，因此是首选格式。您可以[在此处](https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md)找到其[规格](https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md)。

### [](#sub:supported-md-pom)[POM文件](#sub:supported-md-pom)

Gradle本机支持[Maven POM文件](https://maven.apache.org/pom.html)。值得注意的是，默认情况下，Gradle首先会查找POM文件，但是如果该文件包含特殊标记，则Gradle将改用[Gradle Module元数据](#sub:supported-md-gradle)。

### [](#sub:supported-md-ivy)[常春藤文件](#sub:supported-md-ivy)

同样，Gradle支持[Apache Ivy元数据文件](http://ant.apache.org/ivy/)。同样，Gradle将首先查找`ivy.xml`文件，但是如果该文件包含特殊标记，则Gradle将改为使用[Gradle模块元数据](#sub:supported-md-gradle)。