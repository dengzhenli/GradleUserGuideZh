 无标题 <style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body { padding-left: 48px; padding-right: 48px;}</style>

# 依赖管理术语

内容

* [神器](#sub:terminology_artifact)
* [能力](#sub:terminology_capability)
* [零件](#sub:terminology_component)
* [组态](#sub:terminology_configuration)
* [相依性](#sub:terminology_dependency)
* [依赖约束](#sub:terminology_dependency_constraint)
* [功能变体](#sub:terminology_feature_variant)
* [模组](#sub:terminology_module)
* [模块元数据](#sub:terminology_module_metadata)
* [组件元数据规则](#component_metadata_rule)
* [模块版本](#sub:terminology_module_version)
* [平台](#sub::terminology_platform)
* [出版物](#sub:terminology_publication)
* [资料库](#sub:terminology_repository)
* [解析规则](#sub:terminology_resolution_rule)
* [传递依存关系](#sub:terminology_transitive_dependency)
* [（组件的）变体](#sub:terminology_variant)
* [变体属性](#sub:terminology_attribute)

依赖性管理带有大量术语。在这里，您可以找到最常用的术语，包括对用户指南的引用，以了解其实际应用。

## [](#sub:terminology_artifact)[神器](#sub:terminology_artifact)

生成的文件或目录，例如JAR，ZIP发行版或本机可执行文件。

通常将工件设计为供用户或其他项目使用或使用，或部署到托管系统。在这种情况下，工件是单个文件。在项目间相关性的情况下，目录是常见的，以避免产生可发布工件的成本。

## [](#sub:terminology_capability)[能力](#sub:terminology_capability)

功能标识由一个或多个组件提供的功能。通过类似于用于[模块版本](#sub:terminology_module_version)的坐标的坐标来标识能力。默认情况下，每个模块版本均提供与其坐标匹配的功能，例如`com.google:guava:18.0`。功能可以用来表示一个组件提供了多个[功能变体，](#sub:terminology_feature_variant)或者两个不同的组件实现了相同的功能（因此不能一起使用）。有关更多详细信息，请参见[功能]()部分。

## [](#sub:terminology_component)[零件](#sub:terminology_component)

[模块的](#sub:terminology_module)任何单一版本。

对于外部库，术语组件是指该库的一个发行版本。

在构建中，组件由插件（例如Java库插件）定义，并提供一种简单的方式来定义要发布的发布。它们包括[工件](#sub:terminology_artifact)以及适当的[元数据](#sub:terminology_artifact)，这些[元数据](#sub:terminology_artifact)详细描述了组件的[变体](#sub:terminology_variant)。例如，`java`默认设置中的组件由`jar`任务生成的JAR以及Java_api_和_运行时_变体的依赖项信息组成。它还可以使用相应的工件定义其他变体，例如_源_和_Javadoc_。

## [](#sub:terminology_configuration)[组态](#sub:terminology_configuration)

配置是为特定目标分组在一起的一组命名的[依赖项](#sub:terminology_dependency)。配置提供对基础的，已解析的[模块](#sub:terminology_module)及其工件的访问。有关更多信息，请参见有关[依赖项配置]()以及[可解析和易用配置的各节]()。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>单词“配置”是一个重载术语，在依赖项管理的上下文之外具有不同的含义。</font></font></p></div></td></tr></tbody></table>

## [](#sub:terminology_dependency)[相依性](#sub:terminology_dependency)

依赖关系是构建，测试或运行[模块](#sub:terminology_module)所需的另一软件的指针。有关更多信息，请参见关于[声明依赖项]()的部分。

## [](#sub:terminology_dependency_constraint)[依赖约束](#sub:terminology_dependency_constraint)

依赖关系约束定义了模块要使其成为依赖关系的有效解决结果所需要满足的要求。例如，依赖关系约束可以缩小支持的模块版本的范围。依赖关系约束可用于表达对传递性依赖关系的此类要求。有关更多信息，请参见有关[升级]()和[降级]()传递依赖项的部分。

## [](#sub:terminology_feature_variant)[功能变体](#sub:terminology_feature_variant)

特征变体是表示可以单独选择或不能单独选择的组件特征的变[体](#sub:terminology_variant)。一个功能变体由一个或多个[功能](#sub:terminology_capability)标识。有关更多信息，请参见有关[模型特征变体和可选依赖项的部分]()。

## [](#sub:terminology_module)[模组](#sub:terminology_module)

随时间推移而发展的软件，例如[Google Guava](https://github.com/google/guava)。每个模块都有一个名称。模块的每个发行版均以[模块版本](#sub:terminology_module_version)为代表。为了方便使用，可以将模块托管在[资源库中](#sub:terminology_repository)。

## [](#sub:terminology_module_metadata)[模块元数据](#sub:terminology_module_metadata)

[模块的](#sub:terminology_module)发行版提供元数据。元数据是更详细地描述模块的数据，例如有关工件位置或所需[传递依赖项的信息](#sub:terminology_transitive_dependency)。Gradle提供了自己的元数据格式，称为[Gradle模块元数据](https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md)（`.module`文件），但也支持Maven（`.pom`）和Ivy（`ivy.xml`）元数据。有关支持的元数据格式的更多信息，请参见[了解Gradle模块元数据]()的部分。

## [](#component_metadata_rule)[组件元数据规则](#component_metadata_rule)

组件元数据规则是在从存储库中提取组件的元数据后对其进行修改的规则，例如，添加丢失的信息或纠正错误的信息。与[解析规则](#sub:terminology_resolution_rule)相反，**在**解析开始**之前**会应用组件元数据规则。组件元数据规则定义为构建逻辑的一部分，可以通过插件共享。有关更多信息，请参见有关[使用组件元数据规则修复元数据的部分]()。

## [](#sub:terminology_module_version)[模块版本](#sub:terminology_module_version)

模块版本表示已发布[模块](#sub:terminology_module)的一组不同的更改。例如`18.0`，使用坐标表示模块的版本`com.google:guava:18.0`。实际上，对模块版本的方案没有限制。时间戳，数字，特殊后缀等`-GA`都是允许的标识符。最广泛使用的版本控制策略是[语义版本控制](https://semver.org/)。

## [](#sub::terminology_platform)[平台](#sub::terminology_platform)

平台是旨在一起使用的一组模块。平台有不同类别，对应于不同的用例：

* 模块集：通常是作为一个整体发布的一组模块。使用集合中的一个模块通常意味着我们要对集合中的所有模块使用相同的版本。例如，如果使用`groovy`1.2，则也使用`groovy-json`1.2。
* 运行时环境：一组可以很好地协同工作的库。例如，Spring Platform，为Spring和与Spring一起使用的组件推荐了版本。
* 部署环境：Java运行时，应用服务器，...

另外，Gradle定义了[虚拟平台]()。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>Maven的BOM（物料清单）是</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>Gradle支持的</font></font></a><font><font>一种流行的平台</font><font>。</font></font></p></div></td></tr></tbody></table>

## [](#sub:terminology_publication)[出版物](#sub:terminology_publication)

对文件和元数据的描述，这些文件和元数据应作为单个实体发布给存储库，以供使用者使用。

出版物具有名称，由一个或多个工件以及有关这些工件的信息（[元数据](#sub:terminology_module_metadata)）组成。

## [](#sub:terminology_repository)[资料库](#sub:terminology_repository)

存储库托管一组[模块](#sub:terminology_module)，每个[模块](#sub:terminology_module)可以提供一个或多个由[模块版本](#sub:terminology_module_version)指示的发行版（组件）。该存储库可以基于二进制存储库产品（例如Artifactory或Nexus）或文件系统中的目录结构。有关更多信息，请参见[声明存储库]()。

## [](#sub:terminology_resolution_rule)[解析规则](#sub:terminology_resolution_rule)

解决规则会影响直接解决[依赖项](#sub:terminology_dependency)的行为。解析规则被定义为构建逻辑的一部分。有关更多信息，请参见[直接自定义依赖项解析]()的部分。

## [](#sub:terminology_transitive_dependency)[传递依存关系](#sub:terminology_transitive_dependency)

[组件](#sub:terminology_component)的变体可以依赖于其他模块才能正常工作，即所谓的传递依赖。托管在[存储库](#sub:terminology_repository)上的模块的发行版可以提供[元数据](#sub:terminology_module_metadata)来声明这些可传递依赖项。默认情况下，Gradle自动解析传递依赖。声明[依赖约束]()可以影响可传递依赖的版本选择。

## [](#sub:terminology_variant)[（组件的）变体](#sub:terminology_variant)

每个[组件都](#sub:terminology_component)包含一个或多个变体。变体由一组工件组成，并定义了一组依赖项。它由一组[属性](#sub:terminology_attribute)和[功能](#sub:terminology_capability)标识。

Gradle的依赖项解决方案可识别变体，并在选择组件（即模块的一个版本）后为每个组件选择一个或多个变体。如果变体选择结果不明确，也可能会失败，这意味着Gradle没有足够的信息来选择多个互斥变体之一。在这种情况下，可以通过[变量属性](#sub:terminology_attribute)提供更多信息。每个Java组件通常提供的变体示例是_api_和_运行时_变体。其他示例是JDK8和JDK11变体。有关更多信息，请参见[变量选择]()部分。

## [](#sub:terminology_attribute)[变体属性](#sub:terminology_attribute)

属性用于识别和选择[变体](#sub:terminology_variant)。变体具有限定，例如一个或多个属性`org.gradle.usage=java-api`，`org.gradle.jvm.version=11`。解决依赖关系后，将请求一组属性，并且Gradle会为依赖关系图中的每个组件找到最合适的变量。可以为属性实现兼容性和消歧规则，以表达值之间的兼容性（例如Java 8与Java 11兼容，但是如果请求的版本为11或更高版本，则应该首选Java 11）。此类规则通常由插件提供。有关更多信息，请参见有关[变量选择]()和[声明属性的部分]()。