 无标题 <style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body { padding-left: 48px; padding-right: 48px;}</style><style id="wiz_code_style">.wiz-editor-body .wiz-code-container{position: relative; padding:8px 0; margin: 5px 0;text-indent:0; text-align:left;}.CodeMirror {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; color: black; font-size: 10.5pt; font-size: 0.875rem}.wiz-editor-body .wiz-code-container .CodeMirror div {margin-top: 0; margin-bottom: 0;}.CodeMirror-lines {padding: 4px 0;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {padding: 0 4px;}.CodeMirror pre.CodeMirror-line {min-height: 24px;}.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {background-color: white;}.CodeMirror-gutters {border-right: 1px solid #ddd; background-color: #f7f7f7; white-space: nowrap;}.CodeMirror-linenumbers {}.CodeMirror-linenumber {padding: 0 3px 0 5px; min-width: 20px; text-align: right; color: #999; white-space: nowrap;}.CodeMirror-guttermarker {color: black;}.CodeMirror-guttermarker-subtle {color: #999;}.CodeMirror-cursor {border-left: 1px solid black; border-right: none; width: 0;}.CodeMirror div.CodeMirror-secondarycursor {border-left: 1px solid silver;}.cm-fat-cursor .CodeMirror-cursor {width: auto; border: 0 !important; background: #7e7;}.cm-fat-cursor div.CodeMirror-cursors {z-index: 1;}.cm-fat-cursor-mark {background-color: rgba(20, 255, 20, 0.5);-webkit-animation: blink 1.06s steps(1) infinite;-moz-animation: blink 1.06s steps(1) infinite;animation: blink 1.06s steps(1) infinite;}.cm-animate-fat-cursor {width: auto; border: 0; -webkit-animation: blink 1.06s steps(1) infinite; -moz-animation: blink 1.06s steps(1) infinite; animation: blink 1.06s steps(1) infinite; background-color: #7e7;}@-moz-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@-webkit-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}.CodeMirror-overwrite .CodeMirror-cursor {}.cm-tab { display: inline-block; text-decoration: inherit; }.CodeMirror-rulers {position: absolute; left: 0; right: 0; top: -50px; bottom: -20px; overflow: hidden;}.CodeMirror-ruler {border-left: 1px solid #ccc; top: 0; bottom: 0; position: absolute;}.cm-s-default .cm-header {color: blue;}.cm-s-default .cm-quote {color: #090;}.cm-negative {color: #d44;}.cm-positive {color: #292;}.cm-header, .cm-strong {font-weight: bold;}.cm-em {font-style: italic;}.cm-link {text-decoration: underline;}.cm-strikethrough {text-decoration: line-through;}.cm-s-default .cm-keyword {color: #708;}.cm-s-default .cm-atom {color: #219;}.cm-s-default .cm-number {color: #164;}.cm-s-default .cm-def {color: #00f;}.cm-s-default .cm-variable,.cm-s-default .cm-punctuation,.cm-s-default .cm-property,.cm-s-default .cm-operator {}.cm-s-default .cm-variable-2 {color: #05a;}.cm-s-default .cm-variable-3 {color: #085;}.cm-s-default .cm-comment {color: #a50;}.cm-s-default .cm-string {color: #a11;}.cm-s-default .cm-string-2 {color: #f50;}.cm-s-default .cm-meta {color: #555;}.cm-s-default .cm-qualifier {color: #555;}.cm-s-default .cm-builtin {color: #30a;}.cm-s-default .cm-bracket {color: #997;}.cm-s-default .cm-tag {color: #170;}.cm-s-default .cm-attribute {color: #00c;}.cm-s-default .cm-hr {color: #999;}.cm-s-default .cm-link {color: #00c;}.cm-s-default .cm-error {color: #f00;}.cm-invalidchar {color: #f00;}.CodeMirror-composing { border-bottom: 2px solid; }div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }.CodeMirror-activeline-background {background: #e8f2ff;}.CodeMirror {position: relative; background: #f5f5f5;}.CodeMirror-scroll {overflow: hidden !important; margin-bottom: 0; margin-right: -30px; padding: 16px 30px 16px 0; outline: none; position: relative;}.CodeMirror-sizer {position: relative; border-right: 30px solid transparent;}.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {position: absolute; z-index: 6; display: none;}.CodeMirror-vscrollbar {right: 0; top: 0; overflow-x: hidden; overflow-y: scroll;}.CodeMirror-hscrollbar {bottom: 0; left: 0 !important; overflow-y: hidden; overflow-x: scroll;pointer-events: auto !important;outline: none;}.CodeMirror-scrollbar-filler {right: 0; bottom: 0;}.CodeMirror-gutter-filler {left: 0; bottom: 0;}.CodeMirror-gutters {position: absolute; left: 0; top: 0; min-height: 100%; z-index: 3;}.CodeMirror-gutter {white-space: normal; height: 100%; display: inline-block; vertical-align: top; margin-bottom: -30px;}.CodeMirror-gutter-wrapper {position: absolute; z-index: 4; background: none !important; border: none !important;}.CodeMirror-gutter-background {position: absolute; top: 0; bottom: 0; z-index: 4;}.CodeMirror-gutter-elt {position: absolute; cursor: default; z-index: 4;}.CodeMirror-gutter-wrapper ::selection { background-color: transparent }.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }.CodeMirror-lines {cursor: text; min-height: 1px;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {-moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0; border-width: 0; background: transparent; font-family: inherit; font-size: inherit; margin: 0; white-space: pre; word-wrap: normal; line-height: inherit; color: inherit; z-index: 2; position: relative; overflow: visible; -webkit-tap-highlight-color: transparent; -webkit-font-variant-ligatures: contextual; font-variant-ligatures: contextual;}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like {word-wrap: break-word; white-space: pre-wrap; word-break: normal;}.CodeMirror-linebackground {position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;}.CodeMirror-linewidget {position: relative; z-index: 2; padding: 0.1px;}.CodeMirror-widget {}.CodeMirror-rtl pre { direction: rtl; }.CodeMirror-code {outline: none;}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {-moz-box-sizing: content-box; box-sizing: content-box;}.CodeMirror-measure {position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;}.CodeMirror-cursor {position: absolute; pointer-events: none;}.CodeMirror-measure pre { position: static; }div.CodeMirror-cursors {visibility: hidden; position: relative; z-index: 3;}div.CodeMirror-dragcursors {visibility: visible;}.CodeMirror-focused div.CodeMirror-cursors {visibility: visible;}.CodeMirror-selected { background: #d9d9d9; }.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }.CodeMirror-crosshair { cursor: crosshair; }.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }.cm-searching {background: #ffa; background: rgba(255, 255, 0, .4);}.cm-force-border { padding-right: .1px; }@media print { .CodeMirror div.CodeMirror-cursors {visibility: hidden;}}.cm-tab-wrap-hack:after { content: ""; }span.CodeMirror-selectedtext { background: none; }.CodeMirror-activeline-background, .CodeMirror-selected {transition: visibility 0ms 100ms;}.CodeMirror-blur .CodeMirror-activeline-background, .CodeMirror-blur .CodeMirror-selected {visibility:hidden;}.CodeMirror-blur .CodeMirror-matchingbracket {color:inherit !important;outline:none !important;text-decoration:none !important;}.CodeMirror-sizer {min-height:auto !important;}</style>

# 使用组件元数据规则修复元数据

内容

* [编写组件元数据规则的基础](#basics_of_writing_a_component_metadata_rule)
* [元数据的哪些部分可以修改？](#sec:component_metadata_rules_details)
* [何时使用组件元数据规则？](#when_to_use_component_metadata_rules)
* [修复错误的依赖项详细信息](#fixing_wrong_dependency_details)
* [使发布为分类罐子的变体明确](#making_variants_published_as_classified_jars_explicit)
* [使版本中编码的变体明确](#making_variants_encoded_in_versions_explicit)
* [为本地jar添加变体](#adding_variants_for_native_jars)
* [通过功能使库具有不同的风格](#making_different_flavors_of_a_library_available_through_capabilities)
* [添加缺少的功能来检测冲突](#adding_missing_capabilities_to_detect_conflicts)
* [使常春藤模块能够感知变体](#making_ivy_modules_variant_aware)
* [使用Maven元数据过滤](#filter_using_maven_metadata)
* [在组件级别修改元数据以进行对齐](#modifying_metadata_on_the_component_level_for_alignment)
* [在组件级别上修改元数据以根据状态选择版本](#sec:custom_status_scheme)

从存储库中拉出的每个模块都有与其相关联的元数据，例如其组，名称，版本以及它提供的带有工件和依赖项的不同变体。有时，此元数据不完整或不正确。为了从构建脚本中处理这种不完整的元数据，Gradle提供了一个API来编写_组件元数据规则_。这些规则在下载模块的元数据之后但在依赖关系解析中使用之前生效。

## [](#basics_of_writing_a_component_metadata_rule)[编写组件元数据规则的基础](#basics_of_writing_a_component_metadata_rule)

组件元数据规则应用于构建脚本的依赖关系块（[DependencyHandler]()）的组件（[ComponentMetadataHandler]()）部分中。可以用两种不同的方式定义规则：

1.  直接在_组件_部分中应用它们时作为操作
2.  作为实现[ComponentMetadataRule]()接口的隔离类

虽然将规则内联定义为动作可以方便实验，但通常建议将规则定义为单独的类。可以对编写为隔离类的规则进行注释，`@CacheableRule`以缓存其应用程序的结果，从而使每次解决依赖性时都无需重新执行它们。

示例1.可配置组件元数据规则的示例

`Groovy``Kotlin`

build.gradle

class TargetJvmVersionRule implements ComponentMetadataRule \{ final Integer jvmVersion \@Inject TargetJvmVersionRule\(Integer jvmVersion\) \{ this.jvmVersion = jvmVersion \} \@Inject ObjectFactory getObjects\(\) \{ \} void execute\(ComponentMetadataContext context\) \{ context.details.withVariant\("compile"\) \{ attributes \{ attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, jvmVersion\) attribute\(Usage.USAGE\_ATTRIBUTE, objects.named\(Usage, Usage.JAVA\_API\)\) \} \} \} \} dependencies \{ components \{ withModule\("commons-io:commons-io", TargetJvmVersionRule\) \{ params\(7\) \} withModule\("commons-collections:commons-collections", TargetJvmVersionRule\) \{ params\(8\) \} \} implementation\("commons-io:commons-io:2.6"\) implementation\("commons-collections:commons-collections:3.2.2"\) \}

 

1

class TargetJvmVersionRule implements ComponentMetadataRule \{

2

 final Integer jvmVersion

3

 \@Inject TargetJvmVersionRule\(Integer jvmVersion\) \{

4

 this.jvmVersion \= jvmVersion

5

 \}

6

7

 \@Inject ObjectFactory getObjects\(\) \{ \}

8

9

 void execute\(ComponentMetadataContext context\) \{

10

 context.details.withVariant\("compile"\) \{

11

 attributes \{

12

 attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, jvmVersion\)

13

 attribute\(Usage.USAGE\_ATTRIBUTE, objects.named\(Usage, Usage.JAVA\_API\)\)

14

 \}

15

 \}

16

 \}

17

\}

18

dependencies \{

19

 components \{

20

 withModule\("commons-io:commons-io", TargetJvmVersionRule\) \{

21

 params\(7\)

22

 \}

23

 withModule\("commons-collections:commons-collections", TargetJvmVersionRule\) \{

24

 params\(8\)

25

 \}

26

 \}

27

 implementation\("commons-io:commons-io:2.6"\)

28

 implementation\("commons-collections:commons-collections:3.2.2"\)

29

\}

从上面的示例中可以看出，组件元数据规则是通过实现[ComponentMetadataRule]()来定义的，该[组件]()具有单个`execute`方法来接收[ComponentMetadataContext]()的实例作为参数。在此示例中，还通过[ActionConfiguration]()进一步配置了规则。在您的实现中，可以有一个构造函数来`ComponentMetadataRule`接受配置的参数和需要注入的服务，以此来支持这一点。

Gradle强制隔离的实例`ComponentMetadataRule`。这意味着所有参数必须是`Serializable`可以隔离的或已知的Gradle类型。

此外，可以将Gradle服务注入您的中`ComponentMetadataRule`。因此，一旦有了构造函数，就必须使用进行注释`@javax.inject.Inject`。通常需要使用[ObjectFactory]()服务来创建强类型值对象的实例，例如用于设置[Attribute]()的值。[RepositoryResourceAccessor]()是一项有助于将组件元数据规则与自定义元数据一起高级使用的服务。

组件元数据规则可以应用于所有模块`all(rule)`\-或选定的模块-`withModule(groupAndName, rule)`。通常，专门编写规则以丰富一个特定模块的元数据，因此`withModule`应该首选API。

## [](#sec:component_metadata_rules_details)[元数据的哪些部分可以修改？](#sec:component_metadata_rules_details)

组件元数据规则API面向[Gradle Module元数据](https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md)和构建脚本中的_依赖项_API支持的功能。编写规则与在构建脚本中定义依赖项和工件之间的主要区别在于，组件元数据规则遵循Gradle Module元数据的结构，直接对[变体]()进行操作。相反，在构建脚本中，您经常一次影响多个变量的形状（例如，将_api_依赖项添加到Java库的_api_和_运行时_变量中，由_jar_任务生成的工件也添加到这两个变量中） 。

变体可以通过以下方法进行修改：

* `allVariants`：修改组件的所有变体
* `withVariant(name)`：修改由名称标识的单个变体
* `addVariant(name)`或`addVariant(name, base)`：_从头开始_或通过_复制_现有变体的详细信息（基础）向组件添加新变体

可以调整每个变体的以下详细信息：

* 标识变体的[属性]()\-`attributes {}`块
* 该变体提供的[功能]()\-`withCapabilities { }`块
* 变体的[依赖]()项，包括[丰富的版本]()\-`withDependencies {}`块
* 变体的[依赖关系约束]()，包括[丰富版本]()\-`withDependencyConstraints {}`块
* 构成变体实际内容的已发布文件的位置-`withFiles { }`块

整个组件的一些属性也可以更改：

* 该_组件级的属性_，目前唯一有意义的属性有`org.gradle.status`
* 在版本选择过程中影响属性解释的_状态方案_`org.gradle.status`
* [通过虚拟平台]()进行[版本对齐]()的_belongsTo_属性

根据模块元数据的格式，它以不同的方式映射到元数据的以变量为中心的表示形式：

* 如果模块具有Gradle模块元数据，则规则所基于的数据结构与您在模块`.module`文件中找到的数据结构非常相似。
* 如果仅使用`.pom`元数据发布模块，则将导出许多固定的变体，如[POM文件到变体]()的[映射]()部分中所述。
* 如果模块仅与`ivy.xml`文件一起发布，则可以访问文件中定义的_Ivy配置_，而不是变体。它们的依赖性，依赖性约束和文件可以修改。此外，如果需要，`addVariant(name, baseVariantOrConfiguration) { }`可以使用API从_Ivy配置中_派生变体（例如，可以使用此定义[Java库插件的]()[_编译_和_运行时_变体]()）。

## [](#when_to_use_component_metadata_rules)[何时使用组件元数据规则？](#when_to_use_component_metadata_rules)

通常，如果您考虑使用组件元数据规则来调整某个模块的元数据，则应首先检查该模块是否与Gradle Module Metadata（`.module`文件）或仅与传统元数据一起发布（`.pom`或`ivy.xml`）。

如果使用Gradle Module Metadata发布了模块，则尽管有时仍然存在某些明显错误的情况，但元数据可能已完成。对于这些模块，只有在明确确定元数据本身存在问题的情况下，才应使用组件元数据规则。如果您对依赖项解决结果有疑问，应首先检查是否可以通过声明[丰富版本的依赖项约束]()来解决问题。特别是，如果您正在开发要发布的库，则应记住，与组件元数据规则相反，依赖关系约束是作为您自己的库的元数据的一部分发布的。因此，在具有依赖关系约束的情况下，您可以自动与使用者共享依赖关系解决方案的解决方案，而组件元数据规则仅应用于自己的内部版本。

如果使用传统的元数据（`.pom`或`ivy.xml`仅不`.module`包含文件）发布模块，则元数据很可能不完整，因为这些格式不支持诸如变体或依赖项约束之类的功能。仍然，从概念上讲，此类模块可以包含不同的变体，或者可能具有它们刚刚被忽略（或错误地定义为依赖项）的依赖项约束。在接下来的部分中，我们将探索许多现有的oss模块，这些模块具有不完整的元数据以及添加缺失的元数据信息的规则。

根据经验，您应该考虑所编写的规则是否也适用于构建环境。也就是说，如果将规则应用到其他任何使用受其影响的模块的内部版本中，该规则是否仍会产生正确且有用的结果？

## [](#fixing_wrong_dependency_details)[修复错误的依赖项详细信息](#fixing_wrong_dependency_details)

让我们以[Maven](https://repo1.maven.org/maven2/jaxen/jaxen)Central上Jaxen XPath Engine的发布为例。版本1.1.3的pom在编译范围内声明了许多依赖关系，而这些依赖关系实际上并不是编译所必需的。这些已在1.1.4 pom中删除。假设由于某种原因需要使用1.1.3，我们可以使用以下规则来修复元数据：

示例2.删除Jaxen元数据的未使用依赖项的规则

`Groovy``Kotlin`

build.gradle

class JaxenDependenciesRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ context.details.allVariants \{ withDependencies \{ removeAll \{ it.group in \["dom4j", "jdom", "xerces", "maven-plugins", "xml-apis", "xom"\] \} \} \} \} \}

 

1

class JaxenDependenciesRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 context.details.allVariants \{

4

 withDependencies \{

5

 removeAll \{ it.group in \["dom4j", "jdom", "xerces",  "maven-plugins", "xml-apis", "xom"\] \}

6

 \}

7

 \}

8

 \}

9

\}

在该`withDependencies`块中，您可以访问依赖项的完整列表，并且可以使用Java集合界面上可用的所有方法来检查和修改该列表。另外，有些`add(notation, configureAction)`方法接受通常的表示法，类似于在构建脚本中[声明依赖项]()。可以在`withDependencyConstraints`块中以相同的方式检查和修改依赖性约束。

如果仔细研究Jaxen 1.1.4 pom，我们会发现_dom4j_，_jdom_和_xerces_依赖项仍然存在，但标记为_optional_。podle中的可选依赖项不会由Gradle或Maven自动处理。原因是它们指示Jaxen库提供了一些[可选的功能变体]()，这些[变体]()需要这些依赖项中的一个或多个，但是缺少这些功能是什么以及哪个依赖项属于哪个的信息。此类信息不能在pom文件中表示，而可以通过变体和[功能]()在Gradle模块元数据中表示。因此，我们也可以在规则中添加此信息。

例子3.将可选功能添加到Jaxen元数据的规则

`Groovy``Kotlin`

build.gradle

class JaxenCapabilitiesRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ context.details.addVariant\("runtime-dom4j", "runtime"\) \{ withCapabilities \{ removeCapability\("jaxen", "jaxen"\) addCapability\("jaxen", "jaxen-dom4j", context.details.id.version\) \} withDependencies \{ add\("dom4j:dom4j:1.6.1"\) \} \} \} \}

 

1

class JaxenCapabilitiesRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 context.details.addVariant\("runtime-dom4j", "runtime"\) \{

4

 withCapabilities \{

5

 removeCapability\("jaxen", "jaxen"\)

6

 addCapability\("jaxen", "jaxen-dom4j", context.details.id.version\)

7

 \}

8

 withDependencies \{

9

 add\("dom4j:dom4j:1.6.1"\)

10

 \}

11

 \}

12

 \}

13

\}

在这里，我们首先使用该`addVariant(name, baseVariant)`方法创建一个附加变体，通过定义新功能_jaxen-dom4j_来表示Jaxen的可选dom4j集成功能，我们将其标识为_特征变体_。这类似于在构建脚本中[定义可选功能变体]()。然后，我们使用一种方法来添加依赖项，以定义此可选功能所需的依赖项。`add`

然后，在构建脚本中，我们可以将[依赖]()项添加[到可选功能中]()，Gradle将使用丰富的元数据来发现正确的传递性依赖项。

例子4.为Jaxen元数据应用和利用规则

`Groovy``Kotlin`

build.gradle

dependencies \{ components \{ withModule\("jaxen:jaxen", JaxenDependenciesRule\) withModule\("jaxen:jaxen", JaxenCapabilitiesRule\) \} implementation\("jaxen:jaxen:1.1.3"\) runtimeOnly\("jaxen:jaxen:1.1.3"\) \{ capabilities \{ requireCapability\("jaxen:jaxen-dom4j"\) \} \} \}

 

1

dependencies \{

2

 components \{

3

 withModule\("jaxen:jaxen", JaxenDependenciesRule\)

4

 withModule\("jaxen:jaxen", JaxenCapabilitiesRule\)

5

 \}

6

 implementation\("jaxen:jaxen:1.1.3"\)

7

 runtimeOnly\("jaxen:jaxen:1.1.3"\) \{

8

 capabilities \{ requireCapability\("jaxen:jaxen-dom4j"\) \}

9

 \}

10

\}

## [](#making_variants_published_as_classified_jars_explicit)[使发布为分类罐子的变体明确](#making_variants_published_as_classified_jars_explicit)

在上一个示例中，所有变体（“主要变体”和可选功能）都打包在一个jar文件中，但通常会将某些变体发布为单独的文件。特别是，当变体是互斥的时，即它们**不是**功能变体，而是提供替代选择的不同变体。**所有**基于pom的库都已经存在的一个示例是_运行时_和_编译_变体，其中Gradle只能根据手头的任务选择一个。在Java生态系统中经常发现的此类替代方法中的另一个是针对不同Java版本的jar。

例如，我们看一下在[Maven](https://repo1.maven.org/maven2/co/paralleluniverse/quasar-core/0.7.9)Central上发布的异步编程库Quasar的0.7.9版本。如果检查目录列表，`quasar-core-0.7.9-jdk8.jar`除之外，还会发现已发布`quasar-core-0.7.9.jar`。在Maven存储库中，使用_分类器_（此处为_jdk8_）发布其他jar是很常见的做法。尽管Maven和Gradle都允许您通过分类器引用此类jar，但它们在元数据中根本没有提及。因此，没有信息表明这些jar存在，以及此类jar代表的变体之间是否存在其他差异（例如不同的依赖项）。

在Gradle模块元数据中，将显示此变体信息，对于已经发布的Quasar库，我们可以使用以下规则添加它：

示例5.将JDK 8变体添加到Quasar元数据的规则

`Groovy``Kotlin`

build.gradle

class QuasarRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ \["compile", "runtime"\].each \{ base -> context.details.addVariant\("jdk8\$\{base.capitalize\(\)\}", base\) \{ attributes \{ attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 8\) \} withFiles \{ removeAllFiles\(\) addFile\("\$\{context.details.id.name\}-\$\{context.details.id.version\}-jdk8.jar"\) \} \} context.details.withVariant\(base\) \{ attributes \{ attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 7\) \} \} \} \} \}

 

1

class QuasarRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 \["compile", "runtime"\].each \{ base \->

4

 context.details.addVariant\("jdk8\$\{base.capitalize\(\)\}", base\) \{

5

 attributes \{

6

 attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 8\)

7

 \}

8

 withFiles \{

9

 removeAllFiles\(\)

10

 addFile\("\$\{context.details.id.name\}-\$\{context.details.id.version\}-jdk8.jar"\)

11

 \}

12

 \}

13

 context.details.withVariant\(base\) \{

14

 attributes \{

15

 attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 7\)

16

 \}

17

 \}

18

 \}

19

 \}

20

\}

在这种情况下，很明显，分类器代表目标Java版本，这是[已知的Java生态系统属性]()。因为我们还需要Java 8的_编译_和_运行时_，所以我们创建了两个新的变体，但将现有的_编译_和_运行时_变体用作_base_。这样，所有其他Java生态系统属性都已经正确设置，并且所有依赖项都被继承。然后，我们将两个变体的都设置为`TARGET_JVM_VERSION_ATTRIBUTE`，使用`8`来从新变体中删除所有现有文件`removeAllFiles()`，并使用来添加jdk8 jar文件`addFile()`。该`removeAllFiles()`是必要的，因为参考主罐子`quasar-core-0.7.5.jar`从相应的基本变体复制。

我们还将针对Java 7-的信息丰富了现有的_编译_和_运行时_变体`attribute(TARGET_JVM_VERSION_ATTRIBUTE, 7)`。

现在，我们可以为构建脚本中的所有依赖于编译类路径的依赖项请求Java 8版本，Gradle会自动为每个库选择最合适的变体。在Quasar的情况下，这将是暴露了的_jdk8Compile_变体`quasar-core-0.7.9-jdk8.jar`。

例子6.为类星元数据应用和利用规则

`Groovy``Kotlin`

build.gradle

configurations.compileClasspath.attributes \{ attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 8\) \} dependencies \{ components \{ withModule\("co.paralleluniverse:quasar-core", QuasarRule\) \} implementation\("co.paralleluniverse:quasar-core:0.7.9"\) \}

 

1

configurations.compileClasspath.attributes \{

2

 attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 8\)

3

\}

4

dependencies \{

5

 components \{

6

 withModule\("co.paralleluniverse:quasar-core", QuasarRule\)

7

 \}

8

 implementation\("co.paralleluniverse:quasar-core:0.7.9"\)

9

\}

## [](#making_variants_encoded_in_versions_explicit)[使版本中编码的变体明确](#making_variants_encoded_in_versions_explicit)

为同一个库发布多个替代方案的另一种解决方案是使用流行的Guava库完成的版本控制模式。在这里，通过将分类器（而不是jar工件）附加到版本，每个新版本都会发布两次。以Guava 28为例，我们可以在[Maven](https://repo1.maven.org/maven2/com/google/guava/guava)_Central上_找到_28.0-jre_（Java 8）和_28.0-android_（Java 6）版本。仅在使用pom元数据时使用此模式的优势在于，可以通过该版本发现这两个变体。缺点是没有任何信息表明不同版本的后缀在语义上意味着什么。因此，在发生冲突的情况下，Gradle在比较版本字符串时只会选择最高版本。[](https://repo1.maven.org/maven2/com/google/guava/guava)

将其转换为适当的变体会比较棘手，因为Gradle首先选择模块的版本，然后选择最合适的变体。因此，不直接支持将变体编码为版本的概念。但是，由于两个变体始终一起发布，因此我们可以假定文件实际上位于同一存储库中。由于它们是按照Maven存储库约定发布的，因此如果知道模块名称和版本，我们就知道每个文件的位置。我们可以编写以下规则：

示例7.将JDK 6和JDK 8变体添加到Guava元数据的规则

`Groovy``Kotlin`

build.gradle

class GuavaRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ def variantVersion = context.details.id.version def version = variantVersion.substring\(0, variantVersion.indexOf\("-"\)\) \["compile", "runtime"\].each \{ base -> \[6: "android", 8: "jre"\].each \{ targetJvmVersion, jarName -> context.details.addVariant\("jdk\$targetJvmVersion\$\{base.capitalize\(\)\}", base\) \{ attributes \{ attributes.attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, targetJvmVersion\) \} withFiles \{ removeAllFiles\(\) addFile\("guava-\$version-\$\{jarName\}.jar", "../\$version-\$jarName/guava-\$version-\$\{jarName\}.jar"\) \} \} \} \} \} \}

 

1

class GuavaRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 def variantVersion \= context.details.id.version

4

 def version \= variantVersion.substring\(0, variantVersion.indexOf\("-"\)\)

5

 \["compile", "runtime"\].each \{ base \->

6

 \[6: "android", 8: "jre"\].each \{ targetJvmVersion, jarName \->

7

 context.details.addVariant\("jdk\$targetJvmVersion\$\{base.capitalize\(\)\}", base\) \{

8

 attributes \{

9

 attributes.attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, targetJvmVersion\)

10

 \}

11

 withFiles \{

12

 removeAllFiles\(\)

13

 addFile\("guava-\$version-\$\{jarName\}.jar", "../\$version-\$jarName/guava-\$version-\$\{jarName\}.jar"\)

14

 \}

15

 \}

16

 \}

17

 \}

18

 \}

19

\}

与前面的示例类似，我们为两个Java版本都添加了运行时和编译变体。`withFiles`但是，在该块中，我们现在还为相应的jar文件指定了相对路径，无论Gradle选择了_\-jre_还是_\-android_版本，它都允许Gradle查找该文件。该路径始终相对于`pom`选择模块版本的元数据（在本例中为）文件的位置。因此，使用此规则，番石榴28个“版本”都携带_jdk6_和_jdk8_变体。因此，Gradle解决哪个问题都没有关系。根据请求的`TARGET_JVM_VERSION_ATTRIBUTE`值确定该变体以及正确的jar文件。

例子8.为番石榴元数据应用和利用规则

`Groovy``Kotlin`

build.gradle

configurations.compileClasspath.attributes \{ attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 6\) \} dependencies \{ components \{ withModule\("com.google.guava:guava", GuavaRule\) \} // '23.3-android' and '23.3-jre' are now the same as both offer both variants implementation\("com.google.guava:guava:23.3+"\) \}

 

1

configurations.compileClasspath.attributes \{

2

 attribute\(TargetJvmVersion.TARGET\_JVM\_VERSION\_ATTRIBUTE, 6\)

3

\}

4

dependencies \{

5

 components \{

6

 withModule\("com.google.guava:guava", GuavaRule\)

7

 \}

8

 // '23.3-android' and '23.3-jre' are now the same as both offer both variants

9

 implementation\("com.google.guava:guava:23.3+"\)

10

\}

## [](#adding_variants_for_native_jars)[为本地jar添加变体](#adding_variants_for_native_jars)

带有分类器的Jar还用于将库中存在多个替代方案（例如本机代码）与主要工件分离的部分。例如，这是由轻量级Java游戏库（LWGJ）完成的，该库将一些特定于平台的jar发布到[Maven](https://repo1.maven.org/maven2/org/lwjgl/lwjgl/3.2.3)Central，在运行时，除了主jar之外，始终需要其中的一个。由于没有通过元数据关联多个工件的概念，因此无法在pom元数据中传达此信息。在Gradle模块元数据中，每个变体可以具有任意多个文件，我们可以通过编写以下规则来利用它：

例子9.将本地运行时变体添加到LWGJ元数据的规则

`Groovy``Kotlin`

build.gradle

class LwjglRule implements ComponentMetadataRule \{ //val os: String, val arch: String, val classifier: String\) private def nativeVariants = \[ \[os: OperatingSystemFamily.LINUX, arch: "arm32", classifier: "natives-linux-arm32"\], \[os: OperatingSystemFamily.LINUX, arch: "arm64", classifier: "natives-linux-arm64"\], \[os: OperatingSystemFamily.WINDOWS, arch: "x86", classifier: "natives-windows-x86"\], \[os: OperatingSystemFamily.WINDOWS, arch: "x86-64", classifier: "natives-windows"\], \[os: OperatingSystemFamily.MACOS, arch: "x86-64", classifier: "natives-macos"\] \] \@Inject ObjectFactory getObjects\(\) \{ \} void execute\(ComponentMetadataContext context\) \{ context.details.withVariant\("runtime"\) \{ attributes \{ attributes.attribute\(OperatingSystemFamily.OPERATING\_SYSTEM\_ATTRIBUTE, objects.named\(OperatingSystemFamily, "none"\)\) attributes.attribute\(MachineArchitecture.ARCHITECTURE\_ATTRIBUTE, objects.named\(MachineArchitecture, "none"\)\) \} \} nativeVariants.each \{ variantDefinition -> context.details.addVariant\("\$\{variantDefinition.classifier\}-runtime", "runtime"\) \{ attributes \{ attributes.attribute\(OperatingSystemFamily.OPERATING\_SYSTEM\_ATTRIBUTE, objects.named\(OperatingSystemFamily, variantDefinition.os\)\) attributes.attribute\(MachineArchitecture.ARCHITECTURE\_ATTRIBUTE, objects.named\(MachineArchitecture, variantDefinition.arch\)\) \} withFiles \{ addFile\("\$\{context.details.id.name\}-\$\{context.details.id.version\}-\$\{variantDefinition.classifier\}.jar"\) \} \} \} \} \}

 

1

class LwjglRule implements ComponentMetadataRule \{ //val os: String, val arch: String, val classifier: String\)

2

 private def nativeVariants \= \[

3

 \[os: OperatingSystemFamily.LINUX,   arch: "arm32",  classifier: "natives-linux-arm32"\],

4

 \[os: OperatingSystemFamily.LINUX,   arch: "arm64",  classifier: "natives-linux-arm64"\],

5

 \[os: OperatingSystemFamily.WINDOWS, arch: "x86",    classifier: "natives-windows-x86"\],

6

 \[os: OperatingSystemFamily.WINDOWS, arch: "x86-64", classifier: "natives-windows"\],

7

 \[os: OperatingSystemFamily.MACOS,   arch: "x86-64", classifier: "natives-macos"\]

8

 \]

9

10

 \@Inject ObjectFactory getObjects\(\) \{ \}

11

12

 void execute\(ComponentMetadataContext context\) \{

13

 context.details.withVariant\("runtime"\) \{

14

 attributes \{

15

 attributes.attribute\(OperatingSystemFamily.OPERATING\_SYSTEM\_ATTRIBUTE, objects.named\(OperatingSystemFamily, "none"\)\)

16

 attributes.attribute\(MachineArchitecture.ARCHITECTURE\_ATTRIBUTE, objects.named\(MachineArchitecture, "none"\)\)

17

 \}

18

 \}

19

 nativeVariants.each \{ variantDefinition \->

20

 context.details.addVariant\("\$\{variantDefinition.classifier\}-runtime", "runtime"\) \{

21

 attributes \{

22

 attributes.attribute\(OperatingSystemFamily.OPERATING\_SYSTEM\_ATTRIBUTE, objects.named\(OperatingSystemFamily, variantDefinition.os\)\)

23

 attributes.attribute\(MachineArchitecture.ARCHITECTURE\_ATTRIBUTE, objects.named\(MachineArchitecture, variantDefinition.arch\)\)

24

 \}

25

 withFiles \{

26

 addFile\("\$\{context.details.id.name\}-\$\{context.details.id.version\}-\$\{variantDefinition.classifier\}.jar"\)

27

 \}

28

 \}

29

 \}

30

 \}

31

\}

此规则与上面的Quasar库示例非常相似。仅这次，我们添加了五个不同的运行时变体，而对于编译变体则无需更改。运行时变体全部基于现有的_运行时_变体，并且我们不更改任何现有信息。所有Java生态系统属性，依赖项和主jar文件都属于每个运行时变体的一部分。我们仅设置其他属性`OPERATING_SYSTEM_ATTRIBUTE`，`ARCHITECTURE_ATTRIBUTE`这些属性被定义为Gradle[本机支持的一部分]()。然后，我们添加相应的本机jar文件，以便每个运行时变体现在都包含两个文件：主jar和本机jar。

在构建脚本中，我们现在可以请求特定的变体，如果需要更多信息来做出决定，则Gradle将失败，并显示选择错误。

例子10.为LWGJ元数据应用和利用规则

`Groovy``Kotlin`

build.gradle

configurations\["runtimeClasspath"\].attributes \{ attribute\(OperatingSystemFamily.OPERATING\_SYSTEM\_ATTRIBUTE, objects.named\(OperatingSystemFamily, "windows"\)\) \} dependencies \{ components \{ withModule\("org.lwjgl:lwjgl", LwjglRule\) \} implementation\("org.lwjgl:lwjgl:3.2.3"\) \}

 

1

configurations\["runtimeClasspath"\].attributes \{

2

 attribute\(OperatingSystemFamily.OPERATING\_SYSTEM\_ATTRIBUTE, objects.named\(OperatingSystemFamily, "windows"\)\)

3

\}

4

dependencies \{

5

 components \{

6

 withModule\("org.lwjgl:lwjgl", LwjglRule\)

7

 \}

8

 implementation\("org.lwjgl:lwjgl:3.2.3"\)

9

\}

Gradle无法选择变体，因为需要选择机器架构

\>无法解析配置'：runtimeClasspath'的所有文件。 >无法解析org.lwjgl：lwjgl：3.2.3。 要求： 项目： >无法在org.lwjgl：lwjgl：3.2.3的以下变体之间进行选择： -natives-windows-runtime -natives-windows-x86-runtime

## [](#making_different_flavors_of_a_library_available_through_capabilities)[通过功能使库具有不同的风格](#making_different_flavors_of_a_library_available_through_capabilities)

由于很难将[可选功能变量]()建模为带有pom元数据的单独jar，因此库有时会组成具有不同功能集的不同jar。也就是说，不是从不同的功能变体中构成库的风格，而是选择一种预先组合的变体（在一个jar中提供所有内容）。这样的库之一就是在[Maven](https://repo1.maven.org/maven2/com/google/inject/guice/4.2.2)Central上发布的著名的依赖项注入框架Guice，它提供了完整的风格（主jar）和简化的变体，而没有面向方面的编程支持（`guice-4.2.2-no_aop.jar`）。pom元数据中未提及带有分类器的第二个变体。使用以下规则，我们将基于该文件创建编译和运行时变体，并通过名为的功能使其可选`com.google.inject:guice-no_aop`。

例子11.将no\_aop特征变量添加到Guice元数据的规则

`Groovy``Kotlin`

build.gradle

class GuiceRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ \["compile", "runtime"\].each \{ base -> context.details.addVariant\("noAop\$\{base.capitalize\(\)\}", base\) \{ withCapabilities \{ addCapability\("com.google.inject", "guice-no\_aop", context.details.id.version\) \} withFiles \{ removeAllFiles\(\) addFile\("guice-\$\{context.details.id.version\}-no\_aop.jar"\) \} withDependencies \{ removeAll \{ it.group == "aopalliance" \} \} \} \} \} \}

 

1

class GuiceRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 \["compile", "runtime"\].each \{ base \->

4

 context.details.addVariant\("noAop\$\{base.capitalize\(\)\}", base\) \{

5

 withCapabilities \{

6

 addCapability\("com.google.inject", "guice-no\_aop", context.details.id.version\)

7

 \}

8

 withFiles \{

9

 removeAllFiles\(\)

10

 addFile\("guice-\$\{context.details.id.version\}-no\_aop.jar"\)

11

 \}

12

 withDependencies \{

13

 removeAll \{ it.group \== "aopalliance" \}

14

 \}

15

 \}

16

 \}

17

 \}

18

\}

新变体还依赖于标准化的aop接口库`aopalliance:aopalliance`，因为这些变体显然不需要。同样，这是无法在pom元数据中表达的信息。现在，我们可以选择一个`guice-no_aop`变体，并将获得正确的jar文件**和**正确的依赖关系。

例子12.为Guice元数据应用和利用规则

`Groovy``Kotlin`

build.gradle

dependencies \{ components \{ withModule\("com.google.inject:guice", GuiceRule\) \} implementation\("com.google.inject:guice:4.2.2"\) \{ capabilities \{ requireCapability\("com.google.inject:guice-no\_aop"\) \} \} \}

 

1

dependencies \{

2

 components \{

3

 withModule\("com.google.inject:guice", GuiceRule\)

4

 \}

5

 implementation\("com.google.inject:guice:4.2.2"\) \{

6

 capabilities \{ requireCapability\("com.google.inject:guice-no\_aop"\) \}

7

 \}

8

\}

## [](#adding_missing_capabilities_to_detect_conflicts)[添加缺少的功能来检测冲突](#adding_missing_capabilities_to_detect_conflicts)

功能的另一种用法是表示两个不同的模块（例如`log4j`和`log4j-over-slf4j`）提供同一事物的替代实现。通过声明两者都提供相同的功能，Gradle在依赖图中仅接受其中之一。此示例以及如何用组件元数据规则解决该示例，在[功能建模]()部分中进行了详细说明。

## [](#making_ivy_modules_variant_aware)[使常春藤模块能够感知变体](#making_ivy_modules_variant_aware)

具有常春藤元数据的模块默认情况下不具有变体。但是，可以将_Ivy配置_映射到变量，因为它`addVariant(name, baseVariantOrConfiguration)`可以接受发布为基础的任何Ivy配置。例如，这可用于定义运行时和编译变体。相应规则的示例可以在[此处]()找到。常春藤配置的常春藤详细信息（例如，依赖关系和文件）也可以使用`withVariant(configurationName)`API进行修改。但是，修改Ivy配置上的属性或功能无效。

对于非常特定于Ivy的用例，组件元数据规则API还提供对仅在Ivy元数据中找到的其他详细信息的访问。这些都可以通过[IvyModuleDescriptor]()接口，并可以通过访问`getDescriptor(IvyModuleDescriptor)`在[ComponentMetadataContext]()。

例子13.常春藤组件元数据规则

`Groovy``Kotlin`

build.gradle

class IvyComponentRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ def descriptor = context.getDescriptor\(IvyModuleDescriptor\) if \(descriptor \!= null \&\& descriptor.branch == "testing"\) \{ context.details.status = "rc" \} \} \}

 

1

class IvyComponentRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 def descriptor \= context.getDescriptor\(IvyModuleDescriptor\)

4

 if \(descriptor \!= null \&\& descriptor.branch \== "testing"\) \{

5

 context.details.status \= "rc"

6

 \}

7

 \}

8

\}

## [](#filter_using_maven_metadata)[使用Maven元数据过滤](#filter_using_maven_metadata)

对于特定于Maven的用例，组件元数据规则API还提供对仅在POM元数据中找到的其他详细信息的访问。这些可以通过[PomModuleDescriptor]()接口使用`getDescriptor(PomModuleDescriptor)`，并且可以使用[ComponentMetadataContext]()进行访问。

例子14.组件元数据规则中的访问pom打包类型

`Groovy``Kotlin`

build.gradle

class MavenComponentRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ def descriptor = context.getDescriptor\(PomModuleDescriptor\) if \(descriptor \!= null \&\& descriptor.packaging == "war"\) \{ // ... \} \} \}

 

1

class MavenComponentRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 def descriptor \= context.getDescriptor\(PomModuleDescriptor\)

4

 if \(descriptor \!= null \&\& descriptor.packaging \== "war"\) \{

5

 // ...

6

 \}

7

 \}

8

\}

## [](#modifying_metadata_on_the_component_level_for_alignment)[在组件级别修改元数据以进行对齐](#modifying_metadata_on_the_component_level_for_alignment)

尽管以上所有示例都对组件的变体进行了修改，但也可以对组件本身的元数据进行有限的修改。此信息可能会影响相关性解析期间模块的[版本选择]()过程，该过程在[选择]()组件的一个或多个变体_之前_执行。

该组件上第一个可用的API是`belongsTo()`创建虚拟平台，以在没有Gradle Module Metadata的情况下对齐多个模块的版本。在[对齐未通过Gradle发布的模块版本]()的部分中对此进行了详细说明。

## [](#sec:custom_status_scheme)[在组件级别上修改元数据以根据状态选择版本](#sec:custom_status_scheme)

Gradle和Gradle模块元数据还允许在整个组件上设置属性，而不是单个变量。这些属性中的每一个都具有特殊的语义，因为它们会影响版本选择，而版本选择是_在_变量选择_之前_完成的。尽管变体选择可以处理[任何自定义属性]()，但是版本选择仅考虑实现了特定语义的属性。目前，这里唯一有意义的属性是`org.gradle.status`。因此，建议仅在组件级别上修改此属性（如果有）。`setStatus(value)`为此可以使用专用的API。为组件的所有变体修改另一个属性`withAllVariants { attributes {} }`应改为使用。

解析[_最新_版本选择器]()时，将考虑模块的状态。具体来说，`latest.someStatus`将解析为具有状态`someStatus`或更成熟状态的最高模块版本。例如，`latest.integration`将选择最高的模块版本，而不考虑其状态（因为`integration`是最不成熟的状态，如下所述），而`latest.release`将选择具有状态的最高模块版本`release`。

通过API更改模块的_状态方案_可以影响状态的解释`setStatusScheme(valueList)`。这个概念模拟了模块在不同出版物上随着时间推移而转变的不同成熟度。默认状态方案，下令从最低到最高的成熟状态，是`integration`，`milestone`，`release`。的`org.gradle.status`属性必须设置，以便在所述部件状态方案中值中的一个。因此，每个组件始终具有从元数据确定的状态，如下所示：

* Gradle模块元数据：为`org.gradle.status`组件上的属性发布的值
* 常春藤元数据：`status`在ivy.xml中定义，`integration`如果缺少则默认为
* Pom元数据：`integration`对于具有SNAPSHOT版本的模块，`release`对于所有其他

下面的示例演示了`latest`基于在适用于所有模块的组件元数据规则中声明的自定义状态方案的选择器：

例子15.定制状态方案

`Groovy``Kotlin`

build.gradle

class CustomStatusRule implements ComponentMetadataRule \{ void execute\(ComponentMetadataContext context\) \{ context.details.statusScheme = \["nightly", "milestone", "rc", "release"\] if \(context.details.status == "integration"\) \{ context.details.status = "nightly" \} \} \} dependencies \{ components \{ all\(CustomStatusRule\) \} implementation\("org.apache.commons:commons-lang3:latest.rc"\) \}

 

1

class CustomStatusRule implements ComponentMetadataRule \{

2

 void execute\(ComponentMetadataContext context\) \{

3

 context.details.statusScheme \= \["nightly", "milestone", "rc", "release"\]

4

 if \(context.details.status \== "integration"\) \{

5

 context.details.status \= "nightly"

6

 \}

7

 \}

8

\}

9

10

dependencies \{

11

 components \{

12

 all\(CustomStatusRule\)

13

 \}

14

 implementation\("org.apache.commons:commons-lang3:latest.rc"\)

15

\}

与默认方案相比，该规则将插入新状态`rc`并替换`integration`为`nightly`。状态`integration`为的现有模块已映射到`nightly`。