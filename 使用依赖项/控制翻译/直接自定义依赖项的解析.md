 无标题 <style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body { padding-left: 48px; padding-right: 48px;}</style><style id="wiz_code_style">.wiz-editor-body .wiz-code-container{position: relative; padding:8px 0; margin: 5px 0;text-indent:0; text-align:left;}.CodeMirror {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; color: black; font-size: 10.5pt; font-size: 0.875rem}.wiz-editor-body .wiz-code-container .CodeMirror div {margin-top: 0; margin-bottom: 0;}.CodeMirror-lines {padding: 4px 0;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {padding: 0 4px;}.CodeMirror pre.CodeMirror-line {min-height: 24px;}.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {background-color: white;}.CodeMirror-gutters {border-right: 1px solid #ddd; background-color: #f7f7f7; white-space: nowrap;}.CodeMirror-linenumbers {}.CodeMirror-linenumber {padding: 0 3px 0 5px; min-width: 20px; text-align: right; color: #999; white-space: nowrap;}.CodeMirror-guttermarker {color: black;}.CodeMirror-guttermarker-subtle {color: #999;}.CodeMirror-cursor {border-left: 1px solid black; border-right: none; width: 0;}.CodeMirror div.CodeMirror-secondarycursor {border-left: 1px solid silver;}.cm-fat-cursor .CodeMirror-cursor {width: auto; border: 0 !important; background: #7e7;}.cm-fat-cursor div.CodeMirror-cursors {z-index: 1;}.cm-fat-cursor-mark {background-color: rgba(20, 255, 20, 0.5);-webkit-animation: blink 1.06s steps(1) infinite;-moz-animation: blink 1.06s steps(1) infinite;animation: blink 1.06s steps(1) infinite;}.cm-animate-fat-cursor {width: auto; border: 0; -webkit-animation: blink 1.06s steps(1) infinite; -moz-animation: blink 1.06s steps(1) infinite; animation: blink 1.06s steps(1) infinite; background-color: #7e7;}@-moz-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@-webkit-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}.CodeMirror-overwrite .CodeMirror-cursor {}.cm-tab { display: inline-block; text-decoration: inherit; }.CodeMirror-rulers {position: absolute; left: 0; right: 0; top: -50px; bottom: -20px; overflow: hidden;}.CodeMirror-ruler {border-left: 1px solid #ccc; top: 0; bottom: 0; position: absolute;}.cm-s-default .cm-header {color: blue;}.cm-s-default .cm-quote {color: #090;}.cm-negative {color: #d44;}.cm-positive {color: #292;}.cm-header, .cm-strong {font-weight: bold;}.cm-em {font-style: italic;}.cm-link {text-decoration: underline;}.cm-strikethrough {text-decoration: line-through;}.cm-s-default .cm-keyword {color: #708;}.cm-s-default .cm-atom {color: #219;}.cm-s-default .cm-number {color: #164;}.cm-s-default .cm-def {color: #00f;}.cm-s-default .cm-variable,.cm-s-default .cm-punctuation,.cm-s-default .cm-property,.cm-s-default .cm-operator {}.cm-s-default .cm-variable-2 {color: #05a;}.cm-s-default .cm-variable-3 {color: #085;}.cm-s-default .cm-comment {color: #a50;}.cm-s-default .cm-string {color: #a11;}.cm-s-default .cm-string-2 {color: #f50;}.cm-s-default .cm-meta {color: #555;}.cm-s-default .cm-qualifier {color: #555;}.cm-s-default .cm-builtin {color: #30a;}.cm-s-default .cm-bracket {color: #997;}.cm-s-default .cm-tag {color: #170;}.cm-s-default .cm-attribute {color: #00c;}.cm-s-default .cm-hr {color: #999;}.cm-s-default .cm-link {color: #00c;}.cm-s-default .cm-error {color: #f00;}.cm-invalidchar {color: #f00;}.CodeMirror-composing { border-bottom: 2px solid; }div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }.CodeMirror-activeline-background {background: #e8f2ff;}.CodeMirror {position: relative; background: #f5f5f5;}.CodeMirror-scroll {overflow: hidden !important; margin-bottom: 0; margin-right: -30px; padding: 16px 30px 16px 0; outline: none; position: relative;}.CodeMirror-sizer {position: relative; border-right: 30px solid transparent;}.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {position: absolute; z-index: 6; display: none;}.CodeMirror-vscrollbar {right: 0; top: 0; overflow-x: hidden; overflow-y: scroll;}.CodeMirror-hscrollbar {bottom: 0; left: 0 !important; overflow-y: hidden; overflow-x: scroll;pointer-events: auto !important;outline: none;}.CodeMirror-scrollbar-filler {right: 0; bottom: 0;}.CodeMirror-gutter-filler {left: 0; bottom: 0;}.CodeMirror-gutters {position: absolute; left: 0; top: 0; min-height: 100%; z-index: 3;}.CodeMirror-gutter {white-space: normal; height: 100%; display: inline-block; vertical-align: top; margin-bottom: -30px;}.CodeMirror-gutter-wrapper {position: absolute; z-index: 4; background: none !important; border: none !important;}.CodeMirror-gutter-background {position: absolute; top: 0; bottom: 0; z-index: 4;}.CodeMirror-gutter-elt {position: absolute; cursor: default; z-index: 4;}.CodeMirror-gutter-wrapper ::selection { background-color: transparent }.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }.CodeMirror-lines {cursor: text; min-height: 1px;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {-moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0; border-width: 0; background: transparent; font-family: inherit; font-size: inherit; margin: 0; white-space: pre; word-wrap: normal; line-height: inherit; color: inherit; z-index: 2; position: relative; overflow: visible; -webkit-tap-highlight-color: transparent; -webkit-font-variant-ligatures: contextual; font-variant-ligatures: contextual;}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like {word-wrap: break-word; white-space: pre-wrap; word-break: normal;}.CodeMirror-linebackground {position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;}.CodeMirror-linewidget {position: relative; z-index: 2; padding: 0.1px;}.CodeMirror-widget {}.CodeMirror-rtl pre { direction: rtl; }.CodeMirror-code {outline: none;}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {-moz-box-sizing: content-box; box-sizing: content-box;}.CodeMirror-measure {position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;}.CodeMirror-cursor {position: absolute; pointer-events: none;}.CodeMirror-measure pre { position: static; }div.CodeMirror-cursors {visibility: hidden; position: relative; z-index: 3;}div.CodeMirror-dragcursors {visibility: visible;}.CodeMirror-focused div.CodeMirror-cursors {visibility: visible;}.CodeMirror-selected { background: #d9d9d9; }.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }.CodeMirror-crosshair { cursor: crosshair; }.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }.cm-searching {background: #ffa; background: rgba(255, 255, 0, .4);}.cm-force-border { padding-right: .1px; }@media print { .CodeMirror div.CodeMirror-cursors {visibility: hidden;}}.cm-tab-wrap-hack:after { content: ""; }span.CodeMirror-selectedtext { background: none; }.CodeMirror-activeline-background, .CodeMirror-selected {transition: visibility 0ms 100ms;}.CodeMirror-blur .CodeMirror-activeline-background, .CodeMirror-blur .CodeMirror-selected {visibility:hidden;}.CodeMirror-blur .CodeMirror-matchingbracket {color:inherit !important;outline:none !important;text-decoration:none !important;}.CodeMirror-sizer {min-height:auto !important;}</style>

# 直接自定义依赖项的解析

内容

* [使用依赖关系解决规则](#sec:dependency_resolve_rules)
* [使用模块更换规则](#sec:module_replacement)
* [使用依赖替换规则](#sec:dependency_substitution_rules)
* [禁用传递解析](#sec:disabling_resolution_transitive_dependencies)
* [在解决之前更改配置依赖性](#changing_configuration_dependencies_prior_to_resolution)
* [设置默认配置依赖项](#sec:configuration_defaults)
* [从配置中完全排除依赖项](#excluding_a_dependency_from_a_configuration_completely)
* [将依赖项与存储库进行匹配](#matching_dependencies_to_repositories)
* [启用常春藤动态解析模式](#sec:ivy_dynamic_resolve_mode)

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>本节介绍了Gradle提供的直接影响依赖关系解析引擎行为的机制。</font><font>与本章介绍的其他概念（例如</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>依赖项约束</font></font></a><font><font>或</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>组件元数据规则）不同</font></font></a><font><font>，它们都是</font><font>决议的</font></font><strong><font><font>输入</font></font></strong><font><font>，以下机制使您可以编写直接注入决议引擎的规则。</font><font>因此，它们可以看作是</font></font><em style="font-style:italic;"><font><font>蛮力</font></font></em><font><font>解决方案，可能会隐藏未来的问题（例如，如果添加了新的依赖项）。</font><font>因此，一般建议仅在其他手段不足的情况下使用以下机制。</font><font>如果要编写</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>库</font></font></a><font><font>，则应始终首选</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>依赖项约束</font></font></a><font><font><span>&nbsp;</span>因为它们是为您的消费者发布的。</font></font></p></div></td></tr></tbody></table>

## [](#sec:dependency_resolve_rules)[使用依赖关系解决规则](#sec:dependency_resolve_rules)

将为每个已解析的依赖项执行一个依赖项解析规则，并提供了一个强大的api，用于在解析依赖项之前处理请求的依赖项。该功能当前提供了更改请求的依赖项的组，名称和/或版本的功能，从而允许在解析过程中将依赖项替换为完全不同的模块。

依赖关系解析规则提供了一种非常强大的方式来控制依赖关系解析过程，并且可用于实现依赖关系管理中的各种高级模式。下面概述了其中一些模式。有关更多信息和代码示例，请参阅API文档中的[ResolutionStrategy]()类。

### [](#sec:custom_versioning_scheme)[实施自定义版本控制方案](#sec:custom_versioning_scheme)

在某些公司环境中，可以在Gradle构建中声明的模块版本列表由外部维护和审核。依赖性解析规则为这种模式提供了一种简洁的实现方式：

* 在构建脚本中，开发人员使用模块组和名称声明依赖关系，但使用占位符版本，例如：`default`。
* `default`通过依赖关系解析规则将版本解析为特定版本，该规则在已批准模块的公司目录中查找该版本。

可以将规则实施整齐地封装在公司插件中，并在组织内的所有内部版本之间共享。

示例1.使用自定义版本控制方案

`Groovy``Kotlin`

build.gradle

configurations.all \{ resolutionStrategy.eachDependency \{ DependencyResolveDetails details -> if \(details.requested.version == 'default'\) \{ def version = findDefaultVersionInCatalog\(details.requested.group, details.requested.name\) details.useVersion version.version details.because version.because \} \} \} def findDefaultVersionInCatalog\(String group, String name\) \{ //some custom logic that resolves the default version into a specific version \[version: "1.0", because: 'tested by QA'\] \}

 

1

configurations.all \{

2

 resolutionStrategy.eachDependency \{ DependencyResolveDetails details \->

3

 if \(details.requested.version \== 'default'\) \{

4

 def version \= findDefaultVersionInCatalog\(details.requested.group, details.requested.name\)

5

 details.useVersion version.version

6

 details.because version.because

7

 \}

8

 \}

9

\}

10

11

def findDefaultVersionInCatalog\(String group, String name\) \{

12

 //some custom logic that resolves the default version into a specific version

13

 \[version: "1.0", because: 'tested by QA'\]

14

\}

### [](#sec:denying_version)[拒绝替换特定版本](#sec:denying_version)

依赖性解析规则提供了一种机制，用于拒绝依赖性的特定版本并提供替代版本。如果某个依赖项版本已损坏并且不应使用，当依赖项解析规则导致该版本被已知的良好版本替换时，这将很有用。损坏的模块的一个示例是声明对某个库的依赖关系，该依赖关系在任何公共存储库中都找不到，但是还有许多其他原因导致不需要特定的模块版本，而首选其他版本。

在下面的示例中，假设该版本`1.2.1`包含重要的修复程序，并且应始终优先使用`1.2`。提供的规则将强制执行此操作：`1.2`遇到任何版本时，都会将其替换为`1.2.1`。请注意，这与如上所述的强制版本不同，因为此模块的任何其他版本都不会受到影响。这意味着，“最新”的冲突解决策略仍会选择`1.3`该版本，前提是该版本也被传递。

例子2.例子：将一个带有替换版本的版本列入黑名单

`Groovy``Kotlin`

build.gradle

configurations.all \{ resolutionStrategy.eachDependency \{ DependencyResolveDetails details -> if \(details.requested.group == 'org.software' \&\& details.requested.name == 'some-library' \&\& details.requested.version == '1.2'\) \{ details.useVersion '1.2.1' details.because 'fixes critical bug in 1.2' \} \} \}

 

1

configurations.all \{

2

 resolutionStrategy.eachDependency \{ DependencyResolveDetails details \->

3

 if \(details.requested.group \== 'org.software' \&\& details.requested.name \== 'some-library' \&\& details.requested.version \== '1.2'\) \{

4

 details.useVersion '1.2.1'

5

 details.because 'fixes critical bug in 1.2'

6

 \}

7

 \}

8

\}

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>使用</font><font>具有</font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font>丰富版本约束</font></a><font>的</font></font><em style="font-style:italic;"><font><font>reject</font></font></em><font><font>指令</font><font>有一个区别</font><font>：如果在图中找到被拒绝的版本，则丰富的版本将导致构建失败，或者在使用动态依赖项时选择非被拒绝的版本。</font><font>在这里，我们</font><em style="font-style:italic;"><font>处理请求的版本</font></em><font>，以便在找到被拒绝的版本时选择其他版本。</font><font>换句话说，这是</font><font>针对拒绝版本</font><font>的</font><em style="font-style:italic;"><font>解决方案</font></em><font>，而丰富版本限制允许声明</font><em style="font-style:italic;"><font>意图</font></em><font>（您不应使用此版本）。</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font></font></a><font></font><em style="font-style:italic;"><font></font></em><font></font><em style="font-style:italic;"><font></font></em><font></font><em style="font-style:italic;"><font></font></em><font></font></p></div></td></tr></tbody></table>

## [](#sec:module_replacement)[使用模块更换规则](#sec:module_replacement)

就[功能冲突]()而言，最好表达模块[冲突]()。但是，如果没有声明这样的规则，或者您正在使用不支持功能的Gradle版本，则Gradle提供了解决这些问题的工具。

模块替换规则允许构建声明旧库已被新库替换。新库替换旧库的一个很好的例子是`google-collections`\->`guava`迁移。创建Google集合的团队决定将模块名称从更改`com.google.collections:google-collections`为`com.google.guava:guava`。这在业界是一种合法的情况：团队需要能够更改其维护的产品名称，包括模块坐标。重命名模块坐标会影响冲突解决。

为了解释对解决冲突的影响，让我们考虑`google-collections`\->`guava`场景。这两个库都可能被拉到同一个依赖图中。例如，_我们的项目_依赖，`guava`但是_我们的_某些_依赖项_引入了的旧版本`google-collections`。这可能会导致运行时错误，例如在测试或应用程序执行期间。Gradle不会自动解决`google-collections`\->`guava`冲突，因为它不被视为_版本冲突_。这是因为两个库的模块坐标完全不同，并且在`group`和`module`坐标是相同的，但是在依赖关系图中有不同的版本（有关更多信息，请参阅冲突解决部分）。解决此问题的传统方法是：

* 声明排除规则，以避免`google-collections`进入图表。这可能是最流行的方法。
* 避免引入旧式库的依赖项。
* 如果新版本不再引入旧版库，请升级依赖版本。
* 降级为`google-collections`。不建议这样做，只是出于完整性考虑。

传统方法行之有效，但它们不够笼统。例如，一个组织希望在所有项目中解决`google-collections`\->`guava`冲突解决问题。可以声明某些模块已被其他模块替代。这使组织能够将有关模块更换的信息包括在公司插件套件中，并全面解决企业中所有由Gradle支持的项目的问题。

示例3.声明模块更换

`Groovy``Kotlin`

build.gradle

dependencies \{ modules \{ module\("com.google.collections:google-collections"\) \{ replacedBy\("com.google.guava:guava", "google-collections is now part of Guava"\) \} \} \}

 

1

dependencies \{

2

 modules \{

3

 module\("com.google.collections:google-collections"\) \{

4

 replacedBy\("com.google.guava:guava", "google-collections is now part of Guava"\)

5

 \}

6

 \}

7

\}

有关更多示例和详细API，请参阅DSL参考[ComponentMetadataHandler]()。

当我们声明`google-collections`被替换时会发生什么`guava`？Gradle可以使用此信息来解决冲突。Gradle将考虑`guava`比的任何版本更新/更好的每个版本`google-collections`。另外，Gradle将确保在类路径/已解析文件列表中仅存在guava jar。注意，如果仅`google-collections`出现在依赖关系图中（例如，否`guava`），Gradle不会急于将其替换为`guava`。模块更换是Gradle用于解决冲突的信息。如果没有冲突（例如，仅`google-collections`或仅`guava`在图中），则不使用替换信息。

当前，不可能声明给定的模块被一组模块替换。但是，可以声明多个模块被单个模块替换。

## [](#sec:dependency_substitution_rules)[使用依赖替换规则](#sec:dependency_substitution_rules)

依赖关系替换规则的工作方式与依赖关系解决规则相似。实际上，可以使用依赖关系替换规则来实现依赖关系解析规则的许多功能。它们允许将项目和模块依赖项透明地替换为指定的替换项。与依赖关系解析规则不同，依赖关系替换规则允许项目和模块依赖关系可以互换替换。

_向配置中添加依赖项替换规则会更改解析该配置的时间。_在构造任务图时，无需解析首次使用的配置，而是解析配置。如果在任务执行期间对配置进行了进一步修改，或者配置依赖于在执行另一任务期间发布的模块，则可能会产生意想不到的后果。

解释：

* `Configuration`可以将A声明为任何Task的输入，并且在解析该配置时可以包括项目依赖项。
* 如果项目依赖项是任务的输入（通过配置），则必须将用于构建项目工件的任务添加到任务依赖项中。
* 为了确定作为任务输入的项目依赖关系，Gradle需要解析`Configuration`输入。
* 由于Gradle任务图在任务执行开始后便是固定的，因此Gradle需要在执行任何任务之前执行此解决方案。

在没有依赖替换规则的情况下，Gradle知道外部模块依赖永远不会传递引用项目依赖。通过简单的图形遍历，可以轻松确定配置的项目依赖项的完整集合。使用此功能，Gradle不能再进行此假设，并且必须执行完全解析才能确定项目依赖项。

### [](#sub:module_to_project_substitution)[将外部模块依赖项替换为项目依赖项](#sub:module_to_project_substitution)

一种替代依赖的用例是使用模块的本地开发版本来代替从外部存储库下载的模块。这对于测试本地修补版本的依赖项可能很有用。

可以在指定版本或不指定版本的情况下声明要替换的模块。

例子4.用一个项目代替一个模块

`Groovy``Kotlin`

build.gradle

configurations.all \{ resolutionStrategy.dependencySubstitution \{ substitute module\("org.utils:api"\) using project\(":api"\) because "we work with the unreleased development version" substitute module\("org.utils:util:2.5"\) using project\(":util"\) \} \}

 

1

configurations.all \{

2

 resolutionStrategy.dependencySubstitution \{

3

 substitute module\("org.utils:api"\) using project\(":api"\) because "we work with the unreleased development version"

4

 substitute module\("org.utils:util:2.5"\) using project\(":util"\)

5

 \}

6

\}

请注意，被替换的项目必须包含在多项目构建中（通过`settings.gradle`）。依赖关系替换规则负责将模块依赖关系替换为项目依赖关系，并连接所有任务依赖关系，但不将项目隐式包含在构建中。

### [](#sub:project_to_module_substitution)[用模块替换代替项目依赖](#sub:project_to_module_substitution)

使用替换规则的另一种方法是用多项目构建中的模块替换项目依赖项。通过允许从存储库中下载而不是构建项目依赖项的子集，这对于加快大型多项目构建的开发速度可能非常有用。

必须使用指定的版本声明要用作替换模块的模块。

例子5.用一个模块代替一个项目

`Groovy``Kotlin`

build.gradle

configurations.all \{ resolutionStrategy.dependencySubstitution \{ substitute project\(":api"\) using module\("org.utils:api:1.3"\) because "we use a stable version of org.utils:api" \} \}

 

1

configurations.all \{

2

 resolutionStrategy.dependencySubstitution \{

3

 substitute project\(":api"\) using module\("org.utils:api:1.3"\) because "we use a stable version of org.utils:api"

4

 \}

5

\}

当项目依赖关系已替换为模块依赖关系时，该项目仍将包含在整个多项目构建中。但是，将不会执行构建替换后的依赖项的任务来解决dependencies`Configuration`。

### [](#sub:conditional_dependency_substitution)[有条件地替换依赖项](#sub:conditional_dependency_substitution)

依赖替换的一个常见用例是允许在多项目构建中更灵活地组装子项目。这对于开发外部依赖的本地修补版本或在大型多项目构建中构建模块的子集很有用。

以下示例使用依赖项替换规则将任何模块依赖项替换为group`org.example`，但前提是必须找到与依赖项名称匹配的本地项目。

例子6.有条件地替换一个依赖

`Groovy``Kotlin`

build.gradle

configurations.all \{ resolutionStrategy.dependencySubstitution.all \{ DependencySubstitution dependency -> if \(dependency.requested instanceof ModuleComponentSelector \&\& dependency.requested.group == "org.example"\) \{ def targetProject = findProject\(":\$\{dependency.requested.module\}"\) if \(targetProject \!= null\) \{ dependency.useTarget targetProject \} \} \} \}

 

1

configurations.all \{

2

 resolutionStrategy.dependencySubstitution.all \{ DependencySubstitution dependency \->

3

 if \(dependency.requested instanceof ModuleComponentSelector \&\& dependency.requested.group \== "org.example"\) \{

4

 def targetProject \= findProject\(":\$\{dependency.requested.module\}"\)

5

 if \(targetProject \!= null\) \{

6

 dependency.useTarget targetProject

7

 \}

8

 \}

9

 \}

10

\}

请注意，被替换的项目必须包含在多项目构建中（通过`settings.gradle`）。依赖关系替换规则负责将模块依赖关系替换为项目依赖关系，但不将项目隐式包含在构建中。

### [](#sec:variant_aware_substitutions)[用另一个变量替换依赖](#sec:variant_aware_substitutions)

Gradle的依赖性管理引擎具有[变体感知功能，]()这意味着对于单个组件，该引擎可以选择不同的工件和传递性依赖性。

选择什么取决于使用者配置的属性和在生产者端找到的变体的属性。但是，某些特定的依赖关系可能会覆盖配置本身的属性。使用[Java Platform插件]()时通常是这种情况：该插件会构建一种特殊的组件，称为“平台”，可以通过将组件类别属性设置为来解决，`platform`这与针对库的典型依赖项相反。

因此，您可能会遇到想要用常规依赖项替换平台依赖项或其他方式的情况。

#### [](#sec:substitution_with_attributes)[用属性替换依赖项](#sec:substitution_with_attributes)

假设您要用常规依赖项替换平台依赖项。这意味着您正在使用的库声明如下：

例子7.对平台的不正确依赖

`Groovy``Kotlin`

lib / build.gradle

dependencies \{ // This is a platform dependency but you want the library implementation platform\('com.google.guava:guava:28.2-jre'\) \}

 

1

dependencies \{

2

 // This is a platform dependency but you want the library

3

 implementation platform\('com.google.guava:guava:28.2-jre'\)

4

\}

该`platform`关键字实际上是一个很短的记法_与属性的依赖_。如果要用常规依赖关系替换此依赖关系，则需要精确选择具有`platform`属性的依赖关系。

这可以通过使用替换规则来完成：

例子8.用常规依赖替换平台依赖

`Groovy``Kotlin`

消费者/build.gradle

configurations.all \{ resolutionStrategy.dependencySubstitution \{ substitute\(platform\(module\('com.google.guava:guava:28.2-jre'\)\)\). using module\('com.google.guava:guava:28.2-jre'\) \} \}

 

1

configurations.all \{

2

 resolutionStrategy.dependencySubstitution \{

3

 substitute\(platform\(module\('com.google.guava:guava:28.2-jre'\)\)\).

4

 using module\('com.google.guava:guava:28.2-jre'\)

5

 \}

6

\}

同样的规则也_没有_的`platform`关键字会尝试替代_常规的依赖性_与常规的依赖，这是不是你想要的，所以理解替代规则适用上是非常重要的_依赖性规范_：它要求的依赖关系（匹配`substitute XXX`）与替代（`using YYY`）。

您可以在请求的依赖项_或_替换项上都具有属性，并且替换项不限于`platform`：您实际上可以使用`variant`表示法指定整个依赖项属性集。以下规则与上述规则_严格等效_：

例9.使用变量符号用常规依赖项替换平台依赖项

`Groovy``Kotlin`

消费者/build.gradle

configurations.all \{ resolutionStrategy.dependencySubstitution \{ substitute variant\(module\('com.google.guava:guava:28.2-jre'\)\) \{ attributes \{ attribute\(Category.CATEGORY\_ATTRIBUTE, objects.named\(Category, Category.REGULAR\_PLATFORM\)\) \} \} using module\('com.google.guava:guava:28.2-jre'\) \} \}

 

1

configurations.all \{

2

 resolutionStrategy.dependencySubstitution \{

3

 substitute variant\(module\('com.google.guava:guava:28.2-jre'\)\) \{

4

 attributes \{

5

 attribute\(Category.CATEGORY\_ATTRIBUTE, objects.named\(Category, Category.REGULAR\_PLATFORM\)\)

6

 \}

7

 \} using module\('com.google.guava:guava:28.2-jre'\)

8

 \}

9

\}

请参考[Substitution DSL API文档]()，以获取变体替代API的完整参考。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>在</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>复合构建中</font></font></a><font><font>，不应用您必须匹配所请求的确切依赖属性的规则：使用复合时，Gradle将自动匹配所请求的属性。</font><font>换句话说，如果您包含另一个构建，则意味着您</font><font>要用包含的构建中的等效变体替换替换模块的</font></font><em style="font-style:italic;"><font><font>所有变体</font></font></em><font><font>。</font></font></p></div></td></tr></tbody></table>

#### [](#sec:substitution_with_capabilities)[用具有功能的依赖项替换依赖项](#sec:substitution_with_capabilities)

与[属性替换](#sec:substitution_with_attributes)类似，Gradle允许您将具有或不具有功能的依赖项替换为具有或不具有功能的另一个依赖项。

例如，假设您需要用其[测试治具]()替代常规依赖项。您可以使用以下依赖项替换规则来实现此目的：

例子10.用测试夹具代替一个依赖

`Groovy``Kotlin`

build.gradle

configurations.testCompileClasspath \{ resolutionStrategy.dependencySubstitution \{ substitute\(module\('com.acme:lib:1.0'\)\) .using variant\(module\('com.acme:lib:1.0'\)\) \{ capabilities \{ requireCapability\('com.acme:lib-test-fixtures'\) \} \} \} \}

 

1

configurations.testCompileClasspath \{

2

 resolutionStrategy.dependencySubstitution \{

3

 substitute\(module\('com.acme:lib:1.0'\)\)

4

 .using variant\(module\('com.acme:lib:1.0'\)\) \{

5

 capabilities \{

6

 requireCapability\('com.acme:lib-test-fixtures'\)

7

 \}

8

 \}

9

 \}

10

\}

其在所请求的相关性的变换规则声明功能构成的依赖性匹配规范的一部分，因此其不依赖_不_要求能力不会被匹配。

请参考[Substitution DSL API文档]()，以获取变体替代API的完整参考。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-warning"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>在</font></font><a href="" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>复合构建中</font></font></a><font><font>，不应用您必须精确匹配请求的依赖功能的规则：使用复合时，Gradle将自动匹配请求的功能。</font><font>换句话说，如果您包括另一个版本，则意味着您</font><font>要用包含的版本中的等效变体替换替换模块的</font></font><em style="font-style:italic;"><font><font>所有variants_</font></font></em><font><font>。]</font></font></p></div></td></tr></tbody></table>

### [](#sec:substitution_with_classifier)[用分类器或工件替换依赖项](#sec:substitution_with_classifier)

虽然通常通过组/工件/版本坐标来寻址外部模块，但是通常会发布此类模块并附带其他工件，您可能希望使用它们来代替主要工件。对于_分类的_工件，通常是这种情况，但是您可能还需要选择具有不同文件类型或扩展名的工件。Gradle不鼓励在依赖项中使用分类器，而是倾向于将此类工件建模为[模块的其他变体]()。使用变量而不是分类的工件有很多优点，包括但不仅限于这些工件的一组不同的依赖关系。

但是，为了帮助桥接两个模型，Gradle提供了在替换规则中更改或删除分类器的方法。

例子11.依赖关系会导致解析错误

`Groovy``Kotlin`

消费者/build.gradle

dependencies \{ implementation 'com.google.guava:guava:28.2-jre' implementation 'co.paralleluniverse:quasar-core:0.8.0' implementation project\(':lib'\) \}

 

1

dependencies \{

2

 implementation 'com.google.guava:guava:28.2-jre'

3

 implementation 'co.paralleluniverse:quasar-core:0.8.0'

4

 implementation project\(':lib'\)

5

\}

在上面的示例中，第一级依赖`quasar`使我们认为Gradle可以解决，`quasar-core-0.8.0.jar`但事实并非如此：构建会因以下消息而失败：

Execution failed for task ':resolve'. > Could not resolve all files for configuration ':runtimeClasspath'. > Could not find quasar-core-0.8.0-jdk8.jar \(co.paralleluniverse:quasar-core:0.8.0\). Searched in the following locations: https://jcenter.bintray.com/co/paralleluniverse/quasar-core/0.8.0/quasar-core-0.8.0-jdk8.jar

 

1

Execution failed for task ':resolve'.

2

\> Could not resolve all files for configuration ':runtimeClasspath'.

3

 \> Could not find quasar\-core\-0.8.0\-jdk8.jar \(co.paralleluniverse:quasar\-core:0.8.0\).

4

 Searched in the following locations:

5

 https://jcenter.bintray.com/co/paralleluniverse/quasar-core/0.8.0/quasar-core-0.8.0-jdk8.jar

这是因为存在对另一个项目的依赖，该项目`lib`本身依赖于的不同版本`quasar-core`：

例子12.一个“分类的”依赖

`Groovy``Kotlin`

lib / build.gradle

dependencies \{ implementation "co.paralleluniverse:quasar-core:0.7.12\_r3:jdk8" \}

 

1

dependencies \{

2

 implementation "co.paralleluniverse:quasar-core:0.7.12\_r3:jdk8"

3

\}

发生的是，Gradle将在`quasar-core`0.8.0到`quasar-core`0.7.12\_r3之间执行冲突解决。因为0.8.0更高，所以我们选择此版本，但是其中的依赖项`lib`具有分类器，`jdk8`并且此分类_器_在版本0.8.0_中不再存在_。

要解决此问题，您可以要求Gradle在_没有分类器的情况下_解决这两个依赖项：

例子13.禁用分类器选择的解析规则

`Groovy``Kotlin`

消费者/build.gradle

configurations.all \{ resolutionStrategy.dependencySubstitution \{ substitute module\('co.paralleluniverse:quasar-core'\) using module\('co.paralleluniverse:quasar-core:0.8.0'\) withoutClassifier\(\) \} \}

 

1

configurations.all \{

2

 resolutionStrategy.dependencySubstitution \{

3

 substitute module\('co.paralleluniverse:quasar-core'\) using module\('co.paralleluniverse:quasar-core:0.8.0'\) withoutClassifier\(\)

4

 \}

5

\}

该规则有效地用`quasar-core`没有分类器的依赖项替换了在图中找到的所有依赖项。

另外，也可以选择_具有_特定分类器的依赖项_，_或者，对于更特定的用例，可以选择非常特定的工件（类型，扩展名和分类器）代替。

有关更多信息，请参考以下API文档：

* 通过[替代DSL]()选择工件
* 通过[DependencySubstitution API]()选择工件
* 通过[ResolutionStrategy API]()选择工件

## [](#sec:disabling_resolution_transitive_dependencies)[禁用传递解析](#sec:disabling_resolution_transitive_dependencies)

默认情况下，Gradle解析依赖项元数据指定的所有传递依赖项。有时，例如，如果元数据不正确或定义了较大的传递依赖关系图，则此行为可能是不希望的。你可以告诉摇篮到禁用依赖管理通过设定依赖[ModuleDependency.setTransitive（布尔）]()来`false`。结果，只有主工件才可以解决声明的依赖项。

例子14.为声明的依赖项禁用传递依赖项解析

`Groovy``Kotlin`

build.gradle

dependencies \{ implementation\('com.google.guava:guava:23.0'\) \{ transitive = false \} \}

 

1

dependencies \{

2

 implementation\('com.google.guava:guava:23.0'\) \{

3

 transitive \= false

4

 \}

5

\}

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>禁用传递依赖项解析可能需要您在构建脚本中声明必要的运行时依赖项，否则将自动解决。</font><font>否则可能会导致运行时类路径问题。</font></font></p></div></td></tr></tbody></table>

项目可以决定完全禁用传递依赖项解析。您或者不想依赖发布到使用的存储库的元数据，或者想要完全控制图形中的依赖项。有关更多信息，请参见[Configuration.setTransitive（boolean）]()。

例子15.在配置级禁用传递依赖项解析

`Groovy``Kotlin`

build.gradle

configurations.all \{ transitive = false \} dependencies \{ implementation 'com.google.guava:guava:23.0' \}

 

1

configurations.all \{

2

 transitive \= false

3

\}

4

5

dependencies \{

6

 implementation 'com.google.guava:guava:23.0'

7

\}

## [](#changing_configuration_dependencies_prior_to_resolution)[在解决之前更改配置依赖性](#changing_configuration_dependencies_prior_to_resolution)

有时，插件可能要在解决配置之前修改其依赖关系。该`withDependencies`方法允许以编程方式添加，删除或修改依赖项。

例子16.修改对配置的依赖

`Groovy``Kotlin`

build.gradle

configurations \{ implementation \{ withDependencies \{ DependencySet dependencies -> ExternalModuleDependency dep = dependencies.find \{ it.name == 'to-modify' \} as ExternalModuleDependency dep.version \{ strictly "1.2" \} \} \} \}

 

1

configurations \{

2

 implementation \{

3

 withDependencies \{ DependencySet dependencies \->

4

 ExternalModuleDependency dep \= dependencies.find \{ it.name \== 'to-modify' \} as ExternalModuleDependency

5

 dep.version \{

6

 strictly "1.2"

7

 \}

8

 \}

9

 \}

10

\}

## [](#sec:configuration_defaults)[设置默认配置依赖项](#sec:configuration_defaults)

如果未为配置显式设置依赖项，则可以使用默认依赖项来配置配置。此功能的主要用例是开发使用用户可能会覆盖的版本控制工具的插件。通过指定默认依赖关系，只有在用户未指定要使用的特定版本时，插件才能使用该工具的默认版本。

示例17.指定配置的默认依赖项

`Groovy``Kotlin`

build.gradle

configurations \{ pluginTool \{ defaultDependencies \{ dependencies -> dependencies.add\(project.dependencies.create\("org.gradle:my-util:1.0"\)\) \} \} \}

 

1

configurations \{

2

 pluginTool \{

3

 defaultDependencies \{ dependencies \->

4

 dependencies.add\(project.dependencies.create\("org.gradle:my-util:1.0"\)\)

5

 \}

6

 \}

7

\}

## [](#excluding_a_dependency_from_a_configuration_completely)[从配置中完全排除依赖项](#excluding_a_dependency_from_a_configuration_completely)

与[在依赖项声明]()中排除[依赖项]()类似，您可以使用[Configuration.exclude（java.util.Map）]()完全排除特定配置的传递性依赖项。对于配置上声明的所有依赖关系，这将自动排除传递依赖关系。

例子18.排除特定配置的传递依赖

`Groovy``Kotlin`

build.gradle

configurations \{ implementation \{ exclude group: 'commons-collections', module: 'commons-collections' \} \} dependencies \{ implementation 'commons-beanutils:commons-beanutils:1.9.4' implementation 'com.opencsv:opencsv:4.6' \}

 

1

configurations \{

2

 implementation \{

3

 exclude group: 'commons-collections', module: 'commons-collections'

4

 \}

5

\}

6

7

dependencies \{

8

 implementation 'commons-beanutils:commons-beanutils:1.9.4'

9

 implementation 'com.opencsv:opencsv:4.6'

10

\}

## [](#matching_dependencies_to_repositories)[将依赖项与存储库进行匹配](#matching_dependencies_to_repositories)

Gradle公开了一个API，以声明存储库可能包含或不包含的内容。此功能提供了对哪个存储库提供哪些工件的精细控制，这可以是控制依赖项来源的一种方法。

请转至[有关存储库内容过滤的部分，]()以了解有关此功能的更多信息。

## [](#sec:ivy_dynamic_resolve_mode)[启用常春藤动态解析模式](#sec:ivy_dynamic_resolve_mode)

Gradle的Ivy存储库实现支持等同于Ivy的动态解析模式。通常，Gradle会将`rev`属性用于`ivy.xml`文件中包含的每个依赖项定义。在动态解析模式下，对于给定的依赖项定义，Gradle将优先选择该`revConstraint`属性`rev`。如果该`revConstraint`属性不存在，`rev`则使用该属性。

要启用动态解析模式，您需要在存储库定义中设置适当的选项。下面显示了两个示例。请注意，动态解析模式仅适用于Gradle的Ivy存储库。它不适用于Maven存储库或自定义Ivy`DependencyResolver`实现。

例子19.启用动态解析模式

`Groovy``Kotlin`

build.gradle

// Can enable dynamic resolve mode when you define the repository repositories \{ ivy \{ url "http://repo.mycompany.com/repo" resolve.dynamicMode = true \} \} // Can use a rule instead to enable \(or disable\) dynamic resolve mode for all repositories repositories.withType\(IvyArtifactRepository\) \{ resolve.dynamicMode = true \}

 

1

// Can enable dynamic resolve mode when you define the repository

2

repositories \{

3

 ivy \{

4

 url "http://repo.mycompany.com/repo"

5

 resolve.dynamicMode \= true

6

 \}

7

\}

8

9

// Can use a rule instead to enable \(or disable\) dynamic resolve mode for all repositories

10

repositories.withType\(IvyArtifactRepository\) \{

11

 resolve.dynamicMode \= true

12

\}