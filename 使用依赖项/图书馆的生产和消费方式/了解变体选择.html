 无标题 <style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body { padding-left: 48px; padding-right: 48px;}</style><style id="wiz_code_style">.wiz-editor-body .wiz-code-container{position: relative; padding:8px 0; margin: 5px 0;text-indent:0; text-align:left;}.CodeMirror {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; color: black; font-size: 10.5pt; font-size: 0.875rem}.wiz-editor-body .wiz-code-container .CodeMirror div {margin-top: 0; margin-bottom: 0;}.CodeMirror-lines {padding: 4px 0;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {padding: 0 4px;}.CodeMirror pre.CodeMirror-line {min-height: 24px;}.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {background-color: white;}.CodeMirror-gutters {border-right: 1px solid #ddd; background-color: #f7f7f7; white-space: nowrap;}.CodeMirror-linenumbers {}.CodeMirror-linenumber {padding: 0 3px 0 5px; min-width: 20px; text-align: right; color: #999; white-space: nowrap;}.CodeMirror-guttermarker {color: black;}.CodeMirror-guttermarker-subtle {color: #999;}.CodeMirror-cursor {border-left: 1px solid black; border-right: none; width: 0;}.CodeMirror div.CodeMirror-secondarycursor {border-left: 1px solid silver;}.cm-fat-cursor .CodeMirror-cursor {width: auto; border: 0 !important; background: #7e7;}.cm-fat-cursor div.CodeMirror-cursors {z-index: 1;}.cm-fat-cursor-mark {background-color: rgba(20, 255, 20, 0.5);-webkit-animation: blink 1.06s steps(1) infinite;-moz-animation: blink 1.06s steps(1) infinite;animation: blink 1.06s steps(1) infinite;}.cm-animate-fat-cursor {width: auto; border: 0; -webkit-animation: blink 1.06s steps(1) infinite; -moz-animation: blink 1.06s steps(1) infinite; animation: blink 1.06s steps(1) infinite; background-color: #7e7;}@-moz-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@-webkit-keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}@keyframes blink { 0% {} 50% { background-color: transparent; } 100% {}}.CodeMirror-overwrite .CodeMirror-cursor {}.cm-tab { display: inline-block; text-decoration: inherit; }.CodeMirror-rulers {position: absolute; left: 0; right: 0; top: -50px; bottom: -20px; overflow: hidden;}.CodeMirror-ruler {border-left: 1px solid #ccc; top: 0; bottom: 0; position: absolute;}.cm-s-default .cm-header {color: blue;}.cm-s-default .cm-quote {color: #090;}.cm-negative {color: #d44;}.cm-positive {color: #292;}.cm-header, .cm-strong {font-weight: bold;}.cm-em {font-style: italic;}.cm-link {text-decoration: underline;}.cm-strikethrough {text-decoration: line-through;}.cm-s-default .cm-keyword {color: #708;}.cm-s-default .cm-atom {color: #219;}.cm-s-default .cm-number {color: #164;}.cm-s-default .cm-def {color: #00f;}.cm-s-default .cm-variable,.cm-s-default .cm-punctuation,.cm-s-default .cm-property,.cm-s-default .cm-operator {}.cm-s-default .cm-variable-2 {color: #05a;}.cm-s-default .cm-variable-3 {color: #085;}.cm-s-default .cm-comment {color: #a50;}.cm-s-default .cm-string {color: #a11;}.cm-s-default .cm-string-2 {color: #f50;}.cm-s-default .cm-meta {color: #555;}.cm-s-default .cm-qualifier {color: #555;}.cm-s-default .cm-builtin {color: #30a;}.cm-s-default .cm-bracket {color: #997;}.cm-s-default .cm-tag {color: #170;}.cm-s-default .cm-attribute {color: #00c;}.cm-s-default .cm-hr {color: #999;}.cm-s-default .cm-link {color: #00c;}.cm-s-default .cm-error {color: #f00;}.cm-invalidchar {color: #f00;}.CodeMirror-composing { border-bottom: 2px solid; }div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }.CodeMirror-activeline-background {background: #e8f2ff;}.CodeMirror {position: relative; background: #f5f5f5;}.CodeMirror-scroll {overflow: hidden !important; margin-bottom: 0; margin-right: -30px; padding: 16px 30px 16px 0; outline: none; position: relative;}.CodeMirror-sizer {position: relative; border-right: 30px solid transparent;}.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {position: absolute; z-index: 6; display: none;}.CodeMirror-vscrollbar {right: 0; top: 0; overflow-x: hidden; overflow-y: scroll;}.CodeMirror-hscrollbar {bottom: 0; left: 0 !important; overflow-y: hidden; overflow-x: scroll;pointer-events: auto !important;outline: none;}.CodeMirror-scrollbar-filler {right: 0; bottom: 0;}.CodeMirror-gutter-filler {left: 0; bottom: 0;}.CodeMirror-gutters {position: absolute; left: 0; top: 0; min-height: 100%; z-index: 3;}.CodeMirror-gutter {white-space: normal; height: 100%; display: inline-block; vertical-align: top; margin-bottom: -30px;}.CodeMirror-gutter-wrapper {position: absolute; z-index: 4; background: none !important; border: none !important;}.CodeMirror-gutter-background {position: absolute; top: 0; bottom: 0; z-index: 4;}.CodeMirror-gutter-elt {position: absolute; cursor: default; z-index: 4;}.CodeMirror-gutter-wrapper ::selection { background-color: transparent }.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }.CodeMirror-lines {cursor: text; min-height: 1px;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like {-moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0; border-width: 0; background: transparent; font-family: inherit; font-size: inherit; margin: 0; white-space: pre; word-wrap: normal; line-height: inherit; color: inherit; z-index: 2; position: relative; overflow: visible; -webkit-tap-highlight-color: transparent; -webkit-font-variant-ligatures: contextual; font-variant-ligatures: contextual;}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like {word-wrap: break-word; white-space: pre-wrap; word-break: normal;}.CodeMirror-linebackground {position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;}.CodeMirror-linewidget {position: relative; z-index: 2; padding: 0.1px;}.CodeMirror-widget {}.CodeMirror-rtl pre { direction: rtl; }.CodeMirror-code {outline: none;}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {-moz-box-sizing: content-box; box-sizing: content-box;}.CodeMirror-measure {position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;}.CodeMirror-cursor {position: absolute; pointer-events: none;}.CodeMirror-measure pre { position: static; }div.CodeMirror-cursors {visibility: hidden; position: relative; z-index: 3;}div.CodeMirror-dragcursors {visibility: visible;}.CodeMirror-focused div.CodeMirror-cursors {visibility: visible;}.CodeMirror-selected { background: #d9d9d9; }.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }.CodeMirror-crosshair { cursor: crosshair; }.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }.cm-searching {background: #ffa; background: rgba(255, 255, 0, .4);}.cm-force-border { padding-right: .1px; }@media print { .CodeMirror div.CodeMirror-cursors {visibility: hidden;}}.cm-tab-wrap-hack:after { content: ""; }span.CodeMirror-selectedtext { background: none; }.CodeMirror-activeline-background, .CodeMirror-selected {transition: visibility 0ms 100ms;}.CodeMirror-blur .CodeMirror-activeline-background, .CodeMirror-blur .CodeMirror-selected {visibility:hidden;}.CodeMirror-blur .CodeMirror-matchingbracket {color:inherit !important;outline:none !important;text-decoration:none !important;}.CodeMirror-sizer {min-height:auto !important;}</style>

# 了解变体选择

内容

* [配置和变量属性](#sec:abm_configuration_attributes)
* [可视化变体信息](#sec:variant-visual)
* [变体匹配](#sec:variant-aware-matching)
* [变体选择错误](#sec:variant-select-errors)
* [从Maven / Ivy映射到变体](#sec:mapping-maven-ivy-to-variants)

Gradle的依赖管理引擎称为_变体感知_。在像Apache Maven™这样的传统依赖管理引擎中，依赖关系被绑定到在GAV坐标处发布的组件。这意味着组件的传递依赖项集仅由该组件的GAV坐标确定。实际解决什么_工件_都没有关系，依赖关系的集合_始终相同_。另外，为组件选择不同的工件（例如，使用`jdk7`工件）很麻烦，因为它需要使用_分类器_。该模型的一个问题是它不能保证全局图的一致性，因为没有与之关联的通用语义。_分类器_。这意味着没有什么可以阻止在类路径上同时使用单个模块的`jdk7`和`jdk8`版本，因为引擎不知道分类器名称与什么语义相关联。

图1. Maven组件模型

除了在GAV坐标处发布的_模块_的概念外，Gradle还介绍了此模块的_变体_的概念。变体对应于在相同GAV坐标处发布的组件的不同“视图”。在Gradle模型中，工件被附加到_变量_而不是模块。实际上，这意味着不同的_工件_可以具有不同的依赖关系集：

图2. Gradle组件模型

这个中间级别将工件和依赖项与变量关联，而不是直接与组件相关联，使Gradle可以正确地建模每个工件的用途。

但是，这引发了有关如何选择变体的问题：当存在多个变体时，Gradle如何知道要选择哪个变体？实际上，由于使用了[属性]()，因此选择了变体，这些[属性]()为变体提供了语义，并有助于引擎获得_一致的解析结果_。

由于历史原因，Gradle区分两种组件：

* 从源构建的本地组件，其[变体映射到传出配置](#sec:abm_configuration_attributes)
* 外部组件，在存储库上发布，在这种情况下，该模块要么通过Gradle Module Metadata发布，并且本机支持变体，要么该模块使用Ivy / Maven元数据，而[变体则从元数据派生](#sec:mapping-maven-ivy-to-variants)。

在这两种情况下，Gradle都会执行_变体感知选择_。

## [](#sec:abm_configuration_attributes)[配置和变量属性](#sec:abm_configuration_attributes)

本地组件将变体作为_外发配置_公开，这是[消耗性配置]()。发生依赖关系解决方案时，引擎将通过选择其_消耗品配置_之一来选择输出组件的一种变体。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="paragraph"><p style="font-size: 1rem;"><font><font>此规则有2个明显的例外：</font></font></p></div><div class="ulist"><ul style="font-size:1rem;"><li><span><font><font>只要制作者</font></font><em style="font-style:italic;"><font><font>不</font></font></em><font><font>暴露任何消耗品配置</font></font></span></li><li><span><font><font>每当使用者</font></font><em style="font-style:italic;"><font><font>明确选择目标配置时</font></font></em></span></li></ul></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>在这种情况下，</font></font><em style="font-style:italic;"><font><font>绕过变体感知分辨率</font></font></em><font><font>。</font></font></p></div></td></tr></tbody></table>

在_可解析配置_（也称为_使用者_）和_消耗性配置_（在_生产者_）上都使用属性。将属性添加到其他类型的配置中根本没有效果，因为属性不会在配置之间继承。

依赖解析引擎的作用是寻找合适的_变种_a的_生产商_给定一个表示的约束_消费者_。

这就是属性发挥作用的地方：它们的作用是执行组件的正确_变体_的选择。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="title" style="color:rgb(85, 85, 85);font-size:1.25rem;"><font><font>变体与配置</font></font></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>对于外部组件，术语是使用“</font></font><em style="font-style:italic;"><font><font>变体</font></font></em><font><font>”一词</font><font>，而不是“</font></font><em style="font-style:italic;"><font><font>配置</font></font></em><font><font>”一词</font><font>。</font><font>配置是变体的超集。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>这意味着外部组件提供了</font></font><em style="font-style:italic;"><font><font>variants</font></font></em><font><font>，它们也具有属性。</font><font>但是，有时由于</font><font>历史原因或由于您使用也具有这种</font><em style="font-style:italic;"><font>配置</font></em><font>概念的Ivy，</font><font>术语</font></font><em style="font-style:italic;"><font><font>配置</font></font></em><font><font>可能会泄漏到DSL中</font><font>。</font></font><em style="font-style:italic;"><font></font></em><font></font></p></div></td></tr></tbody></table>

## [](#sec:variant-visual)[可视化变体信息](#sec:variant-visual)

Gradle提供了一个名为Report的报告任务`outgoingVariants`，该任务显示项目的变体及其功能，属性和工件。从概念上讲，它类似于`dependencyInsight`[报告任务]()。

默认情况下，`outgoingVariants`打印有关所有变体的信息。它提供了可选参数`--variant <variantName>`以选择要显示的单个变体。它还接受该`--all`标志以包含有关旧配置和不建议使用的配置的信息。

这是`outgoingVariants`新生成的`java-library`项目上的任务输出：

\>任务：待发变量 -------------------------------------------------- 变体apiElements -------------------------------------------------- 描述= main的API元素。
 能力 -\[默认功能\] 属性 -org.gradle.category =库 -org.gradle.dependency.bundling =外部 -org.gradle.jvm.version = 8 -org.gradle.libraryelements = jar -org.gradle.usage = java-api
 伪像 -build / libs / variant-report.jar（artifactType = jar）
 次要变体（\*） -变体：类 -属性 -org.gradle.category =库 -org.gradle.dependency.bundling =外部 -org.gradle.jvm.version = 8 -org.gradle.libraryelements =类 -org.gradle.usage = java-api -文物 -build / classes / java / main（artifactType = java-classes-directory）
 -------------------------------------------------- 变体runtime元素 -------------------------------------------------- 描述= main的运行时元素。
 能力 -\[默认功能\] 属性 -org.gradle.category =库 -org.gradle.dependency.bundling =外部 -org.gradle.jvm.version = 8 -org.gradle.libraryelements = jar -org.gradle.usage = Java运行时
 伪像 -build / libs / variant-report.jar（artifactType = jar）
 次要变体（\*） -变体：类 -属性 -org.gradle.category =库 -org.gradle.dependency.bundling =外部 -org.gradle.jvm.version = 8 -org.gradle.libraryelements =类 -org.gradle.usage = Java运行时 -文物 -build / classes / java / main（artifactType = java-classes-directory） -变体：资源 -属性 -org.gradle.category =库 -org.gradle.dependency.bundling =外部 -org.gradle.jvm.version = 8 -org.gradle.libraryelements =资源 -org.gradle.usage = Java运行时 -文物 -构建/资源/主（artifactType = java-resources-directory）
 （\*）次要变体是通过Configuration＃getOutgoing（）：ConfigurationPublications API创建的变体，除了配置本身之外，它们还参与选择。

从中可以看到java库`apiElements`和公开的两个主要变体`runtimeElements`。请注意，主要区别在于`org.gradle.usage`属性上的值`java-api`和`java-runtime`。正如他们所指出的，这是消费者的_编译_类路径上需要的内容与_运行时_类路径上需要的内容之间的区别。

它还显示了_次级_变体，这些变体是Gradle项目专有的，未发布。例如，`classes`from的第二个变体`apiElements`是让Gradle在针对[`java-library`project进行]()编译时跳过JAR创建。

## [](#sec:variant-aware-matching)[变体匹配](#sec:variant-aware-matching)

让我们以一个`lib`库的示例为例，该库公开了2个变体：其API（通过名为的变体`exposedApi`）和运行时（通过名为的变体`exposedRuntime`）。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="title" style="color:rgb(85, 85, 85);font-size:1.25rem;"><font><font>关于生产者变体</font></font></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>此处存在</font><font>变体</font></font><em style="font-style:italic;"><font><font>名称</font></font></em><font><font>，主要用于调试目的并在错误消息中获得更好的显示。</font><font>特别是，名称不参与</font><font>变体</font><font>的</font></font><em style="font-style:italic;"><font><font>ID</font></font></em><font><font>：只有其属性参与。</font><font>也就是说，要搜索特定的变体，</font></font><em style="font-style:italic;"><font><font>必须</font></font></em><font><font>依靠其属性</font></font><em style="font-style:italic;"><font><font>而不是</font></font></em><font><font>其名称。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>组件可以公开的变体数量没有限制。</font><font>传统上，一个组件会公开一个API和一个实现，但是例如，我们可能也想公开一个组件的测试装置。</font><font>也可以</font><font>为不同的使用者提供</font></font><em style="font-style:italic;"><font><font>不同的API</font></font></em><font><font>（考虑一下不同的环境，例如Linux与Windows）。</font></font></p></div></td></tr></tbody></table>

消费者需要解释它需要_什么_变体，这是通过在_消费者_上设置_属性_来完成的。

属性由_名称_和_值_对组成。例如，Gradle带有一个标准名称，该名称`org.gradle.usage`专门用于处理根据使用者的使用情况（编译，运行时...）选择组件的正确变体的概念。但是可以定义任意数量的属性。作为生产者，我们可以通过将`(org.gradle.usage,JAVA_API)`属性附加到变量来表示消耗性配置代表组件的API。作为使用者，我们可以通过将`(org.gradle.usage,JAVA_API)`属性附加到可解析配置的依赖关系中来表达它。为此，Gradle可以通过查看配置属性来_自动选择适当的变体_：

* 消费者想要`org.gradle.usage=JAVA_API`
* 生产者，`lib`展示了2种不同的变体。一个带`org.gradle.usage=JAVA_API`，另一个带`org.gradle.usage=JAVA_RUNTIME`。
* Gradle选择`org.gradle.usage=JAVA_API`生产者的变体，因为它_与消费者属性匹配_

换句话说：属性用于根据属性的值执行选择。

一个更详细的示例涉及多个属性。通常，Gradle中的Java库项目将涉及4个不同的属性，在生产者和消费者方面都可以找到：

* `org.gradle.usage`，说明变体是组件的API还是其实现
* `org.gradle.dependency.bundling`，它声明如何捆绑组件的依赖项（例如，如果工件是一个胖子，那么捆绑是`EMBEDDED`）
* `org.gradle.libraryelements`，用于说明变体包含库的哪些_部分_（类，资源或所有内容）
* `org.gradle.jvm.version`，用于说明此变体针对的_最低_Java_版本_

现在，假设我们的库具有两种不同的风格：

* 一个用于JDK 8
* 一个用于JDK 9+

在Maven中，这通常是通过生成2种不同的工件（“主”工件和“分类”工件）来实现的。但是，在Maven中，使用者无法表达其需要基于运行时的_最合适_版本的库这一事实。

使用Gradle，可以通过让生产者声明两个变体来优雅地解决此问题：

* 一个`org.gradle.jvm.version=8`，_至少在JDK 8上运行的用户_
* 一个用`org.gradle.jvm.version=9`，为消费者从JDK 9开始

注意，这两个变体的工件会有所不同，但它们的依存关系_也可能_会有所不同。通常，JDK 8变体可能需要JDK 9+的“反向端口”库才能起作用，只有在JDK 8上运行的使用者才能使用。

在使用者方面，_可解析配置_将在上面设置所有四个属性，并且根据运行时将其设置`org.gradle.jvm.version`为8或更多。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="title" style="color:rgb(85, 85, 85);font-size:1.25rem;"><font><font>有关变体兼容性的说明</font></font></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>如果消费者设置</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">org.gradle.jvm.version</code><font><font>为7怎么办？</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>然后解析将</font></font><em style="font-style:italic;"><font><font>失败，</font></font></em><font><font>并显示一条错误消息，说明生产者没有匹配的变体。</font><font>这是因为Gradle认识到消费者希望使用Java 7兼容的库，但是</font><font>生产者可用的Java</font><font>的</font></font><em style="font-style:italic;"><font><font>最低</font></font></em><font><font>版本是8。如果另一方面，消费者需要</font></font><em style="font-style:italic;"><font><font>11</font></font></em><font><font>，则Gradle知道</font></font><em style="font-style:italic;"><font><font>8</font></font></em><font><font>和</font></font><em style="font-style:italic;"><font><font>9</font></font></em><font><font>变体都可以。可以，但是它将选择</font></font><em style="font-style:italic;"><font><font>9，</font></font></em><font><font>因为它是最高兼容版本。</font></font></p></div></td></tr></tbody></table>

## [](#sec:variant-select-errors)[变体选择错误](#sec:variant-select-errors)

在标识组件的正确变体的过程中，两种情况将导致分辨率错误：

* 生产者的多个变体与消费者属性相匹配，存在变体歧义
* 生产者的任何变体都不符合消费者的属性

### [](#sub:variant-ambiguity)[处理模棱两可的变量选择错误](#sub:variant-ambiguity)

模棱两可的变量选择看起来如下所示：

\>无法解析配置'：compileClasspath'的所有文件。 >无法解析项目：lib。 要求： 项目：ui >无法在project的以下变体：lib之间进行选择： -feature1ApiElements -feature2ApiElements 它们都符合使用者属性： -变体'feature1ApiElements'功能org.test：test-capability：1.0： -不匹配的属性： -找到org.gradle.category'library'，但不是必需的。 -兼容的属性： -提供org.gradle.dependency.bundle的'external' -提供org.gradle.jvm.version'11' -必需的org.gradle.libraryelements“类”和发现值“ jar”。 -提供org.gradle.usage'java-api' -变体'feature2ApiElements'功能org.test：test-capability：1.0： -不匹配的属性： -找到org.gradle.category'library'，但不是必需的。 -兼容的属性： -提供org.gradle.dependency.bundle的'external' -提供org.gradle.jvm.version'11' -必需的org.gradle.libraryelements“类”和发现值“ jar”。 -提供org.gradle.usage'java-api'

可以看到，显示了所有_兼容的_候选变体及其属性。然后将它们分为两个部分：

* 首先介绍不匹配的属性，因为它们可能是选择适当变体时缺少的部分。
* 其次显示兼容的属性，因为它们指示消费者想要什么以及这些变体如何匹配该请求。

不能有任何不匹配的属性，因为那时变体将不是候选者。同样，显示的变体集也排除了已消除歧义的变体。

在上面的示例中，解决方法不在于属性匹配，而在于[功能匹配]()，该功能显示在变量名称旁边。因为这两个变体有效地提供了相同的属性和功能，所以它们不会被歧义。因此，在这种情况下，此修补程序最有可能在生产者端（`project :lib`）提供不同的功能，并在消费者端（`project :ui`）表达功能的选择。

### [](#sub:variant-no-match)[处理无匹配的变体错误](#sub:variant-no-match)

没有匹配的变体错误如下所示：

\>项目：lib的任何变体均不符合使用者属性： -配置'：lib：compile'： -不兼容的属性： -必需的artifactType“ dll”，并且发现不兼容的值“ jar”。 -其他兼容属性： -提供用法“ api” -配置'：lib：compile'变量调试： -不兼容的属性： -必需的artifactType“ dll”，并且发现不兼容的值“ jar”。 -其他兼容属性： -找到buildType'debug'，但不是必需的。 -提供用法“ api” -配置'：lib：compile'变体版本： -不兼容的属性： -必需的artifactType“ dll”，并且发现不兼容的值“ jar”。 -其他兼容属性： -找到buildType'release'，但不是必需的。 -提供用法“ api”

可以看到，显示了_所有_候选变体及其属性。然后将它们分为两个部分：

* 首先介绍不兼容的属性，因为它们通常是理解为什么无法选择变体的关键。
* 其次显示其他属性，包括_必需的_和_兼容_的属性，以及消费者不要求的所有其他_生产者_属性。

与模棱两可的变量错误类似，目标是了解要选择哪个变量，并查看可以针对使用者调整哪些属性或功能以实现此目的。

## [](#sec:mapping-maven-ivy-to-variants)[从Maven / Ivy映射到变体](#sec:mapping-maven-ivy-to-variants)

既不的Maven也不常春藤具有的概念_的变体_，其仅由本机模块摇篮元数据的支持。但是，由于不同的策略，它不会阻止Gradle与他们合作。

<table style="background:none;width:912px;"><tbody><tr><td class="icon" style="color:rgba(0, 0, 0, 0.8);width:80px;"><i class="fa icon-note"></i></td><td class="content" style="font-size:1.0625rem;color:rgba(0, 0, 0, 0.6);"><div class="title" style="color:rgb(85, 85, 85);font-size:1.25rem;"><font><font>与Gradle模块元数据的关系</font></font></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>Gradle模块元数据是在Maven，Ivy或其他类型的存储库上发布的模块的元数据格式。</font><font>它类似于</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">pom.xml</code><font><font>或</font></font><code style="font-family:Inconsolata, monospace;font-size:0.9375rem;color:rgba(0, 0, 0, 0.9);background-color:rgb(247, 247, 248);">ivy.xml</code><font><font>文件，但是这种格式可以</font></font><em style="font-style:italic;"><font><font>识别变体</font></font></em><font><font>。</font><font>这意味着，如果您的项目产生其他变体，则这些变体将作为模块元数据的一部分提供并发布，从而极大地改善用户体验。</font></font></p></div><div class="paragraph"><p style="font-size: 1rem;"><font><font>有关</font><font>更多信息，</font><font>请参见</font></font><a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md" style="color:rgb(29, 162, 189);text-decoration:none;"><font><font>Gradle模块元数据规范</font></font></a><font><font>。</font></font></p></div></td></tr></tbody></table>

### [](#sub:maven-mapping-to-variants)[将POM文件映射到变体](#sub:maven-mapping-to-variants)

在Maven存储库中发布的模块将转换为可识别变体的模块。Maven模块的特殊之处在于，无法知道发布了哪种组件。特别是，无法在代表_平台_的BOM和用作超级POM的BOM之间进行区分。有时，POM文件甚至有可能同时充当平台_和_库。

因此，Maven模块分为6个不同的变体，使Gradle用户可以准确地解释它们所依赖的内容：

* 2个“库”变体（属性`org.gradle.category`\=`library`）  

  * 该`compile`变种映射的`<scope>compile</scope>`依赖关系。此变体等效于[Java库插件]()的`apiElements`变体。此范围的所有依赖项均被视为_API依赖项_。
  * 该`runtime`变种都映射在`<scope>compile</scope>`和`<scope>runtime</scope>`依赖性。此变体等效于[Java库插件]()的`runtimeElements`变体。这些作用域的所有依赖关系都被视为_运行时依赖关系_。  

    * 在两种情况下，`<dependencyManagement>`依赖关系都_不会转换为约束_
* 从该`<dependencyManagement>`块派生的4个“平台”变体（属性`org.gradle.category`\=`platform`）：  

  * 该`platform-compile`变量将`<scope>compile</scope>`依赖管理依赖映射为_依赖约束_。
  * 该`platform-runtime`变体将`<scope>compile</scope>`和`<scope>runtime</scope>`依赖管理依赖都映射为_依赖约束_。
  * 在`enforced-platform-compile`类似于`platform-compile`但所有的约束_强制_
  * 在`enforced-platform-runtime`类似于`platform-runtime`但所有的约束_强制_

通过查看手册的“[导入BOM表”]()部分，您可以了解有关平台和强制平台变体用法的更多信息。默认情况下，每当您声明对Maven模块的依赖关系时，Gradle都会查找`library`变体。但是，使用`platform`or`enforcedPlatform`关键字，Gradle现在正在寻找“平台”变体之一，它允许您从POM文件中导入约束，而不是依赖关系。

### [](#sub:ivy-mapping-to-variants)[将常春藤文件映射到变体](#sub:ivy-mapping-to-variants)

与[Maven](#sub:maven-mapping-to-variants)相反，默认情况下没有为Ivy文件实现派生策略。这样做的原因是，与pom相反，Ivy是一种灵活的格式，允许您发布任意多个自定义_配置_。因此，通常在Ivy中没有编译/运行时范围或编译/运行时变体的概念。仅当您使用[Gravy发行版]()的[ivy-publish插件]()发布ivy文件时，您才能获得与pom文件类似的结构。但是，由于不能保证构建所使用的**所有**常春藤元数据文件都遵循此模式，因此Gradle无法基于该模式实施派生策略。

但是，如果要为Ivy的_编译_和_运行时_变体实现派生策略，则可以使用[组件元数据rule来实现]()。组件元数据规则API允许您[访问ivy配置]()并基于它们创建变体。如果您知道您使用的所有ivy模块都已通过Gradle发布，而无需对该`ivy.xml`文件进行进一步的自定义，则可以在构建中添加以下规则：

例子1.派生Ivy元数据的编译和运行时变体

`Groovy``Kotlin`

build.gradle

class IvyVariantDerivationRule implements ComponentMetadataRule \{ \@Inject ObjectFactory getObjects\(\) \{ \} void execute\(ComponentMetadataContext context\) \{ // This filters out any non Ivy module if\(context.getDescriptor\(IvyModuleDescriptor\) == null\) \{ return \} context.details.addVariant\("runtimeElements", "default"\) \{ attributes \{ attribute\(LibraryElements.LIBRARY\_ELEMENTS\_ATTRIBUTE, getObjects\(\).named\(LibraryElements, LibraryElements.JAR\)\) attribute\(Category.CATEGORY\_ATTRIBUTE, getObjects\(\).named\(Category, Category.LIBRARY\)\) attribute\(Usage.USAGE\_ATTRIBUTE, getObjects\(\).named\(Usage, Usage.JAVA\_RUNTIME\)\) \} \} context.details.addVariant\("apiElements", "compile"\) \{ attributes \{ attribute\(LibraryElements.LIBRARY\_ELEMENTS\_ATTRIBUTE, getObjects\(\).named\(LibraryElements, LibraryElements.JAR\)\) attribute\(Category.CATEGORY\_ATTRIBUTE, getObjects\(\).named\(Category, Category.LIBRARY\)\) attribute\(Usage.USAGE\_ATTRIBUTE, getObjects\(\).named\(Usage, Usage.JAVA\_API\)\) \} \} \} \} dependencies \{ components \{ all\(IvyVariantDerivationRule\) \} \}

 

1

class IvyVariantDerivationRule implements ComponentMetadataRule \{

2

 \@Inject ObjectFactory getObjects\(\) \{ \}

3

4

 void execute\(ComponentMetadataContext context\) \{

5

 // This filters out any non Ivy module

6

 if\(context.getDescriptor\(IvyModuleDescriptor\) \== null\) \{

7

 return

8

 \}

9

10

 context.details.addVariant\("runtimeElements", "default"\) \{

11

 attributes \{

12

 attribute\(LibraryElements.LIBRARY\_ELEMENTS\_ATTRIBUTE, getObjects\(\).named\(LibraryElements, LibraryElements.JAR\)\)

13

 attribute\(Category.CATEGORY\_ATTRIBUTE, getObjects\(\).named\(Category, Category.LIBRARY\)\)

14

 attribute\(Usage.USAGE\_ATTRIBUTE, getObjects\(\).named\(Usage, Usage.JAVA\_RUNTIME\)\)

15

 \}

16

 \}

17

 context.details.addVariant\("apiElements", "compile"\) \{

18

 attributes \{

19

 attribute\(LibraryElements.LIBRARY\_ELEMENTS\_ATTRIBUTE, getObjects\(\).named\(LibraryElements, LibraryElements.JAR\)\)

20

 attribute\(Category.CATEGORY\_ATTRIBUTE, getObjects\(\).named\(Category, Category.LIBRARY\)\)

21

 attribute\(Usage.USAGE\_ATTRIBUTE, getObjects\(\).named\(Usage, Usage.JAVA\_API\)\)

22

 \}

23

 \}

24

 \}

25

\}

26

27

dependencies \{

28

 components \{ all\(IvyVariantDerivationRule\) \}

29

\}

该规则`apiElements`基于每个ivy模块的配置创建一个变量，并基于`compile`配置创建一个变量。对于每个变体，它设置相应的[Java生态系统属性](#sec:variant-aware-matching)。变体的依赖关系和工件来自基础配置。如果不是所有消耗的常春藤模块都遵循此模式，则可以调整规则或仅将规则应用于选定的一组模块。`runtimeElements``default`[](#sec:variant-aware-matching)

对于没有体都常春藤模块，摇篮回落到原有配置选择（即摇篮并_没有_执行这些模块的变体意识到分辨率）。这意味着将选择`default`配置或在对相应模块的依赖性中显式定义的配置。（请注意，只有从构建脚本或常春藤元数据中才可以进行显式配置选择，并且应避免使用变量选择。）